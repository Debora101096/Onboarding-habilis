{"version":3,"file":"index.js","sources":["../src/runtime.ts","../src/index.ts"],"sourcesContent":["import * as qs from \"./query\";\nimport { joinUrl } from \"./util\";\nimport { ok } from \"./index\";\nimport { CustomHeaders, mergeHeaders, normalizeHeaders } from \"./headers\";\n\nexport { type CustomHeaders };\n\nexport type RequestOpts = {\n  baseUrl?: string;\n  fetch?: typeof fetch;\n  /** @deprecated Use RequestOpts.FormData instead */\n  formDataConstructor?: new () => FormData;\n  FormData?: new () => FormData;\n  headers?: HeadersInit | CustomHeaders;\n} & Omit<RequestInit, \"body\" | \"headers\">;\n\nexport type Defaults<Headers extends RequestOpts[\"headers\"] = CustomHeaders> =\n  Omit<RequestOpts, \"headers\" | \"baseUrl\"> & {\n    baseUrl: string;\n    headers: Headers;\n  };\n\ntype FetchRequestOpts = RequestOpts & {\n  body?: string | FormData | Blob;\n};\n\ntype JsonRequestOpts = RequestOpts & {\n  body?: any;\n};\n\ntype FormRequestOpts = RequestOpts & {\n  body?: Record<string, any>;\n};\n\nexport type ApiResponse = { status: number; data?: any };\n\nexport type WithHeaders<T extends ApiResponse> = T & { headers: Headers };\n\ntype MultipartRequestOpts = RequestOpts & {\n  body?: Record<string, unknown>;\n};\n\nexport function runtime(defaults: RequestOpts = {}) {\n  async function fetchText(url: string, req?: FetchRequestOpts) {\n    const res = await doFetch(url, req);\n    let data;\n    try {\n      data = await res.text();\n    } catch (err) {}\n\n    return {\n      status: res.status,\n      headers: res.headers,\n      contentType: res.headers.get(\"content-type\"),\n      data,\n    };\n  }\n\n  async function fetchJson<T extends ApiResponse>(\n    url: string,\n    req: FetchRequestOpts = {},\n  ) {\n    const { status, headers, contentType, data } = await fetchText(url, {\n      ...req,\n      headers: mergeHeaders(\n        {\n          Accept: \"application/json\",\n        },\n        req.headers,\n      ),\n    });\n\n    const isJson = contentType ? contentType.includes(\"json\") : false;\n\n    if (isJson) {\n      return {\n        status,\n        headers,\n        data: data ? JSON.parse(data) : null,\n      } as WithHeaders<T>;\n    }\n\n    return { status, headers, data } as WithHeaders<T>;\n  }\n\n  async function fetchBlob<T extends ApiResponse>(\n    url: string,\n    req: FetchRequestOpts = {},\n  ) {\n    const res = await doFetch(url, req);\n    let data;\n    try {\n      data = await res.blob();\n    } catch (err) {}\n    return { status: res.status, headers: res.headers, data } as WithHeaders<T>;\n  }\n\n  async function doFetch(url: string, req: FetchRequestOpts = {}) {\n    const {\n      baseUrl,\n      fetch: customFetch,\n      ...init\n    } = {\n      ...defaults,\n      ...req,\n      headers: mergeHeaders(defaults.headers, req.headers),\n    };\n    const href = joinUrl(baseUrl, url);\n    const res = await (customFetch || fetch)(href, init);\n    return res;\n  }\n\n  return {\n    ok,\n    fetchText,\n    fetchJson,\n    fetchBlob,\n    mergeHeaders,\n\n    json({ body, headers, ...req }: JsonRequestOpts) {\n      return {\n        ...req,\n        ...(body != null && { body: JSON.stringify(body) }),\n        headers: mergeHeaders(\n          {\n            \"Content-Type\": \"application/json\",\n          },\n          headers,\n        ),\n      };\n    },\n\n    form({ body, headers, ...req }: FormRequestOpts) {\n      return {\n        ...req,\n        ...(body != null && { body: qs.form(body) }),\n        headers: mergeHeaders(\n          {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          },\n          headers,\n        ),\n      };\n    },\n\n    multipart({ body, headers, ...req }: MultipartRequestOpts) {\n      if (body == null)\n        return { ...req, body, headers: normalizeHeaders(headers) };\n\n      const data = new (\n        req.FormData ||\n        req.formDataConstructor ||\n        defaults.FormData ||\n        defaults.formDataConstructor ||\n        FormData\n      )();\n\n      const append = (name: string, value: unknown) => {\n        if (typeof value === \"string\" || value instanceof Blob) {\n          data.append(name, value);\n        } else if (typeof value === \"number\" || typeof value === \"boolean\") {\n          data.append(name, String(value));\n        } else {\n          data.append(\n            name,\n            new Blob([JSON.stringify(value)], { type: \"application/json\" }),\n          );\n        }\n      };\n\n      Object.entries(body).forEach(([name, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((v) => append(name, v));\n        } else {\n          append(name, value);\n        }\n      });\n\n      return {\n        ...req,\n        body: data,\n        headers: normalizeHeaders(headers),\n      };\n    },\n  };\n}\n","import type { ApiResponse, WithHeaders } from \"./runtime\";\n\nexport * from \"./runtime\";\n\n/**\n * Type to access a response's data property for a given status.\n */\nexport type DataType<T extends ApiResponse, S extends number> = T extends {\n  status: S;\n}\n  ? T[\"data\"]\n  : never;\n\n/**\n * Object with methods to handle possible status codes of an ApiResponse.\n */\nexport type ResponseHandler<T extends ApiResponse> = {\n  [P in T[\"status\"]]?: (res: DataType<T, P>) => any;\n} & {\n  default?: (status: number, data: any) => any;\n};\n\nexport type FunctionReturnType<T> = T extends (...args: any[]) => any\n  ? ReturnType<T>\n  : never;\n\n/**\n * Utility function to handle different status codes.\n *\n * Example:\n *\n * const userId = await handle(api.register({ email, password }), {\n *   200: (user: User) => user.id,\n *   400: (err: string) => console.log(err),\n * })\n **/\nexport async function handle<\n  T extends WithHeaders<ApiResponse>,\n  H extends ResponseHandler<T>,\n>(promise: Promise<T>, handler: H): Promise<FunctionReturnType<H[keyof H]>> {\n  const { status, data, headers } = await promise;\n  const statusHandler = (handler as any)[status];\n  if (statusHandler) return statusHandler(data);\n  if (handler.default) return handler.default(status, data);\n  throw new HttpError(status, data, headers);\n}\n\nexport const SUCCESS_CODES = [200, 201, 202, 204] as const;\nexport type SuccessCodes = (typeof SUCCESS_CODES)[number];\n\nexport type SuccessResponse<T extends ApiResponse> = DataType<T, SuccessCodes>;\n\n/**\n * Utility function to directly return any successful response\n * and throw a HttpError otherwise.\n *\n * Example:\n *\n * try {\n *   const userId = await ok(api.register({ email, password }));\n * }\n * catch (err) {\n *   console.log(err.status)\n * }\n */\nexport async function ok<T extends WithHeaders<ApiResponse>>(\n  promise: Promise<T>,\n): Promise<SuccessResponse<T>> {\n  const res = await promise;\n  if (SUCCESS_CODES.some((s) => s == res.status)) return res.data;\n  throw new HttpError(res.status, res.data, res.headers);\n}\n\nexport type Args<T> = T extends (...args: infer U) => any ? U : any;\nexport type ApiFunction = (...args: any[]) => Promise<WithHeaders<ApiResponse>>;\nexport type AsyncReturnType<T> = T extends (...args: any[]) => Promise<infer V>\n  ? V\n  : never;\n\nexport type OkResponse<T extends ApiFunction> = SuccessResponse<\n  AsyncReturnType<T>\n>;\n\nexport type Okify<T extends ApiFunction> = (\n  ...args: Args<T>\n) => Promise<OkResponse<T>>;\n\n/**\n * Utility function to wrap an API function with `ok(...)`.\n */\nexport function okify<T extends ApiFunction>(fn: T): Okify<T> {\n  return (...args: Args<T>) => ok(fn(...args));\n}\n\ntype OptimisticApi<T> = {\n  [K in keyof T]: T[K] extends ApiFunction ? Okify<T[K]> : T[K];\n};\n\n/**\n * Utility to `okify` each function of an API.\n */\nexport function optimistic<T extends Record<string, ApiFunction | unknown>>(\n  api: T,\n): OptimisticApi<T> {\n  const okApi: any = {};\n  Object.entries(api).forEach(([key, value]) => {\n    okApi[key] = typeof value === \"function\" ? okify(value as any) : value;\n  });\n  return okApi;\n}\n\nexport class HttpError extends Error {\n  status: number;\n  data?: any;\n  headers: Headers;\n\n  constructor(status: number, data: any, headers: Headers) {\n    super(`Error: ${status}`);\n    this.status = status;\n    this.data = data;\n    this.headers = headers;\n  }\n}\n"],"names":["runtime","defaults","fetchText","url","req","res","doFetch","data","fetchJson","status","headers","contentType","mergeHeaders","fetchBlob","baseUrl","customFetch","init","href","joinUrl","ok","body","qs.form","normalizeHeaders","append","name","value","v","handle","promise","handler","statusHandler","HttpError","SUCCESS_CODES","s","okify","fn","args","optimistic","api","okApi","key"],"mappings":"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"}