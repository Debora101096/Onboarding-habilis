import { form as w } from "./query.js";
import { joinUrl as b } from "./util.js";
import { mergeHeaders as d, normalizeHeaders as h } from "./headers.js";
function D(a = {}) {
  async function r(e, n) {
    const t = await p(e, n);
    let s;
    try {
      s = await t.text();
    } catch {
    }
    return {
      status: t.status,
      headers: t.headers,
      contentType: t.headers.get("content-type"),
      data: s
    };
  }
  async function i(e, n = {}) {
    const { status: t, headers: s, contentType: u, data: c } = await r(e, {
      ...n,
      headers: d(
        {
          Accept: "application/json"
        },
        n.headers
      )
    });
    return (u ? u.includes("json") : !1) ? {
      status: t,
      headers: s,
      data: c ? JSON.parse(c) : null
    } : { status: t, headers: s, data: c };
  }
  async function f(e, n = {}) {
    const t = await p(e, n);
    let s;
    try {
      s = await t.blob();
    } catch {
    }
    return { status: t.status, headers: t.headers, data: s };
  }
  async function p(e, n = {}) {
    const {
      baseUrl: t,
      fetch: s,
      ...u
    } = {
      ...a,
      ...n,
      headers: d(a.headers, n.headers)
    }, c = b(t, e);
    return await (s || fetch)(c, u);
  }
  return {
    ok: y,
    fetchText: r,
    fetchJson: i,
    fetchBlob: f,
    mergeHeaders: d,
    json({ body: e, headers: n, ...t }) {
      return {
        ...t,
        ...e != null && { body: JSON.stringify(e) },
        headers: d(
          {
            "Content-Type": "application/json"
          },
          n
        )
      };
    },
    form({ body: e, headers: n, ...t }) {
      return {
        ...t,
        ...e != null && { body: w(e) },
        headers: d(
          {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          n
        )
      };
    },
    multipart({ body: e, headers: n, ...t }) {
      if (e == null)
        return { ...t, body: e, headers: h(n) };
      const s = new (t.FormData || t.formDataConstructor || a.FormData || a.formDataConstructor || FormData)(), u = (c, o) => {
        typeof o == "string" || o instanceof Blob ? s.append(c, o) : typeof o == "number" || typeof o == "boolean" ? s.append(c, String(o)) : s.append(
          c,
          new Blob([JSON.stringify(o)], { type: "application/json" })
        );
      };
      return Object.entries(e).forEach(([c, o]) => {
        Array.isArray(o) ? o.forEach((m) => u(c, m)) : u(c, o);
      }), {
        ...t,
        body: s,
        headers: h(n)
      };
    }
  };
}
async function J(a, r) {
  const { status: i, data: f, headers: p } = await a, e = r[i];
  if (e) return e(f);
  if (r.default) return r.default(i, f);
  throw new l(i, f, p);
}
const j = [200, 201, 202, 204];
async function y(a) {
  const r = await a;
  if (j.some((i) => i == r.status)) return r.data;
  throw new l(r.status, r.data, r.headers);
}
function E(a) {
  return (...r) => y(a(...r));
}
function O(a) {
  const r = {};
  return Object.entries(a).forEach(([i, f]) => {
    r[i] = typeof f == "function" ? E(f) : f;
  }), r;
}
class l extends Error {
  status;
  data;
  headers;
  constructor(r, i, f) {
    super(`Error: ${r}`), this.status = r, this.data = i, this.headers = f;
  }
}
export {
  l as HttpError,
  j as SUCCESS_CODES,
  J as handle,
  y as ok,
  E as okify,
  O as optimistic,
  D as runtime
};
//# sourceMappingURL=index.js.map
