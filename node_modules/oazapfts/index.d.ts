import { default as default_2 } from 'typescript';
import { OpenAPIV3 } from 'openapi-types';

declare function addComment<T extends default_2.Node>(node: T, comment?: string): T;

declare function appendNodes<T extends default_2.Node>(array: default_2.NodeArray<T>, ...nodes: T[]): default_2.NodeArray<T>;

declare function block(...statements: default_2.Statement[]): default_2.Block;

declare namespace cg {
    export {
        createQuestionToken,
        createKeywordType,
        createLiteral,
        createEnumTypeNode,
        createTypeAliasDeclaration,
        createInterfaceAliasDeclaration,
        toExpression,
        createCall,
        createMethodCall,
        createObjectLiteral,
        createPropertyAssignment,
        block,
        createArrowFunction,
        createFunctionDeclaration,
        createClassDeclaration,
        createConstructor,
        createMethod,
        createParameter,
        createPropertySignature,
        createIndexSignature,
        createObjectBinding,
        createTemplateString,
        findNode,
        getName,
        getFirstDeclarationName,
        findFirstVariableDeclaration,
        changePropertyValue,
        appendNodes,
        addComment,
        printNode,
        printNodes,
        printFile,
        isValidIdentifier,
        questionToken,
        keywordType,
        modifier
    }
}
export { cg }

declare function changePropertyValue(o: default_2.ObjectLiteralExpression, property: string, value: default_2.Expression): void;

declare function createArrowFunction(parameters: default_2.ParameterDeclaration[], body: default_2.ConciseBody, { modifiers, typeParameters, type, equalsGreaterThanToken, }?: {
    modifiers?: default_2.Modifier[];
    typeParameters?: default_2.TypeParameterDeclaration[];
    type?: default_2.TypeNode;
    equalsGreaterThanToken?: default_2.EqualsGreaterThanToken;
}): default_2.ArrowFunction;

declare function createCall(expression: default_2.Expression | string, { typeArgs, args, }?: {
    typeArgs?: Array<default_2.TypeNode>;
    args?: Array<default_2.Expression>;
}): default_2.CallExpression;

declare function createClassDeclaration({ modifiers, name, typeParameters, heritageClauses, members, }: {
    modifiers?: Array<default_2.Modifier>;
    name?: string | default_2.Identifier;
    typeParameters?: Array<default_2.TypeParameterDeclaration>;
    heritageClauses?: Array<default_2.HeritageClause>;
    members: Array<default_2.ClassElement>;
}): default_2.ClassDeclaration;

declare function createConstructor({ modifiers, parameters, body, }: {
    modifiers?: Array<default_2.Modifier>;
    parameters: Array<default_2.ParameterDeclaration>;
    body?: default_2.Block;
}): default_2.ConstructorDeclaration;

declare function createEnumTypeNode(values: Array<string | boolean | number>): default_2.LiteralTypeNode | default_2.UnionTypeNode;

declare function createFunctionDeclaration(name: string | default_2.Identifier | undefined, { modifiers, asteriskToken, typeParameters, type, }: {
    modifiers?: default_2.Modifier[];
    asteriskToken?: default_2.AsteriskToken;
    typeParameters?: default_2.TypeParameterDeclaration[];
    type?: default_2.TypeNode;
}, parameters: default_2.ParameterDeclaration[], body?: default_2.Block): default_2.FunctionDeclaration;

declare function createIndexSignature(type: default_2.TypeNode, { modifiers, indexName, indexType, }?: {
    indexName?: string;
    indexType?: default_2.TypeNode;
    modifiers?: Array<default_2.Modifier>;
}): default_2.IndexSignatureDeclaration;

declare function createInterfaceAliasDeclaration({ modifiers, name, typeParameters, type, inheritedNodeNames, }: {
    modifiers?: Array<default_2.Modifier>;
    name: string | default_2.Identifier;
    typeParameters?: Array<default_2.TypeParameterDeclaration>;
    type: default_2.TypeNode;
    inheritedNodeNames?: (string | default_2.Identifier)[];
}): default_2.InterfaceDeclaration;

declare function createKeywordType(type: KeywordTypeName): default_2.KeywordTypeNode<default_2.SyntaxKind.AnyKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.NumberKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.ObjectKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.StringKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.BooleanKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.UndefinedKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.VoidKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.NeverKeyword> | default_2.LiteralTypeNode | default_2.KeywordTypeNode<default_2.SyntaxKind.UnknownKeyword>;

declare function createLiteral(v: string | boolean | number): default_2.StringLiteral | default_2.TrueLiteral | default_2.FalseLiteral | default_2.NumericLiteral | default_2.PrefixUnaryExpression;

declare function createMethod(name: string | default_2.Identifier | default_2.StringLiteral | default_2.NumericLiteral | default_2.ComputedPropertyName, { modifiers, asteriskToken, questionToken, typeParameters, type, }?: {
    modifiers?: default_2.Modifier[];
    asteriskToken?: default_2.AsteriskToken;
    questionToken?: default_2.QuestionToken | boolean;
    typeParameters?: default_2.TypeParameterDeclaration[];
    type?: default_2.TypeNode;
}, parameters?: default_2.ParameterDeclaration[], body?: default_2.Block): default_2.MethodDeclaration;

declare function createMethodCall(method: string, opts: {
    typeArgs?: Array<default_2.TypeNode>;
    args?: Array<default_2.Expression>;
}): default_2.CallExpression;

declare function createObjectBinding(elements: Array<{
    name: string | default_2.BindingName;
    dotDotDotToken?: default_2.DotDotDotToken;
    propertyName?: string | default_2.PropertyName;
    initializer?: default_2.Expression;
}>): default_2.ObjectBindingPattern;

declare function createObjectLiteral(props: [string, string | default_2.Expression][]): default_2.ObjectLiteralExpression;

declare function createParameter(name: string | default_2.BindingName, { modifiers, dotDotDotToken, questionToken, type, initializer, }: {
    modifiers?: Array<default_2.Modifier>;
    dotDotDotToken?: default_2.DotDotDotToken;
    questionToken?: default_2.QuestionToken | boolean;
    type?: default_2.TypeNode;
    initializer?: default_2.Expression;
}): default_2.ParameterDeclaration;

declare function createPropertyAssignment(name: string, expression: default_2.Expression): default_2.PropertyAssignment | default_2.ShorthandPropertyAssignment;

declare function createPropertySignature({ modifiers, name, questionToken, type, }: {
    modifiers?: Array<default_2.Modifier>;
    name: default_2.PropertyName | string;
    questionToken?: default_2.QuestionToken | boolean;
    type?: default_2.TypeNode;
}): default_2.PropertySignature;

declare function createQuestionToken(token?: boolean | default_2.QuestionToken): default_2.QuestionToken | undefined;

declare function createTemplateString(head: string, spans: Array<{
    literal: string;
    expression: default_2.Expression;
}>): default_2.StringLiteral | default_2.TemplateExpression;

declare function createTypeAliasDeclaration({ modifiers, name, typeParameters, type, }: {
    modifiers?: Array<default_2.Modifier>;
    name: string | default_2.Identifier;
    typeParameters?: Array<default_2.TypeParameterDeclaration>;
    type: default_2.TypeNode;
}): default_2.TypeAliasDeclaration;

declare function findFirstVariableDeclaration(nodes: default_2.NodeArray<default_2.Node>, name: string): default_2.VariableDeclaration;

declare function findNode<T extends default_2.Node>(nodes: default_2.NodeArray<default_2.Node>, kind: T extends {
    kind: infer K;
} ? K : never, test?: (node: T) => boolean | undefined): T;

export declare function generateAst(doc: OpenAPIV3.Document, opts: Opts, isConverted: boolean): default_2.SourceFile;

export declare function generateSource(spec: string, opts?: Opts): Promise<string>;

declare function getFirstDeclarationName(n: default_2.VariableStatement): string | (void & {
    __escapedIdentifier: void;
});

declare function getName(name: default_2.Node): string | (void & {
    __escapedIdentifier: void;
});

declare function isValidIdentifier(str: string): boolean;

declare const keywordType: {
    any: default_2.KeywordTypeNode<default_2.SyntaxKind.AnyKeyword>;
    number: default_2.KeywordTypeNode<default_2.SyntaxKind.NumberKeyword>;
    integer: default_2.KeywordTypeNode<default_2.SyntaxKind.NumberKeyword>;
    object: default_2.KeywordTypeNode<default_2.SyntaxKind.ObjectKeyword>;
    string: default_2.KeywordTypeNode<default_2.SyntaxKind.StringKeyword>;
    boolean: default_2.KeywordTypeNode<default_2.SyntaxKind.BooleanKeyword>;
    undefined: default_2.KeywordTypeNode<default_2.SyntaxKind.UndefinedKeyword>;
    void: default_2.KeywordTypeNode<default_2.SyntaxKind.VoidKeyword>;
    never: default_2.KeywordTypeNode<default_2.SyntaxKind.NeverKeyword>;
    null: default_2.LiteralTypeNode;
    unknown: default_2.KeywordTypeNode<default_2.SyntaxKind.UnknownKeyword>;
};

declare type KeywordTypeName = keyof typeof keywordType;

declare const modifier: {
    async: default_2.ModifierToken<default_2.SyntaxKind.AsyncKeyword>;
    export: default_2.ModifierToken<default_2.SyntaxKind.ExportKeyword>;
};

export declare type Opts = {
    include?: string[];
    exclude?: string[];
    optimistic?: boolean;
    unionUndefined?: boolean;
    useEnumType?: boolean;
    mergeReadWriteOnly?: boolean;
    useUnknown?: boolean;
    argumentStyle?: (typeof optsArgumentStyles)[number];
};

export declare const optsArgumentStyles: string[];

export declare function parseSpec(spec: string): Promise<{
    doc: OpenAPIV3.Document<{}>;
    isConverted: boolean;
}>;

export declare function printAst(ast: default_2.SourceFile): string;

declare function printFile(sourceFile: default_2.SourceFile): string;

declare function printNode(node: default_2.Node): string;

declare function printNodes(nodes: default_2.Node[]): string;

declare const questionToken: default_2.PunctuationToken<default_2.SyntaxKind.QuestionToken>;

declare function toExpression(ex: default_2.Expression | string): default_2.Expression;

export { }
