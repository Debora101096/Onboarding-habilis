import { default as default_2 } from 'typescript';
import { OpenAPIV3 } from 'openapi-types';
import { OpenAPIV3_1 } from 'openapi-types';

export declare function addComment<T extends default_2.Node>(node: T, comment?: string): T;

/**
 * Main entry point that generates TypeScript code from a given API spec.
 */
declare class ApiGenerator {
    readonly spec: OpenAPIDocument;
    readonly opts: Opts;
    /** Indicates if the document was converted from an older version of the OpenAPI specification. */
    readonly isConverted: boolean;
    constructor(spec: OpenAPIDocument, opts?: Opts, 
    /** Indicates if the document was converted from an older version of the OpenAPI specification. */
    isConverted?: boolean);
    discriminatingSchemas: Set<string>;
    aliases: (default_2.TypeAliasDeclaration | default_2.InterfaceDeclaration)[];
    enumAliases: default_2.Statement[];
    enumRefs: Record<string, {
        values: string;
        type: default_2.TypeReferenceNode;
    }>;
    refs: Record<string, {
        base: default_2.TypeReferenceNode;
        readOnly?: default_2.TypeReferenceNode;
        writeOnly?: default_2.TypeReferenceNode;
    }>;
    refsOnlyMode: Map<string, OnlyModes>;
    typeAliases: Record<string, number>;
    reset(): void;
    resolve<T>(obj: T | OpenAPIReferenceObject): T;
    resolveArray<T>(array?: Array<T | OpenAPIReferenceObject>): T[];
    skip(tags?: string[]): boolean;
    findAvailableRef(ref: string): string;
    getUniqueAlias(name: string): string;
    getEnumUniqueAlias(name: string, values: string): string;
    /**
     * Create a type alias for the schema referenced by the given ReferenceObject
     */
    getRefAlias(obj: OpenAPIReferenceObject, onlyMode?: OnlyMode, ignoreDiscriminator?: boolean): default_2.TypeNode;
    getUnionType(variants: (OpenAPIReferenceObject | SchemaObject)[], discriminator?: OpenAPIDiscriminatorObject, onlyMode?: OnlyMode): default_2.UnionTypeNode;
    /**
     * Creates a type node from a given schema.
     * Delegates to getBaseTypeFromSchema internally and
     * optionally adds a union with null.
     */
    getTypeFromSchema(schema?: SchemaObject | OpenAPIReferenceObject, name?: string, onlyMode?: OnlyMode): default_2.TypeNode;
    getEmptySchemaType(): default_2.KeywordTypeNode<default_2.SyntaxKind.AnyKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.UnknownKeyword>;
    /**
     * This is the very core of the OpenAPI to TS conversion - it takes a
     * schema and returns the appropriate type.
     */
    getBaseTypeFromSchema(schema?: SchemaObject | OpenAPIReferenceObject, name?: string, onlyMode?: OnlyMode): default_2.TypeNode;
    isTrueEnum(schema: SchemaObject, name?: string): name is string;
    /**
     * Get enum member reference type for discriminator values when useEnumType is enabled
     */
    getDiscriminatorType(discriminatingSchemaRef: Exclude<SchemaObject, boolean> | OpenAPIReferenceObject, propertyName: string, matches: string[]): default_2.TypeNode;
    /**
     * Creates literal type (or union) from an array of values
     */
    getTypeFromEnum(values: unknown[]): default_2.LiteralTypeNode | default_2.UnionTypeNode;
    getEnumValuesString(values: string[]): string;
    getTrueEnum(schema: SchemaObject, propName: string): default_2.TypeReferenceNode;
    /**
     * Checks if readOnly/writeOnly properties are present in the given schema.
     * Returns a tuple of booleans; the first one is about readOnly, the second
     * one is about writeOnly.
     */
    checkSchemaOnlyMode(schema: SchemaObject | OpenAPIReferenceObject, resolveRefs?: boolean): OnlyModes;
    /**
     * Recursively creates a type literal with the given props.
     */
    getTypeFromProperties(props: {
        [prop: string]: SchemaObject | OpenAPIReferenceObject;
    }, required?: string[], additionalProperties?: boolean | OpenAPISchemaObject | OpenAPIReferenceObject, onlyMode?: OnlyMode): default_2.TypeLiteralNode;
    getTypeFromResponses(responses: OpenAPIResponsesObject, onlyMode?: OnlyMode): default_2.UnionTypeNode;
    getTypeFromResponse(resOrRef: OpenAPIResponseObject | OpenAPIReferenceObject, onlyMode?: OnlyMode): default_2.TypeNode;
    getResponseType(responses?: OpenAPIResponsesObject): "json" | "text" | "blob";
    getSchemaFromContent(content: Record<string, OpenAPIMediaTypeObject>): OpenAPISchemaObject | OpenAPIReferenceObject;
    getTypeFromParameter(p: OpenAPIParameterObject): default_2.TypeNode;
    wrapResult(ex: default_2.Expression): default_2.Expression;
    /**
     * Does three things:
     * 1. Add a `x-component-ref-path` property.
     * 2. Record discriminating schemas in `this.discriminatingSchemas`. A discriminating schema
     *    refers to a schema that has a `discriminator` property which is neither used in conjunction
     *    with `oneOf` nor `anyOf`.
     * 3. Make all mappings of discriminating schemas explicit to generate types immediately.
     */
    preprocessComponents(schemas: {
        [key: string]: OpenAPIReferenceObject | SchemaObject;
    }): void;
    generateApi(): default_2.SourceFile;
}
export default ApiGenerator;

export declare function appendNodes<T extends default_2.Node>(array: default_2.NodeArray<T>, ...nodes: T[]): default_2.NodeArray<T>;

export declare function block(...statements: default_2.Statement[]): default_2.Block;

/**
 * Create a call expression for one of the oazapfts runtime functions.
 */
export declare function callOazapftsFunction(name: string, args: default_2.Expression[], typeArgs?: default_2.TypeNode[]): default_2.CallExpression;

/**
 * Create a call expression for one of the QS runtime functions.
 */
export declare function callQsFunction(name: string, args: default_2.Expression[]): default_2.CallExpression;

export declare function changePropertyValue(o: default_2.ObjectLiteralExpression, property: string, value: default_2.Expression): void;

declare type ContentType = "json" | "form" | "multipart";

export declare function createArrowFunction(parameters: default_2.ParameterDeclaration[], body: default_2.ConciseBody, { modifiers, typeParameters, type, equalsGreaterThanToken, }?: {
    modifiers?: default_2.Modifier[];
    typeParameters?: default_2.TypeParameterDeclaration[];
    type?: default_2.TypeNode;
    equalsGreaterThanToken?: default_2.EqualsGreaterThanToken;
}): default_2.ArrowFunction;

export declare function createCall(expression: default_2.Expression | string, { typeArgs, args, }?: {
    typeArgs?: Array<default_2.TypeNode>;
    args?: Array<default_2.Expression>;
}): default_2.CallExpression;

export declare function createClassDeclaration({ modifiers, name, typeParameters, heritageClauses, members, }: {
    modifiers?: Array<default_2.Modifier>;
    name?: string | default_2.Identifier;
    typeParameters?: Array<default_2.TypeParameterDeclaration>;
    heritageClauses?: Array<default_2.HeritageClause>;
    members: Array<default_2.ClassElement>;
}): default_2.ClassDeclaration;

export declare function createConstructor({ modifiers, parameters, body, }: {
    modifiers?: Array<default_2.Modifier>;
    parameters: Array<default_2.ParameterDeclaration>;
    body?: default_2.Block;
}): default_2.ConstructorDeclaration;

export declare function createEnumTypeNode(values: Array<string | boolean | number>): default_2.LiteralTypeNode | default_2.UnionTypeNode;

export declare function createFunctionDeclaration(name: string | default_2.Identifier | undefined, { modifiers, asteriskToken, typeParameters, type, }: {
    modifiers?: default_2.Modifier[];
    asteriskToken?: default_2.AsteriskToken;
    typeParameters?: default_2.TypeParameterDeclaration[];
    type?: default_2.TypeNode;
}, parameters: default_2.ParameterDeclaration[], body?: default_2.Block): default_2.FunctionDeclaration;

export declare function createIndexSignature(type: default_2.TypeNode, { modifiers, indexName, indexType, }?: {
    indexName?: string;
    indexType?: default_2.TypeNode;
    modifiers?: Array<default_2.Modifier>;
}): default_2.IndexSignatureDeclaration;

export declare function createInterfaceAliasDeclaration({ modifiers, name, typeParameters, type, inheritedNodeNames, }: {
    modifiers?: Array<default_2.Modifier>;
    name: string | default_2.Identifier;
    typeParameters?: Array<default_2.TypeParameterDeclaration>;
    type: default_2.TypeNode;
    inheritedNodeNames?: (string | default_2.Identifier)[];
}): default_2.InterfaceDeclaration;

export declare function createKeywordType(type: KeywordTypeName): default_2.KeywordTypeNode<default_2.SyntaxKind.AnyKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.NumberKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.ObjectKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.StringKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.BooleanKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.UndefinedKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.VoidKeyword> | default_2.KeywordTypeNode<default_2.SyntaxKind.NeverKeyword> | default_2.LiteralTypeNode | default_2.KeywordTypeNode<default_2.SyntaxKind.UnknownKeyword>;

export declare function createLiteral(v: string | boolean | number): default_2.StringLiteral | default_2.TrueLiteral | default_2.FalseLiteral | default_2.NumericLiteral | default_2.PrefixUnaryExpression;

export declare function createMethod(name: string | default_2.Identifier | default_2.StringLiteral | default_2.NumericLiteral | default_2.ComputedPropertyName, { modifiers, asteriskToken, questionToken, typeParameters, type, }?: {
    modifiers?: default_2.Modifier[];
    asteriskToken?: default_2.AsteriskToken;
    questionToken?: default_2.QuestionToken | boolean;
    typeParameters?: default_2.TypeParameterDeclaration[];
    type?: default_2.TypeNode;
}, parameters?: default_2.ParameterDeclaration[], body?: default_2.Block): default_2.MethodDeclaration;

export declare function createMethodCall(method: string, opts: {
    typeArgs?: Array<default_2.TypeNode>;
    args?: Array<default_2.Expression>;
}): default_2.CallExpression;

export declare function createObjectBinding(elements: Array<{
    name: string | default_2.BindingName;
    dotDotDotToken?: default_2.DotDotDotToken;
    propertyName?: string | default_2.PropertyName;
    initializer?: default_2.Expression;
}>): default_2.ObjectBindingPattern;

export declare function createObjectLiteral(props: [string, string | default_2.Expression][]): default_2.ObjectLiteralExpression;

export declare function createParameter(name: string | default_2.BindingName, { modifiers, dotDotDotToken, questionToken, type, initializer, }: {
    modifiers?: Array<default_2.Modifier>;
    dotDotDotToken?: default_2.DotDotDotToken;
    questionToken?: default_2.QuestionToken | boolean;
    type?: default_2.TypeNode;
    initializer?: default_2.Expression;
}): default_2.ParameterDeclaration;

export declare function createPropertyAssignment(name: string, expression: default_2.Expression): default_2.PropertyAssignment | default_2.ShorthandPropertyAssignment;

export declare function createPropertySignature({ modifiers, name, questionToken, type, }: {
    modifiers?: Array<default_2.Modifier>;
    name: default_2.PropertyName | string;
    questionToken?: default_2.QuestionToken | boolean;
    type?: default_2.TypeNode;
}): default_2.PropertySignature;

export declare function createQuestionToken(token?: boolean | default_2.QuestionToken): default_2.QuestionToken | undefined;

export declare function createTemplateString(head: string, spans: Array<{
    literal: string;
    expression: default_2.Expression;
}>): default_2.StringLiteral | default_2.TemplateExpression;

export declare function createTypeAliasDeclaration({ modifiers, name, typeParameters, type, }: {
    modifiers?: Array<default_2.Modifier>;
    name: string | default_2.Identifier;
    typeParameters?: Array<default_2.TypeParameterDeclaration>;
    type: default_2.TypeNode;
}): default_2.TypeAliasDeclaration;

/**
 * Create a template string literal from the given OpenAPI urlTemplate.
 * Curly braces in the path are turned into identifier expressions,
 * which are read from the local scope during runtime.
 */
export declare function createUrlExpression(path: string, qs?: default_2.Expression): default_2.StringLiteral | default_2.TemplateExpression;

export declare function defaultBaseUrl(servers: OpenAPIV3.ServerObject[]): default_2.StringLiteral;

export declare type DiscriminatingSchemaObject = Exclude<SchemaObject, boolean> & {
    discriminator: NonNullable<Exclude<SchemaObject, boolean>["discriminator"]>;
};

export declare function findFirstVariableDeclaration(nodes: default_2.NodeArray<default_2.Node>, name: string): default_2.VariableDeclaration;

export declare function findNode<T extends default_2.Node>(nodes: default_2.NodeArray<default_2.Node>, kind: T extends {
    kind: infer K;
} ? K : never, test?: (node: T) => boolean | undefined): T;

export declare function getBodyFormatter(body?: OpenAPIRequestBodyObject): ContentType | undefined;

export declare function getFirstDeclarationName(n: default_2.VariableStatement): string | (void & {
    __escapedIdentifier: void;
});

/**
 * Get the name of a formatter function for a given parameter.
 */
export declare function getFormatter({ style, explode, content, }: OpenAPIParameterObject): "json" | "form" | "deep" | "explode" | "space" | "pipe";

export declare function getName(name: default_2.Node): string | (void & {
    __escapedIdentifier: void;
});

export declare function getOperationIdentifier(id?: string): string | undefined;

/**
 * Create a method name for a given operation, either from its operationId or
 * the HTTP verb and path.
 */
export declare function getOperationName(verb: string, path: string, operationId?: string): string;

/**
 * If the given object is a ReferenceObject, return the last part of its path.
 */
export declare function getReferenceName(obj: unknown): string | undefined;

export declare function isJsonMimeType(mime: string): boolean;

export declare function isMimeType(s: unknown): boolean;

export declare function isNullable(schema?: SchemaObject | OpenAPIReferenceObject): boolean | undefined;

export declare function isReference(obj: unknown): obj is OpenAPIReferenceObject;

export declare function isValidIdentifier(str: string): boolean;

export declare const keywordType: {
    any: default_2.KeywordTypeNode<default_2.SyntaxKind.AnyKeyword>;
    number: default_2.KeywordTypeNode<default_2.SyntaxKind.NumberKeyword>;
    integer: default_2.KeywordTypeNode<default_2.SyntaxKind.NumberKeyword>;
    object: default_2.KeywordTypeNode<default_2.SyntaxKind.ObjectKeyword>;
    string: default_2.KeywordTypeNode<default_2.SyntaxKind.StringKeyword>;
    boolean: default_2.KeywordTypeNode<default_2.SyntaxKind.BooleanKeyword>;
    undefined: default_2.KeywordTypeNode<default_2.SyntaxKind.UndefinedKeyword>;
    void: default_2.KeywordTypeNode<default_2.SyntaxKind.VoidKeyword>;
    never: default_2.KeywordTypeNode<default_2.SyntaxKind.NeverKeyword>;
    null: default_2.LiteralTypeNode;
    unknown: default_2.KeywordTypeNode<default_2.SyntaxKind.UnknownKeyword>;
};

declare type KeywordTypeName = keyof typeof keywordType;

export declare const modifier: {
    async: default_2.ModifierToken<default_2.SyntaxKind.AsyncKeyword>;
    export: default_2.ModifierToken<default_2.SyntaxKind.ExportKeyword>;
};

declare type OnlyMode = "readOnly" | "writeOnly";

declare type OnlyModes = Record<OnlyMode, boolean>;

declare type OpenAPIDiscriminatorObject = OpenAPIV3.DiscriminatorObject | OpenAPIV3_1.DiscriminatorObject;

export declare type OpenAPIDocument = OpenAPIV3.Document | OpenAPIV3_1.Document;

declare type OpenAPIMediaTypeObject = OpenAPIV3.MediaTypeObject | OpenAPIV3_1.MediaTypeObject;

declare type OpenAPIParameterObject = OpenAPIV3.ParameterObject | OpenAPIV3_1.ParameterObject;

declare type OpenAPIReferenceObject = OpenAPIV3.ReferenceObject | OpenAPIV3_1.ReferenceObject;

declare type OpenAPIRequestBodyObject = OpenAPIV3.RequestBodyObject | OpenAPIV3_1.RequestBodyObject;

declare type OpenAPIResponseObject = OpenAPIV3.ResponseObject | OpenAPIV3_1.ResponseObject;

declare type OpenAPIResponsesObject = OpenAPIV3.ResponsesObject | OpenAPIV3_1.ResponsesObject;

declare type OpenAPISchemaObject = OpenAPIV3.SchemaObject | OpenAPIV3_1.SchemaObject | boolean;

declare type Opts = {
    include?: string[];
    exclude?: string[];
    optimistic?: boolean;
    unionUndefined?: boolean;
    useEnumType?: boolean;
    mergeReadWriteOnly?: boolean;
    useUnknown?: boolean;
    argumentStyle?: (typeof optsArgumentStyles)[number];
};

declare const optsArgumentStyles: string[];

export declare function printFile(sourceFile: default_2.SourceFile): string;

export declare function printNode(node: default_2.Node): string;

export declare function printNodes(nodes: default_2.Node[]): string;

export declare const questionToken: default_2.PunctuationToken<default_2.SyntaxKind.QuestionToken>;

/**
 * Converts a local reference path into an array of property names.
 */
export declare function refPathToPropertyPath(ref: string): string[];

export declare type SchemaObject = OpenAPISchemaObject & {
    const?: unknown;
    "x-enumNames"?: string[];
    "x-enum-varnames"?: string[];
    "x-component-ref-path"?: string;
    prefixItems?: (OpenAPIReferenceObject | SchemaObject)[];
};

/**
 * Despite its name, OpenApi's `deepObject` serialization does not support
 * deeply nested objects. As a workaround we detect parameters that contain
 * square brackets and merge them into a single object.
 */
export declare function supportDeepObjects(params: OpenAPIParameterObject[]): OpenAPIV3.ParameterObject[];

export declare function toExpression(ex: default_2.Expression | string): default_2.Expression;

export declare function toIdentifier(s: string, upperFirst?: boolean, onlyMode?: OnlyMode): string;

export declare const verbs: string[];

export { }
