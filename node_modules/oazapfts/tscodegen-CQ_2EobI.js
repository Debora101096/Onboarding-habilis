import u from "typescript";
import T from "lodash";
const U = u.factory;
function Ae(t) {
  const e = t.split(/{([\s\S]+?)}/g), r = T.chunk(e.slice(1), 2);
  return te(
    e[0],
    r.map(([i, n]) => ({
      expression: U.createIdentifier(i),
      literal: n
    }))
  );
}
function Ke(t, e) {
  const r = [
    F(
      H(
        Object.entries(e || {}).map(([i, n]) => ({
          name: i,
          initializer: q(n.default)
        }))
      ),
      {
        type: U.createTypeLiteralNode(
          Object.entries(e || {}).map(([i, n]) => x({
            name: i,
            type: n.enum ? V(n.enum) : U.createUnionTypeNode([
              h.string,
              h.number,
              h.boolean
            ])
          }))
        )
      }
    )
  ];
  return me(r, Ae(t));
}
function je(t) {
  return t.variables ? Ke(t.url, t.variables) : U.createStringLiteral(t.url);
}
function ke(t) {
  if (!t) return "/";
  const { url: e, variables: r } = t;
  return r ? e.replace(
    /\{(.+?)\}/g,
    (i, n) => r[n] ? String(r[n].default) : i
  ) : e;
}
function Le(t) {
  return U.createStringLiteral(ke(t[0]));
}
function Pe(t, e) {
  return t.description ? T.camelCase(t.description.replace(/\W+/, " ")) : `server${e + 1}`;
}
function Re(t) {
  return ee(
    t.map((e, r) => [
      Pe(e, r),
      je(e)
    ])
  );
}
const o = u.factory, Ie = [
  "GET",
  "PUT",
  "POST",
  "DELETE",
  "OPTIONS",
  "HEAD",
  "PATCH",
  "TRACE"
], fe = {
  "*/*": "json",
  "application/json": "json",
  "application/x-www-form-urlencoded": "form",
  "multipart/form-data": "multipart"
};
function $e(t) {
  return typeof t == "string" && /^[^/]+\/[^/]+$/.test(t);
}
function Z(t) {
  return fe[t] === "json" || /\bjson\b/i.test(t);
}
function Ue(t) {
  if (t?.content)
    for (const e of Object.keys(t.content)) {
      const r = fe[e];
      if (r) return r;
      if (Z(e)) return "json";
    }
}
function qe({
  style: t = "form",
  explode: e = !0,
  content: r
}) {
  if (r) {
    const i = Object.keys(r);
    if (i.length !== 1)
      throw new Error(
        "Parameters with content property must specify one media type"
      );
    if (!Z(i[0]))
      throw new Error(
        "Parameters with content property must specify a JSON compatible media type"
      );
    return "json";
  }
  return e && t === "deepObject" ? "deep" : e ? "explode" : t === "spaceDelimited" ? "space" : t === "pipeDelimited" ? "pipe" : "form";
}
function Ce(t) {
  if (t && !t.match(/[^\w\s]/) && (t = T.camelCase(t), W(t)))
    return t;
}
function De(t, e, r) {
  const i = Ce(r);
  return i || (e = e.replace(/\{(.+?)\}/, "by $1").replace(/\{(.+?)\}/, "and $1"), O(`${t} ${e}`));
}
function Be(t) {
  return typeof t == "boolean" ? t : t && "nullable" in t ? !w(t) && t.nullable : !1;
}
function w(t) {
  return typeof t == "object" && t !== null && "$ref" in t;
}
function le(t) {
  if (!t.startsWith("#/"))
    throw new Error(
      `External refs are not supported (${t}). Make sure to call SwaggerParser.bundle() first.`
    );
  return t.slice(2).split("/").map((e) => decodeURI(e.replace(/~1/g, "/").replace(/~0/g, "~")));
}
function R(t) {
  return t.replace(/.+\//, "");
}
function ze(t) {
  const e = R(t);
  return /^\d+/.test(e) ? le(t).join("_") : e;
}
function ue(t) {
  if (w(t))
    return R(t.$ref);
}
const Me = {
  readOnly: "Read",
  writeOnly: "Write"
};
function Ve(t) {
  return t ? Me[t] : "";
}
function O(t, e = !1, r) {
  let i = T.camelCase(t) + Ve(r);
  return e && (i = T.upperFirst(i)), W(i) ? i : "$" + i;
}
function _e(t, e) {
  const r = [], i = t.replace(
    /(.*?)\{(.+?)\}(.*?)(?=\{|$)/g,
    (n, s, a, f) => {
      const p = O(a);
      return r.push({
        expression: C(
          o.createIdentifier("encodeURIComponent"),
          { args: [o.createIdentifier(p)] }
        ),
        literal: f
      }), s;
    }
  );
  return e && r.push({ expression: e, literal: "" }), te(i, r);
}
function pe(t, e) {
  return C(
    o.createPropertyAccessExpression(
      o.createIdentifier("QS"),
      t
    ),
    { args: e }
  );
}
function z(t, e, r) {
  return C(
    o.createPropertyAccessExpression(
      o.createIdentifier("oazapfts"),
      t
    ),
    { args: e, typeArgs: r }
  );
}
function He(t) {
  const e = [], r = {};
  return t.forEach((i) => {
    const n = /^(.+?)\[(.*?)\]/.exec(i.name);
    if (!n) {
      e.push(i);
      return;
    }
    const [, s, a] = n;
    let f = r[s];
    f || (f = r[s] = {
      name: s,
      in: i.in,
      style: "deepObject",
      schema: {
        type: "object",
        properties: {}
      }
    }, e.push(f)), f.schema.properties[a] = i.schema;
  }), e;
}
function Qe(t) {
  return t in h;
}
class st {
  constructor(e, r = {}, i = !1) {
    this.spec = e, this.opts = r, this.isConverted = i, this.spec.components?.schemas && this.preprocessComponents(this.spec.components.schemas);
  }
  // see `preprocessComponents` for the definition of a discriminating schema
  discriminatingSchemas = /* @__PURE__ */ new Set();
  aliases = [];
  enumAliases = [];
  enumRefs = {};
  // Collect the types of all referenced schemas so we can export them later
  // Referenced schemas can be pointing at the following versions:
  // - "base": The regular type/interface e.g. ExampleSchema
  // - "readOnly": The readOnly version e.g. ExampleSchemaRead
  // - "writeOnly": The writeOnly version e.g. ExampleSchemaWrite
  refs = {};
  // Maps a referenced schema to its readOnly/writeOnly status
  // This field should be used exclusively within the `checkSchemaOnlyMode` method
  refsOnlyMode = /* @__PURE__ */ new Map();
  // Keep track of already used type aliases
  typeAliases = {};
  reset() {
    this.aliases = [], this.enumAliases = [], this.refs = {}, this.typeAliases = {};
  }
  resolve(e) {
    if (!w(e)) return e;
    const r = e.$ref, i = le(r), n = T.get(this.spec, i);
    if (typeof n > "u")
      throw new Error(`Can't find ${i}`);
    return n;
  }
  resolveArray(e) {
    return e ? e.map((r) => this.resolve(r)) : [];
  }
  skip(e) {
    return e && e.some((i) => this.opts?.exclude?.includes(i)) ? !0 : this.opts?.include ? !(e && e.some((n) => this.opts.include?.includes(n))) : !1;
  }
  findAvailableRef(e) {
    const r = (n) => {
      try {
        return this.resolve({ $ref: n }), !1;
      } catch {
        return !0;
      }
    };
    if (r(e)) return e;
    let i = 2;
    for (; ; ) {
      const n = e + String(i);
      if (r(n)) return n;
      i += 1;
    }
  }
  getUniqueAlias(e) {
    let r = this.typeAliases[e] || 0;
    return r && (this.typeAliases[e] = ++r, e += r), this.typeAliases[e] = 1, e;
  }
  getEnumUniqueAlias(e, r) {
    return this.enumRefs[e] && this.enumRefs[e].values == r ? e : this.getUniqueAlias(e);
  }
  /**
   * Create a type alias for the schema referenced by the given ReferenceObject
   */
  getRefAlias(e, r, i) {
    const n = i ? this.findAvailableRef(e.$ref + "Base") : e.$ref;
    if (!this.refs[n]) {
      let s = this.resolve(e);
      typeof s != "boolean" && i && (s = T.cloneDeep(s), delete s.discriminator);
      const a = typeof s != "boolean" && s.title || ze(n), f = O(a, !0);
      if (this.isTrueEnum(s, a))
        return this.getTypeFromSchema(s, a);
      const p = this.getUniqueAlias(f);
      this.refs[n] = {
        base: o.createTypeReferenceNode(p, void 0),
        readOnly: void 0,
        writeOnly: void 0
      };
      const l = this.getTypeFromSchema(s, void 0);
      this.aliases.push(
        M({
          modifiers: [P.export],
          name: p,
          type: l
        })
      );
      const { readOnly: m, writeOnly: g } = this.checkSchemaOnlyMode(s);
      if (m) {
        const S = this.getUniqueAlias(
          O(a, !0, "readOnly")
        );
        this.refs[n].readOnly = o.createTypeReferenceNode(
          S,
          void 0
        );
        const N = this.getTypeFromSchema(s, a, "readOnly");
        this.aliases.push(
          M({
            modifiers: [P.export],
            name: S,
            type: N
          })
        );
      }
      if (g) {
        const S = this.getUniqueAlias(
          O(a, !0, "writeOnly")
        );
        this.refs[n].writeOnly = o.createTypeReferenceNode(
          S,
          void 0
        );
        const N = this.getTypeFromSchema(s, a, "writeOnly");
        this.aliases.push(
          M({
            modifiers: [P.export],
            name: S,
            type: N
          })
        );
      }
    }
    return this.refs[n][r || "base"] ?? this.refs[n].base;
  }
  getUnionType(e, r, i) {
    if (r) {
      if (r.propertyName === void 0)
        throw new Error("Discriminators require a propertyName");
      const n = new Set(
        Object.values(r.mapping || {}).map(R)
      );
      return o.createUnionTypeNode(
        [
          ...Object.entries(r.mapping || {}).map(
            ([s, a]) => [
              s,
              { $ref: a }
            ]
          ),
          ...e.filter((s) => {
            if (!w(s))
              throw new Error(
                "Discriminators require references, not inline schemas"
              );
            return !n.has(R(s.$ref));
          }).map((s) => {
            const a = R(
              s.$ref
            ), p = this.resolve(
              s
            ).properties?.[r.propertyName];
            return [(p && "enum" in p ? p?.enum?.[0] : "") || a, s];
          })
        ].map(
          ([s, a]) => (
            // Yields: { [discriminator.propertyName]: discriminatorValue } & variant
            o.createIntersectionTypeNode([
              o.createTypeLiteralNode([
                x({
                  name: r.propertyName,
                  type: this.getDiscriminatorType(
                    a,
                    r.propertyName,
                    [s]
                  )
                })
              ]),
              this.getTypeFromSchema(a, void 0, i)
            ])
          )
        )
      );
    } else
      return o.createUnionTypeNode(
        T.uniq(
          e.map(
            (n) => this.getTypeFromSchema(n, void 0, i)
          )
        )
      );
  }
  /**
   * Creates a type node from a given schema.
   * Delegates to getBaseTypeFromSchema internally and
   * optionally adds a union with null.
   */
  getTypeFromSchema(e, r, i) {
    const n = this.getBaseTypeFromSchema(e, r, i);
    return Be(e) ? o.createUnionTypeNode([n, h.null]) : n;
  }
  getEmptySchemaType() {
    return this.opts.useUnknown ? h.unknown : h.any;
  }
  /**
   * This is the very core of the OpenAPI to TS conversion - it takes a
   * schema and returns the appropriate type.
   */
  getBaseTypeFromSchema(e, r, i) {
    if (!e && typeof e != "boolean")
      return this.getEmptySchemaType();
    if (w(e))
      return this.getRefAlias(e, i);
    if (e === !0)
      return this.getEmptySchemaType();
    if (e === !1)
      return h.never;
    if (e.oneOf) {
      const n = { ...e };
      return delete n.oneOf, this.getUnionType(
        e.oneOf.map(
          (s) => (
            // ensure that base properties from the schema are included in the oneOf variants
            T.mergeWith({}, n, s, (a, f) => {
              if (T.isArray(a))
                return a.concat(f);
            })
          )
        ),
        e.discriminator,
        i
      );
    }
    if (e.anyOf)
      return this.getUnionType(e.anyOf, void 0, i);
    if (e.discriminator?.mapping) {
      const n = e.discriminator.mapping;
      return this.getUnionType(
        Object.values(n).map((s) => ({ $ref: s })),
        void 0,
        i
      );
    }
    if (e.allOf) {
      const n = [];
      for (const s of e.allOf)
        if (w(s) && this.discriminatingSchemas.has(s.$ref)) {
          const a = this.resolve(s), f = a.discriminator, p = Object.entries(f.mapping ?? {}).filter(([, l]) => l === e["x-component-ref-path"]).map(([l]) => l);
          p.length > 0 && n.push(
            o.createTypeLiteralNode([
              x({
                name: f.propertyName,
                type: this.getDiscriminatorType(
                  a,
                  f.propertyName,
                  p
                )
              })
            ])
          ), n.push(
            this.getRefAlias(
              s,
              i,
              /* ignoreDiscriminator */
              !0
            )
          );
        } else
          n.push(
            this.getTypeFromSchema(
              {
                required: e.required,
                ...s
              },
              void 0,
              i
            )
          );
      return (e.properties || e.additionalProperties) && n.push(
        this.getTypeFromProperties(
          e.properties || {},
          e.required,
          e.additionalProperties,
          i
        )
      ), o.createIntersectionTypeNode(n);
    }
    if (Array.isArray(e.type))
      return o.createUnionTypeNode(
        e.type.map((n) => {
          const s = { ...e, type: n };
          return "items" in s && n !== "array" && delete s.items, "properties" in s && n !== "object" && delete s.properties, this.getBaseTypeFromSchema(s, r, i);
        })
      );
    if ("items" in e) {
      const n = e.items;
      if (n.enum) {
        const s = this.isTrueEnum(n, r) ? this.getTrueEnum(n, r) : V(n.enum);
        return o.createArrayTypeNode(s);
      }
      return o.createArrayTypeNode(
        this.getTypeFromSchema(e.items, void 0, i)
      );
    }
    if ("prefixItems" in e && e.prefixItems)
      return o.createTupleTypeNode(
        e.prefixItems.map((n) => this.getTypeFromSchema(n))
      );
    if (e.properties || e.additionalProperties)
      return this.getTypeFromProperties(
        e.properties || {},
        e.required,
        e.additionalProperties,
        i
      );
    if (e.enum)
      return this.isTrueEnum(e, r) ? this.getTrueEnum(e, r) : V(e.enum);
    if (e.format == "binary")
      return o.createTypeReferenceNode("Blob", []);
    if (e.const)
      return this.getTypeFromEnum([e.const]);
    if (e.type !== void 0) {
      if (e.type === null) return h.null;
      if (Qe(e.type)) return h[e.type];
    }
    return this.getEmptySchemaType();
  }
  isTrueEnum(e, r) {
    return !!(typeof e != "boolean" && e.enum && this.opts.useEnumType && r && e.type !== "boolean");
  }
  /**
   * Get enum member reference type for discriminator values when useEnumType is enabled
   */
  getDiscriminatorType(e, r, i) {
    if (!this.opts.useEnumType)
      return this.getTypeFromEnum(i);
    const n = this.resolve(e);
    let s = this.resolve(
      n.properties?.[r]
    );
    if (!s && n.allOf)
      for (const f of n.allOf) {
        const p = this.resolve(f);
        if (p.properties?.[r]) {
          s = this.resolve(
            p.properties[r]
          );
          break;
        }
      }
    if (!s || !this.isTrueEnum(s, r))
      return this.getTypeFromEnum(i);
    const a = this.getTrueEnum(
      s,
      r
    );
    if (i.length === 1) {
      const f = o.createIdentifier(
        O(i[0], !0)
      ), p = a.typeName;
      return o.createTypeReferenceNode(
        o.createQualifiedName(p, f),
        void 0
      );
    } else {
      const f = a.typeName, p = i.map((l) => {
        const m = o.createIdentifier(
          O(l, !0)
        );
        return o.createTypeReferenceNode(
          o.createQualifiedName(f, m),
          void 0
        );
      });
      return o.createUnionTypeNode(p);
    }
  }
  /**
   * Creates literal type (or union) from an array of values
   */
  getTypeFromEnum(e) {
    const r = e.map((i) => {
      if (i === null) return h.null;
      if (typeof i == "boolean")
        return i ? o.createLiteralTypeNode(
          u.factory.createToken(u.SyntaxKind.TrueKeyword)
        ) : o.createLiteralTypeNode(
          u.factory.createToken(u.SyntaxKind.FalseKeyword)
        );
      if (typeof i == "number")
        return o.createLiteralTypeNode(o.createNumericLiteral(i));
      if (typeof i == "string")
        return o.createLiteralTypeNode(o.createStringLiteral(i));
      throw new Error(`Unexpected ${String(i)} of type ${typeof i} in enum`);
    });
    return r.length > 1 ? o.createUnionTypeNode(r) : r[0];
  }
  getEnumValuesString(e) {
    return e.join("_");
  }
  /*
    Creates a enum "ref" if not used, reuse existing if values and name matches or creates a new one
    with a new name adding a number
  */
  getTrueEnum(e, r) {
    if (typeof e == "boolean")
      throw new Error(
        "cannot get enum from boolean schema. schema must be an object"
      );
    const n = (e.title || T.upperFirst(r)).split(/[^A-Za-z0-9$_]/g).map((g) => T.upperFirst(g)).join(""), s = this.getEnumValuesString(
      e.enum ? e.enum : []
    ), a = this.getEnumUniqueAlias(n, s);
    if (this.enumRefs[n] && n === a)
      return this.enumRefs[n].type;
    const f = e.enum ? e.enum : [], p = e["x-enumNames"] ?? e["x-enum-varnames"];
    if (p) {
      if (!Array.isArray(p))
        throw new Error("enum names must be an array");
      if (p.length !== f.length)
        throw new Error("enum names must have the same length as enum values");
    }
    const l = f.map((g, S) => {
      if (e.type === "number" || e.type === "integer" || e.type === "string") {
        const N = p ? p[S] : String(g);
        return o.createEnumMember(
          o.createIdentifier(O(N, !0)),
          q(g)
        );
      }
      return o.createEnumMember(
        o.createIdentifier(O(g, !0)),
        q(g)
      );
    });
    this.enumAliases.push(
      o.createEnumDeclaration([P.export], a, l)
    );
    const m = o.createTypeReferenceNode(a, void 0);
    return this.enumRefs[n] = {
      values: s,
      type: o.createTypeReferenceNode(a, void 0)
    }, m;
  }
  /**
   * Checks if readOnly/writeOnly properties are present in the given schema.
   * Returns a tuple of booleans; the first one is about readOnly, the second
   * one is about writeOnly.
   */
  checkSchemaOnlyMode(e, r = !0) {
    if (this.opts.mergeReadWriteOnly)
      return { readOnly: !1, writeOnly: !1 };
    const i = (n, s) => {
      if (w(n)) {
        if (!r) return { readOnly: !1, writeOnly: !1 };
        if (s.has(n.$ref))
          return { readOnly: !1, writeOnly: !1 };
        const l = this.refsOnlyMode.get(n.$ref);
        if (l) return l;
        s.add(n.$ref);
        const m = i(this.resolve(n), s);
        return s.delete(n.$ref), this.refsOnlyMode.set(n.$ref, m), m;
      }
      if (typeof n == "boolean")
        return { readOnly: !1, writeOnly: !1 };
      let a = n.readOnly ?? !1, f = n.writeOnly ?? !1;
      const p = [];
      "items" in n && n.items ? p.push(n.items) : (p.push(...Object.values(n.properties ?? {})), p.push(...n.allOf ?? []), p.push(...n.anyOf ?? []), p.push(...n.oneOf ?? []));
      for (const l of p) {
        if (a && f) break;
        const m = i(l, s);
        a = a || m.readOnly, f = f || m.writeOnly;
      }
      return { readOnly: a, writeOnly: f };
    };
    return i(e, /* @__PURE__ */ new Set());
  }
  /**
   * Recursively creates a type literal with the given props.
   */
  getTypeFromProperties(e, r, i, n) {
    const f = Object.keys(e).filter((p) => {
      const l = e[p], { readOnly: m, writeOnly: g } = this.checkSchemaOnlyMode(l, !1);
      switch (n) {
        case "readOnly":
          return m || !g;
        case "writeOnly":
          return g || !m;
        default:
          return !m && !g;
      }
    }).map((p) => {
      const l = e[p], m = r && r.includes(p);
      let g = this.getTypeFromSchema(l, p, n);
      !m && this.opts.unionUndefined && (g = o.createUnionTypeNode([g, h.undefined]));
      const S = x({
        questionToken: !m,
        name: p,
        type: g
      });
      if (typeof l != "boolean" && "description" in l && l.description) {
        const N = l.description.replace("*/", "*\\/");
        u.addSyntheticLeadingComment(
          S,
          u.SyntaxKind.MultiLineCommentTrivia,
          // Ensures it is formatted like a JSDoc comment: /** description here */
          `* ${N} `,
          !0
        );
      }
      return S;
    });
    if (i) {
      const p = i === !0 ? this.getEmptySchemaType() : this.getTypeFromSchema(i, void 0, n);
      f.push(Te(p));
    }
    return o.createTypeLiteralNode(f);
  }
  getTypeFromResponses(e, r) {
    return o.createUnionTypeNode(
      Object.entries(e).map(([i, n]) => {
        const s = i === "default" ? h.number : o.createLiteralTypeNode(o.createNumericLiteral(i)), a = [
          x({
            name: "status",
            type: s
          })
        ], f = this.getTypeFromResponse(n, r);
        return f !== h.void && a.push(
          x({
            name: "data",
            type: f
          })
        ), o.createTypeLiteralNode(a);
      })
    );
  }
  getTypeFromResponse(e, r) {
    const i = this.resolve(e);
    return !i || !i.content ? h.void : this.getTypeFromSchema(
      this.getSchemaFromContent(i.content),
      void 0,
      r
    );
  }
  getResponseType(e) {
    if (!e) return "text";
    const r = Object.values(e).map(
      (n) => this.resolve(n)
    );
    return r.some(
      (n) => Object.keys(n.content ?? {}).length > 0
    ) ? r.some((n) => Object.keys(n.content ?? {}).some(Z)) ? "json" : r.some(
      (n) => Object.keys(n.content ?? []).some((s) => s.startsWith("text/"))
    ) ? "text" : "blob" : "text";
  }
  getSchemaFromContent(e) {
    const r = Object.keys(e).find($e);
    if (r) {
      const { schema: i } = e[r];
      if (i)
        return i;
    }
    return Object.keys(e).length === 0 || Object.keys(e).some((i) => i.startsWith("text/")) ? { type: "string" } : { type: "string", format: "binary" };
  }
  getTypeFromParameter(e) {
    if (e.content) {
      const r = this.getSchemaFromContent(e.content);
      return this.getTypeFromSchema(r);
    }
    return this.getTypeFromSchema(w(e) ? e : e.schema);
  }
  wrapResult(e) {
    return this.opts?.optimistic ? z("ok", [e]) : e;
  }
  /**
   * Does three things:
   * 1. Add a `x-component-ref-path` property.
   * 2. Record discriminating schemas in `this.discriminatingSchemas`. A discriminating schema
   *    refers to a schema that has a `discriminator` property which is neither used in conjunction
   *    with `oneOf` nor `anyOf`.
   * 3. Make all mappings of discriminating schemas explicit to generate types immediately.
   */
  preprocessComponents(e) {
    const r = "#/components/schemas/";
    for (const n of Object.keys(e)) {
      const s = e[n];
      w(s) || typeof s == "boolean" || (s["x-component-ref-path"] = r + n, typeof s != "boolean" && s.discriminator && !s.oneOf && !s.anyOf && this.discriminatingSchemas.add(r + n));
    }
    const i = (n, s) => Object.values(n.mapping || {}).includes(s);
    for (const n of Object.keys(e)) {
      const s = e[n];
      if (!(w(s) || typeof s == "boolean" || !s.allOf))
        for (const a of s.allOf) {
          if (!w(a) || !this.discriminatingSchemas.has(a.$ref))
            continue;
          const p = e[R(a.$ref)].discriminator;
          i(p, r + n) || (p.mapping || (p.mapping = {}), p.mapping[n] = r + n);
        }
    }
  }
  generateApi() {
    this.reset();
    const e = u.createSourceFile(
      "ApiStub.ts",
      `/**
 * DO NOT MODIFY - This file has been generated using oazapfts.
 * See https://www.npmjs.com/package/oazapfts
 */

import * as Oazapfts from "@oazapfts/runtime";
import * as QS from "@oazapfts/runtime/query";

export const defaults: Oazapfts.Defaults<Oazapfts.CustomHeaders> = {
  headers: {},
  baseUrl: "/",
};

const oazapfts = Oazapfts.runtime(defaults);

export const servers = {};
`,
      // replaced with ApiStub.ts during build
      u.ScriptTarget.Latest,
      /*setParentNodes*/
      !1,
      u.ScriptKind.TS
    ), r = Y(e.statements, "servers");
    Object.assign(r, {
      initializer: Re(this.spec.servers || [])
    });
    const { initializer: i } = Y(
      e.statements,
      "defaults"
    );
    if (!i || !u.isObjectLiteralExpression(i))
      throw new Error("No object literal: defaults");
    Oe(
      i,
      "baseUrl",
      Le(this.spec.servers || [])
    );
    const n = [], s = {};
    return this.spec.paths && Object.keys(this.spec.paths).forEach((a) => {
      if (!this.spec.paths) return;
      const f = this.spec.paths[a];
      f && Object.keys(this.resolve(f)).forEach((p) => {
        const l = p.toUpperCase();
        if (!Ie.includes(l)) return;
        const m = f[p], {
          operationId: g,
          requestBody: S,
          responses: N,
          summary: xe,
          description: ve,
          tags: Ee
        } = m;
        if (this.skip(Ee))
          return;
        let D = De(p, a, g);
        const ie = s[D] = (s[D] || 0) + 1;
        ie > 1 && (D += ie);
        const B = this.resolveArray(f.parameters);
        for (const d of this.resolveArray(m.parameters))
          B.find(
            (j) => j.name === d.name && j.in === d.in
          ) || B.push(d);
        const k = this.isConverted ? He(B) : B, J = /* @__PURE__ */ new Map();
        T.sortBy(k, "name.length").forEach((d) => {
          const b = O(d.name), E = [...J.values()].includes(b) ? T.upperFirst(d.in) : "";
          J.set(d, b + E);
        });
        const A = (d) => {
          const b = J.get(d);
          if (!b) throw new Error(`Can't find parameter: ${d.name}`);
          return b;
        }, L = [];
        let K, v;
        switch (this.opts.argumentStyle ?? "positional") {
          case "positional":
            const [d, b] = T.partition(k, "required"), j = d.map(
              (y) => F(A(this.resolve(y)), {
                type: this.getTypeFromParameter(y)
              })
            );
            if (L.push(...j), S) {
              K = this.resolve(S);
              const y = this.getSchemaFromContent(K.content), $ = this.getTypeFromSchema(
                y,
                void 0,
                "writeOnly"
              );
              v = O(
                $.name || ue(y) || "body"
              ), L.push(
                F(v, {
                  type: $,
                  questionToken: !K.required
                })
              );
            }
            b.length && L.push(
              F(
                H(
                  b.map((y) => this.resolve(y)).map((y) => ({ name: A(y) }))
                ),
                {
                  initializer: o.createObjectLiteralExpression(),
                  type: o.createTypeLiteralNode(
                    b.map(
                      (y) => x({
                        name: A(this.resolve(y)),
                        questionToken: !0,
                        type: this.getTypeFromParameter(y)
                      })
                    )
                  )
                }
              )
            );
            break;
          case "object":
            const E = k.map(
              (y) => x({
                name: A(this.resolve(y)),
                questionToken: !y.required,
                type: this.getTypeFromParameter(y)
              })
            );
            if (S) {
              K = this.resolve(S);
              const y = this.getSchemaFromContent(K.content), $ = this.getTypeFromSchema(
                y,
                void 0,
                "writeOnly"
              );
              v = O(
                $.name || ue(y) || "body"
              ), E.push(
                x({
                  name: v,
                  questionToken: !K.required,
                  type: $
                })
              );
            }
            if (E.length === 0)
              break;
            L.push(
              F(
                H([
                  ...k.map((y) => this.resolve(y)).map((y) => ({ name: A(y) })),
                  ...v ? [{ name: v }] : []
                ]),
                {
                  type: o.createTypeLiteralNode(E)
                }
              )
            );
            break;
        }
        L.push(
          F("opts", {
            type: o.createTypeReferenceNode(
              "Oazapfts.RequestOpts",
              void 0
            ),
            questionToken: !0
          })
        );
        const G = this.getResponseType(N), se = k.filter((d) => d.in === "query"), oe = k.filter((d) => d.in === "header");
        let ae;
        if (se.length) {
          const d = T.groupBy(se, qe);
          ae = pe(
            "query",
            Object.entries(d).map(([b, j]) => pe(b, [
              ee(
                j.map((E) => [E.name, A(E)])
              )
            ]))
          );
        }
        const Fe = _e(a, ae), I = [
          o.createSpreadAssignment(o.createIdentifier("opts"))
        ];
        l !== "GET" && I.push(
          o.createPropertyAssignment(
            "method",
            o.createStringLiteral(l)
          )
        ), v && I.push(
          _(
            "body",
            o.createIdentifier(v)
          )
        ), oe.length && I.push(
          o.createPropertyAssignment(
            "headers",
            z("mergeHeaders", [
              o.createPropertyAccessChain(
                o.createIdentifier("opts"),
                o.createToken(u.SyntaxKind.QuestionDotToken),
                "headers"
              ),
              o.createObjectLiteralExpression(
                [
                  ...oe.map(
                    (d) => _(
                      d.name,
                      o.createIdentifier(A(d))
                    )
                  )
                ],
                !0
              )
            ])
          )
        );
        const ce = [Fe];
        if (I.length) {
          const d = Ue(K), b = o.createObjectLiteralExpression(I, !0);
          ce.push(
            d ? z(d, [b]) : b
          );
        }
        n.push(
          Ne(
            he(
              D,
              {
                modifiers: [P.export]
              },
              L,
              ye(
                o.createReturnStatement(
                  this.wrapResult(
                    z(
                      {
                        json: "fetchJson",
                        text: "fetchText",
                        blob: "fetchBlob"
                      }[G],
                      ce,
                      G === "json" || G === "blob" ? [
                        this.getTypeFromResponses(
                          N,
                          "readOnly"
                        ) || u.SyntaxKind.AnyKeyword
                      ] : void 0
                    )
                  )
                )
              )
            ),
            xe || ve
          )
        );
      });
    }), Object.assign(e, {
      statements: we(
        e.statements,
        ...this.aliases,
        ...n,
        ...this.enumAliases
      )
    }), e;
  }
}
const c = u.factory, de = c.createToken(u.SyntaxKind.QuestionToken);
function Q(t) {
  if (t)
    return t === !0 ? de : t;
}
const h = {
  any: c.createKeywordTypeNode(u.SyntaxKind.AnyKeyword),
  number: c.createKeywordTypeNode(u.SyntaxKind.NumberKeyword),
  integer: c.createKeywordTypeNode(u.SyntaxKind.NumberKeyword),
  object: c.createKeywordTypeNode(u.SyntaxKind.ObjectKeyword),
  string: c.createKeywordTypeNode(u.SyntaxKind.StringKeyword),
  boolean: c.createKeywordTypeNode(u.SyntaxKind.BooleanKeyword),
  undefined: c.createKeywordTypeNode(u.SyntaxKind.UndefinedKeyword),
  void: c.createKeywordTypeNode(u.SyntaxKind.VoidKeyword),
  never: c.createKeywordTypeNode(u.SyntaxKind.NeverKeyword),
  null: c.createLiteralTypeNode(c.createNull()),
  unknown: c.createKeywordTypeNode(u.SyntaxKind.UnknownKeyword)
};
function We(t) {
  return h[t];
}
const P = {
  async: c.createModifier(u.SyntaxKind.AsyncKeyword),
  export: c.createModifier(u.SyntaxKind.ExportKeyword)
};
function q(t) {
  switch (typeof t) {
    case "string":
      return c.createStringLiteral(t);
    case "boolean":
      return t ? c.createTrue() : c.createFalse();
    case "number":
      return String(t).charAt(0) === "-" ? c.createPrefixUnaryExpression(
        u.SyntaxKind.MinusToken,
        c.createNumericLiteral(String(-t))
      ) : c.createNumericLiteral(String(t));
  }
}
function V(t) {
  const e = t.map(
    (r) => r === null ? h.null : c.createLiteralTypeNode(q(r))
  );
  return e.length > 1 ? c.createUnionTypeNode(e) : e[0];
}
function M({
  modifiers: t,
  name: e,
  typeParameters: r,
  type: i
}) {
  return c.createTypeAliasDeclaration(
    t,
    e,
    r,
    i
  );
}
function Je({
  modifiers: t,
  name: e,
  typeParameters: r,
  type: i,
  inheritedNodeNames: n
}) {
  const s = n ? [
    c.createHeritageClause(
      u.SyntaxKind.ExtendsKeyword,
      n.map((a) => {
        const f = typeof a == "string" ? a : a.escapedText.toString();
        return c.createExpressionWithTypeArguments(
          c.createIdentifier(
            O(f, !0)
          ),
          void 0
        );
      })
    )
  ] : [];
  return c.createInterfaceDeclaration(
    t,
    e,
    r,
    s,
    i.members
  );
}
function X(t) {
  return typeof t == "string" ? c.createIdentifier(t) : t;
}
function C(t, {
  typeArgs: e,
  args: r
} = {}) {
  return c.createCallExpression(X(t), e, r);
}
function Ge(t, e) {
  return C(
    c.createPropertyAccessExpression(c.createThis(), t),
    e
  );
}
function ee(t) {
  return c.createObjectLiteralExpression(
    t.map(
      ([e, r]) => _(e, X(r))
    ),
    !0
  );
}
function _(t, e) {
  return u.isIdentifier(e) && e.text === t ? c.createShorthandPropertyAssignment(t) : c.createPropertyAssignment(ge(t), e);
}
function ye(...t) {
  return c.createBlock(t, !0);
}
function me(t, e, {
  modifiers: r,
  typeParameters: i,
  type: n,
  equalsGreaterThanToken: s
} = {}) {
  return c.createArrowFunction(
    r,
    i,
    t,
    n,
    s,
    e
  );
}
function he(t, {
  modifiers: e,
  asteriskToken: r,
  typeParameters: i,
  type: n
}, s, a) {
  return c.createFunctionDeclaration(
    e,
    r,
    t,
    i,
    s,
    n,
    a
  );
}
function Ye({
  modifiers: t,
  name: e,
  typeParameters: r,
  heritageClauses: i,
  members: n
}) {
  return c.createClassDeclaration(
    t,
    e,
    r,
    i,
    n
  );
}
function Ze({
  modifiers: t,
  parameters: e,
  body: r
}) {
  return c.createConstructorDeclaration(t, e, r);
}
function Xe(t, {
  modifiers: e,
  asteriskToken: r,
  questionToken: i,
  typeParameters: n,
  type: s
} = {}, a = [], f) {
  return c.createMethodDeclaration(
    e,
    r,
    t,
    Q(i),
    n,
    a,
    s,
    f
  );
}
function F(t, {
  modifiers: e,
  dotDotDotToken: r,
  questionToken: i,
  type: n,
  initializer: s
}) {
  return c.createParameterDeclaration(
    e,
    r,
    t,
    Q(i),
    n,
    s
  );
}
function ge(t) {
  return typeof t == "string" ? W(t) ? c.createIdentifier(t) : c.createStringLiteral(t) : t;
}
function x({
  modifiers: t,
  name: e,
  questionToken: r,
  type: i
}) {
  return c.createPropertySignature(
    t,
    ge(e),
    Q(r),
    i
  );
}
function Te(t, {
  modifiers: e,
  indexName: r = "key",
  indexType: i = h.string
} = {}) {
  return c.createIndexSignature(
    e,
    [F(r, { type: i })],
    t
  );
}
function H(t) {
  return c.createObjectBindingPattern(
    t.map(
      ({ dotDotDotToken: e, propertyName: r, name: i, initializer: n }) => c.createBindingElement(
        e,
        r,
        i,
        n
      )
    )
  );
}
function te(t, e) {
  return e.length ? c.createTemplateExpression(
    c.createTemplateHead(t),
    e.map(
      ({ expression: r, literal: i }, n) => c.createTemplateSpan(
        r,
        n === e.length - 1 ? c.createTemplateTail(i) : c.createTemplateMiddle(i)
      )
    )
  ) : c.createStringLiteral(t);
}
function Se(t, e, r) {
  const i = t.find(
    (n) => n.kind === e && (!r || r(n))
  );
  if (!i) throw new Error(`Node not found: ${e}`);
  return i;
}
function re(t) {
  return u.isIdentifier(t) ? t.escapedText : u.isLiteralExpression(t) ? t.text : "";
}
function be(t) {
  const e = u.getNameOfDeclaration(t.declarationList.declarations[0]);
  return e ? re(e) : "";
}
function Y(t, e) {
  const r = Se(
    t,
    u.SyntaxKind.VariableStatement,
    (n) => be(n) === e
  ), [i] = r.declarationList.declarations;
  if (!i) throw new Error("Missing declaration");
  return i;
}
function Oe(t, e, r) {
  const i = t.properties.find(
    (n) => u.isPropertyAssignment(n) && re(n.name) === e
  );
  if (i && u.isPropertyAssignment(i))
    Object.assign(i, { initializer: r });
  else
    throw new Error(`No such property: ${e}`);
}
function we(t, ...e) {
  return c.createNodeArray([...t, ...e]);
}
function Ne(t, e) {
  return e ? u.addSyntheticLeadingComment(
    t,
    u.SyntaxKind.MultiLineCommentTrivia,
    `*
 * ${e.replace(/\n/g, `
 * `)}
 `,
    !0
  ) : t;
}
const ne = u.createPrinter({
  newLine: u.NewLineKind.LineFeed
});
function et(t) {
  const e = u.createSourceFile(
    "someFileName.ts",
    "",
    u.ScriptTarget.Latest,
    /*setParentNodes*/
    !1,
    u.ScriptKind.TS
  );
  return ne.printNode(u.EmitHint.Unspecified, t, e);
}
function tt(t) {
  const e = u.createSourceFile(
    "someFileName.ts",
    "",
    u.ScriptTarget.Latest,
    /*setParentNodes*/
    !1,
    u.ScriptKind.TS
  );
  return t.map((r) => ne.printNode(u.EmitHint.Unspecified, r, e)).join(`
`);
}
function rt(t) {
  return ne.printFile(t);
}
function W(t) {
  if (!t.length || t.trim() !== t) return !1;
  const e = u.parseIsolatedEntityName(t, u.ScriptTarget.Latest);
  return !!e && e.kind === u.SyntaxKind.Identifier && u.identifierToKeywordKind(e) === void 0;
}
const ot = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addComment: Ne,
  appendNodes: we,
  block: ye,
  changePropertyValue: Oe,
  createArrowFunction: me,
  createCall: C,
  createClassDeclaration: Ye,
  createConstructor: Ze,
  createEnumTypeNode: V,
  createFunctionDeclaration: he,
  createIndexSignature: Te,
  createInterfaceAliasDeclaration: Je,
  createKeywordType: We,
  createLiteral: q,
  createMethod: Xe,
  createMethodCall: Ge,
  createObjectBinding: H,
  createObjectLiteral: ee,
  createParameter: F,
  createPropertyAssignment: _,
  createPropertySignature: x,
  createQuestionToken: Q,
  createTemplateString: te,
  createTypeAliasDeclaration: M,
  findFirstVariableDeclaration: Y,
  findNode: Se,
  getFirstDeclarationName: be,
  getName: re,
  isValidIdentifier: W,
  keywordType: h,
  modifier: P,
  printFile: rt,
  printNode: et,
  printNodes: tt,
  questionToken: de,
  toExpression: X
}, Symbol.toStringTag, { value: "Module" }));
export {
  W as $,
  st as A,
  Je as B,
  X as C,
  C as D,
  Ge as E,
  ee as F,
  _ as G,
  ye as H,
  me as I,
  he as J,
  Ye as K,
  Ze as L,
  Xe as M,
  F as N,
  x as O,
  Te as P,
  H as Q,
  te as R,
  Se as S,
  re as T,
  be as U,
  Y as V,
  Oe as W,
  we as X,
  Ne as Y,
  et as Z,
  tt as _,
  Z as a,
  Le as a0,
  qe as b,
  Ce as c,
  De as d,
  Be as e,
  w as f,
  Ue as g,
  ue as h,
  $e as i,
  O as j,
  _e as k,
  pe as l,
  z as m,
  Q as n,
  h as o,
  rt as p,
  de as q,
  le as r,
  He as s,
  ot as t,
  We as u,
  Ie as v,
  P as w,
  q as x,
  V as y,
  M as z
};
//# sourceMappingURL=tscodegen-CQ_2EobI.js.map
