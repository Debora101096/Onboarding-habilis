{"version":3,"file":"tscodegen-CQ_2EobI.js","sources":["../src/generateServers.ts","../src/generate.ts","../src/tscodegen.ts"],"sourcesContent":["import _ from \"lodash\";\nimport * as cg from \"./tscodegen\";\nimport ts from \"typescript\";\nimport { OpenAPIV3 } from \"openapi-types\";\n\nconst factory = ts.factory;\n\nfunction createTemplate(url: string) {\n  const tokens = url.split(/{([\\s\\S]+?)}/g);\n  const chunks = _.chunk(tokens.slice(1), 2);\n  return cg.createTemplateString(\n    tokens[0],\n    chunks.map(([expression, literal]) => ({\n      expression: factory.createIdentifier(expression),\n      literal,\n    })),\n  );\n}\n\nfunction createServerFunction(\n  template: string,\n  vars: Record<string, OpenAPIV3.ServerVariableObject>,\n) {\n  const params = [\n    cg.createParameter(\n      cg.createObjectBinding(\n        Object.entries(vars || {}).map(([name, value]) => {\n          return {\n            name,\n            initializer: cg.createLiteral(value.default),\n          };\n        }),\n      ),\n      {\n        type: factory.createTypeLiteralNode(\n          Object.entries(vars || {}).map(([name, value]) => {\n            return cg.createPropertySignature({\n              name,\n              type: value.enum\n                ? cg.createEnumTypeNode(value.enum)\n                : factory.createUnionTypeNode([\n                    cg.keywordType.string,\n                    cg.keywordType.number,\n                    cg.keywordType.boolean,\n                  ]),\n            });\n          }),\n        ),\n      },\n    ),\n  ];\n\n  return cg.createArrowFunction(params, createTemplate(template));\n}\n\nfunction generateServerExpression(server: OpenAPIV3.ServerObject) {\n  return server.variables\n    ? createServerFunction(server.url, server.variables)\n    : factory.createStringLiteral(server.url);\n}\n\nfunction defaultUrl(server?: OpenAPIV3.ServerObject) {\n  if (!server) return \"/\";\n  const { url, variables } = server;\n  if (!variables) return url;\n  return url.replace(/\\{(.+?)\\}/g, (m, name) =>\n    variables[name] ? String(variables[name].default) : m,\n  );\n}\n\nexport function defaultBaseUrl(servers: OpenAPIV3.ServerObject[]) {\n  return factory.createStringLiteral(defaultUrl(servers[0]));\n}\n\nfunction serverName(server: OpenAPIV3.ServerObject, index: number) {\n  return server.description\n    ? _.camelCase(server.description.replace(/\\W+/, \" \"))\n    : `server${index + 1}`;\n}\n\nexport default function generateServers(\n  servers: OpenAPIV3.ServerObject[],\n): ts.ObjectLiteralExpression {\n  return cg.createObjectLiteral(\n    servers.map((server, i) => [\n      serverName(server, i),\n      generateServerExpression(server),\n    ]),\n  );\n}\n","import _ from \"lodash\";\nimport ts from \"typescript\";\nimport { OpenAPIV3, OpenAPIV3_1 } from \"openapi-types\";\nimport * as cg from \"./tscodegen\";\nimport generateServers, { defaultBaseUrl } from \"./generateServers\";\nimport { Opts } from \".\";\n\nexport * from \"./tscodegen\";\nexport * from \"./generateServers\";\n\nconst factory = ts.factory;\n\nexport const verbs = [\n  \"GET\",\n  \"PUT\",\n  \"POST\",\n  \"DELETE\",\n  \"OPTIONS\",\n  \"HEAD\",\n  \"PATCH\",\n  \"TRACE\",\n];\n\ntype ContentType = \"json\" | \"form\" | \"multipart\";\ntype OnlyMode = \"readOnly\" | \"writeOnly\";\ntype OnlyModes = Record<OnlyMode, boolean>;\n\n// Use union of OAS 3.0 and 3.1 types throughout\n// openapi-types does not define boolean json schemas (https://json-schema.org/draft/2020-12/json-schema-core#section-4.3.2)\ntype OpenAPISchemaObject =\n  | OpenAPIV3.SchemaObject\n  | OpenAPIV3_1.SchemaObject\n  | boolean;\ntype OpenAPIReferenceObject =\n  | OpenAPIV3.ReferenceObject\n  | OpenAPIV3_1.ReferenceObject;\ntype OpenAPIParameterObject =\n  | OpenAPIV3.ParameterObject\n  | OpenAPIV3_1.ParameterObject;\nexport type OpenAPIDocument = OpenAPIV3.Document | OpenAPIV3_1.Document;\ntype OpenAPIDiscriminatorObject =\n  | OpenAPIV3.DiscriminatorObject\n  | OpenAPIV3_1.DiscriminatorObject;\ntype OpenAPIResponseObject =\n  | OpenAPIV3.ResponseObject\n  | OpenAPIV3_1.ResponseObject;\ntype OpenAPIResponsesObject =\n  | OpenAPIV3.ResponsesObject\n  | OpenAPIV3_1.ResponsesObject;\ntype OpenAPIRequestBodyObject =\n  | OpenAPIV3.RequestBodyObject\n  | OpenAPIV3_1.RequestBodyObject;\ntype OpenAPIMediaTypeObject =\n  | OpenAPIV3.MediaTypeObject\n  | OpenAPIV3_1.MediaTypeObject;\ntype OpenAPIOperationObject =\n  | OpenAPIV3.OperationObject\n  | OpenAPIV3_1.OperationObject;\n\nconst contentTypes: Record<string, ContentType> = {\n  \"*/*\": \"json\",\n  \"application/json\": \"json\",\n  \"application/x-www-form-urlencoded\": \"form\",\n  \"multipart/form-data\": \"multipart\",\n};\n\nexport function isMimeType(s: unknown) {\n  return typeof s === \"string\" && /^[^/]+\\/[^/]+$/.test(s);\n}\n\nexport function isJsonMimeType(mime: string) {\n  return contentTypes[mime] === \"json\" || /\\bjson\\b/i.test(mime);\n}\n\nexport function getBodyFormatter(body?: OpenAPIRequestBodyObject) {\n  if (body?.content) {\n    for (const contentType of Object.keys(body.content)) {\n      const formatter = contentTypes[contentType];\n      if (formatter) return formatter;\n      if (isJsonMimeType(contentType)) return \"json\";\n    }\n  }\n}\n\n// Augment SchemaObject type to allow slowly adopting new OAS3.1+ features\n// and support custom vendor extensions.\nexport type SchemaObject = OpenAPISchemaObject & {\n  const?: unknown;\n  \"x-enumNames\"?: string[];\n  \"x-enum-varnames\"?: string[];\n  \"x-component-ref-path\"?: string;\n  prefixItems?: (OpenAPIReferenceObject | SchemaObject)[];\n};\n\nexport type DiscriminatingSchemaObject = Exclude<SchemaObject, boolean> & {\n  discriminator: NonNullable<Exclude<SchemaObject, boolean>[\"discriminator\"]>;\n};\n\n/**\n * Get the name of a formatter function for a given parameter.\n */\nexport function getFormatter({\n  style = \"form\",\n  explode = true,\n  content,\n}: OpenAPIParameterObject) {\n  if (content) {\n    const medias = Object.keys(content);\n    if (medias.length !== 1) {\n      throw new Error(\n        \"Parameters with content property must specify one media type\",\n      );\n    }\n    if (!isJsonMimeType(medias[0])) {\n      throw new Error(\n        \"Parameters with content property must specify a JSON compatible media type\",\n      );\n    }\n    return \"json\";\n  }\n  if (explode && style === \"deepObject\") return \"deep\";\n  if (explode) return \"explode\";\n  if (style === \"spaceDelimited\") return \"space\";\n  if (style === \"pipeDelimited\") return \"pipe\";\n  return \"form\";\n}\n\nexport function getOperationIdentifier(id?: string) {\n  if (!id) return;\n  if (id.match(/[^\\w\\s]/)) return;\n  id = _.camelCase(id);\n  if (cg.isValidIdentifier(id)) return id;\n}\n\n/**\n * Create a method name for a given operation, either from its operationId or\n * the HTTP verb and path.\n */\nexport function getOperationName(\n  verb: string,\n  path: string,\n  operationId?: string,\n) {\n  const id = getOperationIdentifier(operationId);\n  if (id) return id;\n  path = path.replace(/\\{(.+?)\\}/, \"by $1\").replace(/\\{(.+?)\\}/, \"and $1\");\n  return toIdentifier(`${verb} ${path}`);\n}\n\nexport function isNullable(schema?: SchemaObject | OpenAPIReferenceObject) {\n  if (typeof schema === \"boolean\") return schema;\n\n  if (schema && \"nullable\" in schema)\n    return !isReference(schema) && schema.nullable;\n\n  return false;\n}\n\nexport function isReference(obj: unknown): obj is OpenAPIReferenceObject {\n  return typeof obj === \"object\" && obj !== null && \"$ref\" in obj;\n}\n\n/**\n * Converts a local reference path into an array of property names.\n */\nexport function refPathToPropertyPath(ref: string) {\n  if (!ref.startsWith(\"#/\")) {\n    throw new Error(\n      `External refs are not supported (${ref}). Make sure to call SwaggerParser.bundle() first.`,\n    );\n  }\n  return ref\n    .slice(2)\n    .split(\"/\")\n    .map((s) => decodeURI(s.replace(/~1/g, \"/\").replace(/~0/g, \"~\")));\n}\n\n/**\n * Get the last path component of the given ref.\n */\nfunction getRefBasename(ref: string) {\n  return ref.replace(/.+\\//, \"\");\n}\n\n/**\n * Returns a name for the given ref that can be used as basis for a type\n * alias. This usually is the baseName, unless the ref starts with a number,\n * in which case the whole ref is returned, with slashes turned into\n * underscores.\n */\nfunction getRefName(ref: string) {\n  const base = getRefBasename(ref);\n  if (/^\\d+/.test(base)) {\n    return refPathToPropertyPath(ref).join(\"_\");\n  }\n  return base;\n}\n\n/**\n * If the given object is a ReferenceObject, return the last part of its path.\n */\nexport function getReferenceName(obj: unknown) {\n  if (isReference(obj)) {\n    return getRefBasename(obj.$ref);\n  }\n}\n\nconst onlyModeSuffixes: Record<OnlyMode, string> = {\n  readOnly: \"Read\",\n  writeOnly: \"Write\",\n};\n\nfunction getOnlyModeSuffix(onlyMode?: OnlyMode) {\n  if (!onlyMode) return \"\";\n  return onlyModeSuffixes[onlyMode];\n}\n\nexport function toIdentifier(\n  s: string,\n  upperFirst = false,\n  onlyMode?: OnlyMode,\n) {\n  let cc = _.camelCase(s) + getOnlyModeSuffix(onlyMode);\n  if (upperFirst) cc = _.upperFirst(cc);\n  if (cg.isValidIdentifier(cc)) return cc;\n  return \"$\" + cc;\n}\n\n/**\n * Create a template string literal from the given OpenAPI urlTemplate.\n * Curly braces in the path are turned into identifier expressions,\n * which are read from the local scope during runtime.\n */\nexport function createUrlExpression(path: string, qs?: ts.Expression) {\n  const spans: Array<{ expression: ts.Expression; literal: string }> = [];\n  // Use a replacer function to collect spans as a side effect:\n  const head = path.replace(\n    /(.*?)\\{(.+?)\\}(.*?)(?=\\{|$)/g,\n    (_substr, head, name, literal) => {\n      const expression = toIdentifier(name);\n      spans.push({\n        expression: cg.createCall(\n          factory.createIdentifier(\"encodeURIComponent\"),\n          { args: [factory.createIdentifier(expression)] },\n        ),\n        literal,\n      });\n      return head;\n    },\n  );\n\n  if (qs) {\n    // add the query string as last span\n    spans.push({ expression: qs, literal: \"\" });\n  }\n  return cg.createTemplateString(head, spans);\n}\n\n/**\n * Create a call expression for one of the QS runtime functions.\n */\nexport function callQsFunction(name: string, args: ts.Expression[]) {\n  return cg.createCall(\n    factory.createPropertyAccessExpression(\n      factory.createIdentifier(\"QS\"),\n      name,\n    ),\n    { args },\n  );\n}\n\n/**\n * Create a call expression for one of the oazapfts runtime functions.\n */\nexport function callOazapftsFunction(\n  name: string,\n  args: ts.Expression[],\n  typeArgs?: ts.TypeNode[],\n) {\n  return cg.createCall(\n    factory.createPropertyAccessExpression(\n      factory.createIdentifier(\"oazapfts\"),\n      name,\n    ),\n    { args, typeArgs },\n  );\n}\n\n/**\n * Despite its name, OpenApi's `deepObject` serialization does not support\n * deeply nested objects. As a workaround we detect parameters that contain\n * square brackets and merge them into a single object.\n */\nexport function supportDeepObjects(params: OpenAPIParameterObject[]) {\n  const res: OpenAPIParameterObject[] = [];\n  const merged: any = {};\n  params.forEach((p) => {\n    const m = /^(.+?)\\[(.*?)\\]/.exec(p.name);\n    if (!m) {\n      res.push(p);\n      return;\n    }\n    const [, name, prop] = m;\n    let obj = merged[name];\n    if (!obj) {\n      obj = merged[name] = {\n        name,\n        in: p.in,\n        style: \"deepObject\",\n        schema: {\n          type: \"object\",\n          properties: {},\n        },\n      };\n      res.push(obj);\n    }\n    obj.schema.properties[prop] = p.schema;\n  });\n  return res;\n}\n\nfunction isKeyOfKeywordType(key: string): key is keyof typeof cg.keywordType {\n  return key in cg.keywordType;\n}\n\n/**\n * Main entry point that generates TypeScript code from a given API spec.\n */\nexport default class ApiGenerator {\n  constructor(\n    public readonly spec: OpenAPIDocument,\n    public readonly opts: Opts = {},\n    /** Indicates if the document was converted from an older version of the OpenAPI specification. */\n    public readonly isConverted = false,\n  ) {\n    if (this.spec.components?.schemas) {\n      this.preprocessComponents(this.spec.components.schemas);\n    }\n  }\n\n  // see `preprocessComponents` for the definition of a discriminating schema\n  discriminatingSchemas: Set<string> = new Set();\n\n  aliases: (ts.TypeAliasDeclaration | ts.InterfaceDeclaration)[] = [];\n\n  enumAliases: ts.Statement[] = [];\n  enumRefs: Record<string, { values: string; type: ts.TypeReferenceNode }> = {};\n\n  // Collect the types of all referenced schemas so we can export them later\n  // Referenced schemas can be pointing at the following versions:\n  // - \"base\": The regular type/interface e.g. ExampleSchema\n  // - \"readOnly\": The readOnly version e.g. ExampleSchemaRead\n  // - \"writeOnly\": The writeOnly version e.g. ExampleSchemaWrite\n  refs: Record<\n    string,\n    {\n      base: ts.TypeReferenceNode;\n      readOnly?: ts.TypeReferenceNode;\n      writeOnly?: ts.TypeReferenceNode;\n    }\n  > = {};\n\n  // Maps a referenced schema to its readOnly/writeOnly status\n  // This field should be used exclusively within the `checkSchemaOnlyMode` method\n  refsOnlyMode: Map<string, OnlyModes> = new Map();\n\n  // Keep track of already used type aliases\n  typeAliases: Record<string, number> = {};\n\n  reset() {\n    this.aliases = [];\n    this.enumAliases = [];\n    this.refs = {};\n    this.typeAliases = {};\n  }\n\n  resolve<T>(obj: T | OpenAPIReferenceObject) {\n    if (!isReference(obj)) return obj;\n    const ref = obj.$ref;\n    const path = refPathToPropertyPath(ref);\n    const resolved = _.get(this.spec, path);\n    if (typeof resolved === \"undefined\") {\n      throw new Error(`Can't find ${path}`);\n    }\n    return resolved as T;\n  }\n\n  resolveArray<T>(array?: Array<T | OpenAPIReferenceObject>) {\n    return array ? array.map((el) => this.resolve(el)) : [];\n  }\n\n  skip(tags?: string[]) {\n    const excluded = tags && tags.some((t) => this.opts?.exclude?.includes(t));\n    if (excluded) {\n      return true;\n    }\n    if (this.opts?.include) {\n      const included = tags && tags.some((t) => this.opts.include?.includes(t));\n      return !included;\n    }\n    return false;\n  }\n\n  findAvailableRef(ref: string) {\n    const available = (ref: string) => {\n      try {\n        this.resolve({ $ref: ref });\n        return false;\n      } catch (error) {\n        return true;\n      }\n    };\n\n    if (available(ref)) return ref;\n\n    let i = 2;\n    while (true) {\n      const key = ref + String(i);\n      if (available(key)) return key;\n      i += 1;\n    }\n  }\n\n  getUniqueAlias(name: string) {\n    let used = this.typeAliases[name] || 0;\n    if (used) {\n      this.typeAliases[name] = ++used;\n      name += used;\n    }\n    this.typeAliases[name] = 1;\n    return name;\n  }\n\n  getEnumUniqueAlias(name: string, values: string) {\n    // If enum name already exists and have the same values\n    if (this.enumRefs[name] && this.enumRefs[name].values == values) {\n      return name;\n    }\n\n    return this.getUniqueAlias(name);\n  }\n\n  /**\n   * Create a type alias for the schema referenced by the given ReferenceObject\n   */\n  getRefAlias(\n    obj: OpenAPIReferenceObject,\n    onlyMode?: OnlyMode,\n    // If true, the discriminator property of the schema referenced by `obj` will be ignored.\n    // This is meant to be used when getting the type of a discriminating schema in an `allOf`\n    // construct.\n    ignoreDiscriminator?: boolean,\n  ) {\n    const $ref = ignoreDiscriminator\n      ? this.findAvailableRef(obj.$ref + \"Base\")\n      : obj.$ref;\n\n    if (!this.refs[$ref]) {\n      let schema = this.resolve<SchemaObject>(obj);\n\n      if (typeof schema !== \"boolean\" && ignoreDiscriminator) {\n        schema = _.cloneDeep(schema);\n        delete schema.discriminator;\n      }\n      const name =\n        (typeof schema !== \"boolean\" && schema.title) || getRefName($ref);\n      const identifier = toIdentifier(name, true);\n\n      // When this is a true enum we can reference it directly,\n      // no need to create a type alias\n      if (this.isTrueEnum(schema, name)) {\n        return this.getTypeFromSchema(schema, name);\n      }\n\n      const alias = this.getUniqueAlias(identifier);\n\n      this.refs[$ref] = {\n        base: factory.createTypeReferenceNode(alias, undefined),\n        readOnly: undefined,\n        writeOnly: undefined,\n      };\n\n      const type = this.getTypeFromSchema(schema, undefined);\n      this.aliases.push(\n        cg.createTypeAliasDeclaration({\n          modifiers: [cg.modifier.export],\n          name: alias,\n          type,\n        }),\n      );\n\n      const { readOnly, writeOnly } = this.checkSchemaOnlyMode(schema);\n\n      if (readOnly) {\n        const readOnlyAlias = this.getUniqueAlias(\n          toIdentifier(name, true, \"readOnly\"),\n        );\n        this.refs[$ref][\"readOnly\"] = factory.createTypeReferenceNode(\n          readOnlyAlias,\n          undefined,\n        );\n\n        const readOnlyType = this.getTypeFromSchema(schema, name, \"readOnly\");\n        this.aliases.push(\n          cg.createTypeAliasDeclaration({\n            modifiers: [cg.modifier.export],\n            name: readOnlyAlias,\n            type: readOnlyType,\n          }),\n        );\n      }\n\n      if (writeOnly) {\n        const writeOnlyAlias = this.getUniqueAlias(\n          toIdentifier(name, true, \"writeOnly\"),\n        );\n        this.refs[$ref][\"writeOnly\"] = factory.createTypeReferenceNode(\n          writeOnlyAlias,\n          undefined,\n        );\n        const writeOnlyType = this.getTypeFromSchema(schema, name, \"writeOnly\");\n        this.aliases.push(\n          cg.createTypeAliasDeclaration({\n            modifiers: [cg.modifier.export],\n            name: writeOnlyAlias,\n            type: writeOnlyType,\n          }),\n        );\n      }\n    }\n\n    // If not ref fallback to the regular reference\n    return this.refs[$ref][onlyMode || \"base\"] ?? this.refs[$ref].base;\n  }\n\n  getUnionType(\n    variants: (OpenAPIReferenceObject | SchemaObject)[],\n    discriminator?: OpenAPIDiscriminatorObject,\n    onlyMode?: OnlyMode,\n  ) {\n    if (discriminator) {\n      // oneOf + discriminator -> tagged union (polymorphism)\n      if (discriminator.propertyName === undefined) {\n        throw new Error(\"Discriminators require a propertyName\");\n      }\n\n      // By default, the last component of the ref name (i.e., after the last trailing slash) is\n      // used as the discriminator value for each variant. This can be overridden using the\n      // discriminator.mapping property.\n      const mappedValues = new Set(\n        Object.values(discriminator.mapping || {}).map(getRefBasename),\n      );\n\n      return factory.createUnionTypeNode(\n        (\n          [\n            ...Object.entries(discriminator.mapping || {}).map(\n              ([discriminatorValue, variantRef]) => [\n                discriminatorValue,\n                { $ref: variantRef },\n              ],\n            ),\n            ...variants\n              .filter((variant) => {\n                if (!isReference(variant)) {\n                  // From the Swagger spec: \"When using the discriminator, inline schemas will not be\n                  // considered.\"\n                  throw new Error(\n                    \"Discriminators require references, not inline schemas\",\n                  );\n                }\n                return !mappedValues.has(getRefBasename(variant.$ref));\n              })\n              .map((schema) => {\n                const schemaBaseName = getRefBasename(\n                  (schema as OpenAPIV3.ReferenceObject).$ref,\n                );\n                const resolvedSchema = this.resolve(\n                  schema,\n                ) as OpenAPIV3.SchemaObject;\n                const discriminatorProperty =\n                  resolvedSchema.properties?.[discriminator.propertyName];\n                const variantName =\n                  discriminatorProperty && \"enum\" in discriminatorProperty\n                    ? discriminatorProperty?.enum?.[0]\n                    : \"\";\n                return [variantName || schemaBaseName, schema];\n              }),\n          ] as [string, OpenAPIReferenceObject][]\n        ).map(([discriminatorValue, variant]) =>\n          // Yields: { [discriminator.propertyName]: discriminatorValue } & variant\n          factory.createIntersectionTypeNode([\n            factory.createTypeLiteralNode([\n              cg.createPropertySignature({\n                name: discriminator.propertyName,\n                type: this.getDiscriminatorType(\n                  variant,\n                  discriminator.propertyName,\n                  [discriminatorValue],\n                ),\n              }),\n            ]),\n            this.getTypeFromSchema(variant, undefined, onlyMode),\n          ]),\n        ),\n      );\n    } else {\n      // oneOf -> untagged union\n      return factory.createUnionTypeNode(\n        _.uniq(\n          variants.map((schema) =>\n            this.getTypeFromSchema(schema, undefined, onlyMode),\n          ),\n        ),\n      );\n    }\n  }\n\n  /**\n   * Creates a type node from a given schema.\n   * Delegates to getBaseTypeFromSchema internally and\n   * optionally adds a union with null.\n   */\n  getTypeFromSchema(\n    schema?: SchemaObject | OpenAPIReferenceObject,\n    name?: string,\n    onlyMode?: OnlyMode,\n  ) {\n    const type = this.getBaseTypeFromSchema(schema, name, onlyMode);\n    return isNullable(schema)\n      ? factory.createUnionTypeNode([type, cg.keywordType.null])\n      : type;\n  }\n\n  getEmptySchemaType() {\n    return this.opts.useUnknown ? cg.keywordType.unknown : cg.keywordType.any;\n  }\n\n  /**\n   * This is the very core of the OpenAPI to TS conversion - it takes a\n   * schema and returns the appropriate type.\n   */\n  getBaseTypeFromSchema(\n    schema?: SchemaObject | OpenAPIReferenceObject,\n    name?: string,\n    onlyMode?: OnlyMode,\n  ): ts.TypeNode {\n    if (!schema && typeof schema !== \"boolean\")\n      return this.getEmptySchemaType();\n    if (isReference(schema)) {\n      return this.getRefAlias(schema, onlyMode) as ts.TypeReferenceNode;\n    }\n\n    if (schema === true) {\n      return this.getEmptySchemaType();\n    }\n\n    if (schema === false) {\n      return cg.keywordType.never;\n    }\n\n    if (schema.oneOf) {\n      const clone = { ...schema };\n      delete clone.oneOf;\n      // oneOf -> union\n      return this.getUnionType(\n        schema.oneOf.map((variant) =>\n          // ensure that base properties from the schema are included in the oneOf variants\n          _.mergeWith({}, clone, variant, (objValue, srcValue) => {\n            if (_.isArray(objValue)) {\n              return objValue.concat(srcValue);\n            }\n          }),\n        ),\n        schema.discriminator,\n        onlyMode,\n      );\n    }\n    if (schema.anyOf) {\n      // anyOf -> union\n      return this.getUnionType(schema.anyOf, undefined, onlyMode);\n    }\n    if (schema.discriminator?.mapping) {\n      // discriminating schema -> union\n      const mapping = schema.discriminator.mapping;\n      return this.getUnionType(\n        Object.values(mapping).map((ref) => ({ $ref: ref })),\n        undefined,\n        onlyMode,\n      );\n    }\n    if (schema.allOf) {\n      // allOf -> intersection\n      const types: Array<ts.TypeNode> = [];\n      for (const childSchema of schema.allOf) {\n        if (\n          isReference(childSchema) &&\n          this.discriminatingSchemas.has(childSchema.$ref)\n        ) {\n          const discriminatingSchema =\n            this.resolve<DiscriminatingSchemaObject>(childSchema);\n          const discriminator = discriminatingSchema.discriminator;\n          const matches = Object.entries(discriminator.mapping ?? {})\n            .filter(([, ref]) => ref === schema[\"x-component-ref-path\"])\n            .map(([discriminatorValue]) => discriminatorValue);\n          if (matches.length > 0) {\n            types.push(\n              factory.createTypeLiteralNode([\n                cg.createPropertySignature({\n                  name: discriminator.propertyName,\n                  type: this.getDiscriminatorType(\n                    discriminatingSchema,\n                    discriminator.propertyName,\n                    matches,\n                  ),\n                }),\n              ]),\n            );\n          }\n          types.push(\n            this.getRefAlias(\n              childSchema,\n              onlyMode,\n              /* ignoreDiscriminator */ true,\n            ),\n          );\n        } else {\n          types.push(\n            this.getTypeFromSchema(\n              {\n                required: schema.required,\n                ...childSchema,\n              },\n              undefined,\n              onlyMode,\n            ),\n          );\n        }\n      }\n\n      if (schema.properties || schema.additionalProperties) {\n        // properties -> literal type\n        types.push(\n          this.getTypeFromProperties(\n            schema.properties || {},\n            schema.required,\n            schema.additionalProperties,\n            onlyMode,\n          ),\n        );\n      }\n      return factory.createIntersectionTypeNode(types);\n    }\n    // Union types defined by an array in schema.type\n    if (Array.isArray(schema.type)) {\n      return factory.createUnionTypeNode(\n        schema.type.map((type) => {\n          const subSchema = { ...schema, type } as SchemaObject;\n          // Remove items if the type isn't array since it's not relevant\n          if (\"items\" in subSchema && type !== \"array\") {\n            delete subSchema.items;\n          }\n          if (\"properties\" in subSchema && type !== \"object\") {\n            delete subSchema.properties;\n          }\n\n          return this.getBaseTypeFromSchema(subSchema, name, onlyMode);\n        }),\n      );\n    }\n    if (\"items\" in schema) {\n      const schemaItems = schema.items as OpenAPIV3.BaseSchemaObject;\n\n      // items -> array of enums or unions\n      if (schemaItems.enum) {\n        const enumType = this.isTrueEnum(schemaItems, name)\n          ? this.getTrueEnum(schemaItems, name)\n          : cg.createEnumTypeNode(schemaItems.enum);\n\n        return factory.createArrayTypeNode(enumType);\n      }\n\n      // items -> array\n      return factory.createArrayTypeNode(\n        this.getTypeFromSchema(schema.items, undefined, onlyMode),\n      );\n    }\n    if (\"prefixItems\" in schema && schema.prefixItems) {\n      // prefixItems -> typed tuple\n      return factory.createTupleTypeNode(\n        schema.prefixItems.map((schema) => this.getTypeFromSchema(schema)),\n      );\n    }\n    if (schema.properties || schema.additionalProperties) {\n      // properties -> literal type\n      return this.getTypeFromProperties(\n        schema.properties || {},\n        schema.required,\n        schema.additionalProperties,\n        onlyMode,\n      );\n    }\n    if (schema.enum) {\n      // enum -> enum or union\n      return this.isTrueEnum(schema, name)\n        ? this.getTrueEnum(schema, name)\n        : cg.createEnumTypeNode(schema.enum);\n    }\n    if (schema.format == \"binary\") {\n      return factory.createTypeReferenceNode(\"Blob\", []);\n    }\n    if (schema.const) {\n      return this.getTypeFromEnum([schema.const]);\n    }\n    if (schema.type !== undefined) {\n      if (schema.type === null) return cg.keywordType.null;\n      if (isKeyOfKeywordType(schema.type)) return cg.keywordType[schema.type];\n    }\n\n    return this.getEmptySchemaType();\n  }\n\n  isTrueEnum(schema: SchemaObject, name?: string): name is string {\n    return Boolean(\n      typeof schema !== \"boolean\" &&\n      schema.enum &&\n      this.opts.useEnumType &&\n      name &&\n      schema.type !== \"boolean\",\n    );\n  }\n\n  /**\n   * Get enum member reference type for discriminator values when useEnumType is enabled\n   */\n  getDiscriminatorType(\n    discriminatingSchemaRef:\n      | Exclude<SchemaObject, boolean>\n      | OpenAPIReferenceObject,\n    propertyName: string,\n    matches: string[],\n  ): ts.TypeNode {\n    if (!this.opts.useEnumType) {\n      return this.getTypeFromEnum(matches);\n    }\n\n    const discriminatingSchema = this.resolve(discriminatingSchemaRef);\n    // Get the discriminator property schema to check if it should use enum types\n    // Check the schema's own properties first, then search in allOf parents\n    let discriminatorPropertySchema = this.resolve(\n      discriminatingSchema.properties?.[propertyName],\n    );\n\n    if (!discriminatorPropertySchema && discriminatingSchema.allOf) {\n      // Search in allOf parents\n      for (const allOfSchema of discriminatingSchema.allOf) {\n        const resolvedAllOf = this.resolve(allOfSchema);\n        if (resolvedAllOf.properties?.[propertyName]) {\n          discriminatorPropertySchema = this.resolve(\n            resolvedAllOf.properties[propertyName],\n          );\n          break;\n        }\n      }\n    }\n\n    if (\n      !discriminatorPropertySchema ||\n      !this.isTrueEnum(discriminatorPropertySchema, propertyName)\n    ) {\n      return this.getTypeFromEnum(matches);\n    }\n\n    // Get the enum type reference\n    const enumTypeRef = this.getTrueEnum(\n      discriminatorPropertySchema,\n      propertyName,\n    );\n\n    if (matches.length === 1) {\n      // Single value: return EnumName.MemberName as a type reference\n      const enumMemberName = factory.createIdentifier(\n        toIdentifier(matches[0], true),\n      );\n      const enumName = (enumTypeRef as ts.TypeReferenceNode)\n        .typeName as ts.Identifier;\n      return factory.createTypeReferenceNode(\n        factory.createQualifiedName(enumName, enumMemberName),\n        undefined,\n      );\n    } else {\n      // Multiple matches: return union of EnumName.MemberName1 | EnumName.MemberName2\n      const enumName = (enumTypeRef as ts.TypeReferenceNode)\n        .typeName as ts.Identifier;\n      const memberTypes = matches.map((value) => {\n        const enumMemberName = factory.createIdentifier(\n          toIdentifier(value, true),\n        );\n        return factory.createTypeReferenceNode(\n          factory.createQualifiedName(enumName, enumMemberName),\n          undefined,\n        );\n      });\n\n      return factory.createUnionTypeNode(memberTypes);\n    }\n  }\n\n  /**\n   * Creates literal type (or union) from an array of values\n   */\n  getTypeFromEnum(values: unknown[]) {\n    const types = values.map((s) => {\n      if (s === null) return cg.keywordType.null;\n      if (typeof s === \"boolean\")\n        return s\n          ? factory.createLiteralTypeNode(\n              ts.factory.createToken(ts.SyntaxKind.TrueKeyword),\n            )\n          : factory.createLiteralTypeNode(\n              ts.factory.createToken(ts.SyntaxKind.FalseKeyword),\n            );\n      if (typeof s === \"number\")\n        return factory.createLiteralTypeNode(factory.createNumericLiteral(s));\n      if (typeof s === \"string\")\n        return factory.createLiteralTypeNode(factory.createStringLiteral(s));\n      throw new Error(`Unexpected ${String(s)} of type ${typeof s} in enum`);\n    });\n    return types.length > 1 ? factory.createUnionTypeNode(types) : types[0];\n  }\n\n  getEnumValuesString(values: string[]) {\n    return values.join(\"_\");\n  }\n\n  /*\n    Creates a enum \"ref\" if not used, reuse existing if values and name matches or creates a new one\n    with a new name adding a number\n  */\n  getTrueEnum(schema: SchemaObject, propName: string) {\n    if (typeof schema === \"boolean\") {\n      // this should never be thrown, since the only `getTrueEnum` call is\n      // behind an `isTrueEnum` check, which returns false for boolean schemas.\n      throw new Error(\n        \"cannot get enum from boolean schema. schema must be an object\",\n      );\n    }\n    const baseName = schema.title || _.upperFirst(propName);\n    // TODO: use _.camelCase in future major version\n    // (currently we allow _ and $ for backwards compatibility)\n    const proposedName = baseName\n      .split(/[^A-Za-z0-9$_]/g)\n      .map((n) => _.upperFirst(n))\n      .join(\"\");\n    const stringEnumValue = this.getEnumValuesString(\n      schema.enum ? schema.enum : [],\n    );\n\n    const name = this.getEnumUniqueAlias(proposedName, stringEnumValue);\n\n    if (this.enumRefs[proposedName] && proposedName === name) {\n      return this.enumRefs[proposedName].type;\n    }\n\n    const values = schema.enum ? schema.enum : [];\n\n    const names = schema[\"x-enumNames\"] ?? schema[\"x-enum-varnames\"];\n    if (names) {\n      if (!Array.isArray(names)) {\n        throw new Error(\"enum names must be an array\");\n      }\n      if (names.length !== values.length) {\n        throw new Error(\"enum names must have the same length as enum values\");\n      }\n    }\n\n    const members = values.map((s, index) => {\n      if (\n        schema.type === \"number\" ||\n        schema.type === \"integer\" ||\n        schema.type === \"string\"\n      ) {\n        const name = names ? names[index] : String(s);\n        return factory.createEnumMember(\n          factory.createIdentifier(toIdentifier(name, true)),\n          cg.createLiteral(s),\n        );\n      }\n      return factory.createEnumMember(\n        factory.createIdentifier(toIdentifier(s, true)),\n        cg.createLiteral(s),\n      );\n    });\n    this.enumAliases.push(\n      factory.createEnumDeclaration([cg.modifier.export], name, members),\n    );\n\n    const type = factory.createTypeReferenceNode(name, undefined);\n\n    this.enumRefs[proposedName] = {\n      values: stringEnumValue,\n      type: factory.createTypeReferenceNode(name, undefined),\n    };\n\n    return type;\n  }\n\n  /**\n   * Checks if readOnly/writeOnly properties are present in the given schema.\n   * Returns a tuple of booleans; the first one is about readOnly, the second\n   * one is about writeOnly.\n   */\n  checkSchemaOnlyMode(\n    schema: SchemaObject | OpenAPIReferenceObject,\n    resolveRefs = true,\n  ): OnlyModes {\n    if (this.opts.mergeReadWriteOnly) {\n      return { readOnly: false, writeOnly: false };\n    }\n\n    const check = (\n      schema: SchemaObject | OpenAPIReferenceObject,\n      history: Set<string>,\n    ): OnlyModes => {\n      if (isReference(schema)) {\n        if (!resolveRefs) return { readOnly: false, writeOnly: false };\n\n        // history is used to prevent infinite recursion\n        if (history.has(schema.$ref))\n          return { readOnly: false, writeOnly: false };\n\n        // check if the result is cached in `this.refsOnlyMode`\n        const cached = this.refsOnlyMode.get(schema.$ref);\n        if (cached) return cached;\n\n        history.add(schema.$ref);\n        const ret = check(this.resolve(schema), history);\n        history.delete(schema.$ref);\n\n        // cache the result\n        this.refsOnlyMode.set(schema.$ref, ret);\n\n        return ret;\n      }\n\n      if (typeof schema === \"boolean\") {\n        return { readOnly: false, writeOnly: false };\n      }\n\n      let readOnly = schema.readOnly ?? false;\n      let writeOnly = schema.writeOnly ?? false;\n\n      const subSchemas: (OpenAPIReferenceObject | SchemaObject)[] = [];\n      if (\"items\" in schema && schema.items) {\n        subSchemas.push(schema.items);\n      } else {\n        subSchemas.push(...Object.values(schema.properties ?? {}));\n        subSchemas.push(...(schema.allOf ?? []));\n        subSchemas.push(...(schema.anyOf ?? []));\n        subSchemas.push(...(schema.oneOf ?? []));\n      }\n\n      for (const schema of subSchemas) {\n        // `readOnly` and `writeOnly` do not change once they become true,\n        // so you can exit early if both are true.\n        if (readOnly && writeOnly) break;\n\n        const result = check(schema, history);\n        readOnly = readOnly || result.readOnly;\n        writeOnly = writeOnly || result.writeOnly;\n      }\n\n      return { readOnly, writeOnly };\n    };\n\n    return check(schema, new Set<string>());\n  }\n\n  /**\n   * Recursively creates a type literal with the given props.\n   */\n  getTypeFromProperties(\n    props: {\n      [prop: string]: SchemaObject | OpenAPIReferenceObject;\n    },\n    required?: string[],\n    additionalProperties?:\n      | boolean\n      | OpenAPISchemaObject\n      | OpenAPIReferenceObject,\n    onlyMode?: OnlyMode,\n  ): ts.TypeLiteralNode {\n    // Check if any of the props are readOnly or writeOnly schemas\n    const propertyNames = Object.keys(props);\n    const filteredPropertyNames = propertyNames.filter((name) => {\n      const schema = props[name];\n      const { readOnly, writeOnly } = this.checkSchemaOnlyMode(schema, false);\n\n      switch (onlyMode) {\n        case \"readOnly\":\n          return readOnly || !writeOnly;\n        case \"writeOnly\":\n          return writeOnly || !readOnly;\n        default:\n          return !readOnly && !writeOnly;\n      }\n    });\n\n    const members: ts.TypeElement[] = filteredPropertyNames.map((name) => {\n      const schema = props[name];\n      const isRequired = required && required.includes(name);\n      let type = this.getTypeFromSchema(schema, name, onlyMode);\n      if (!isRequired && this.opts.unionUndefined) {\n        type = factory.createUnionTypeNode([type, cg.keywordType.undefined]);\n      }\n\n      const signature = cg.createPropertySignature({\n        questionToken: !isRequired,\n        name,\n        type,\n      });\n\n      if (\n        typeof schema !== \"boolean\" &&\n        \"description\" in schema &&\n        schema.description\n      ) {\n        // Escape any JSDoc comment closing tags in description\n        const description = schema.description.replace(\"*/\", \"*\\\\/\");\n\n        ts.addSyntheticLeadingComment(\n          signature,\n          ts.SyntaxKind.MultiLineCommentTrivia,\n          // Ensures it is formatted like a JSDoc comment: /** description here */\n          `* ${description} `,\n          true,\n        );\n      }\n\n      return signature;\n    });\n    if (additionalProperties) {\n      const type =\n        additionalProperties === true\n          ? this.getEmptySchemaType()\n          : this.getTypeFromSchema(additionalProperties, undefined, onlyMode);\n\n      members.push(cg.createIndexSignature(type));\n    }\n    return factory.createTypeLiteralNode(members);\n  }\n\n  getTypeFromResponses(responses: OpenAPIResponsesObject, onlyMode?: OnlyMode) {\n    return factory.createUnionTypeNode(\n      Object.entries(responses).map(([code, res]) => {\n        const statusType =\n          code === \"default\"\n            ? cg.keywordType.number\n            : factory.createLiteralTypeNode(factory.createNumericLiteral(code));\n\n        const props = [\n          cg.createPropertySignature({\n            name: \"status\",\n            type: statusType,\n          }),\n        ];\n\n        const dataType = this.getTypeFromResponse(res, onlyMode);\n        if (dataType !== cg.keywordType.void) {\n          props.push(\n            cg.createPropertySignature({\n              name: \"data\",\n              type: dataType,\n            }),\n          );\n        }\n        return factory.createTypeLiteralNode(props);\n      }),\n    );\n  }\n\n  getTypeFromResponse(\n    resOrRef: OpenAPIResponseObject | OpenAPIReferenceObject,\n    onlyMode?: OnlyMode,\n  ) {\n    const res = this.resolve(resOrRef);\n    if (!res || !res.content) return cg.keywordType.void;\n    return this.getTypeFromSchema(\n      this.getSchemaFromContent(res.content),\n      undefined,\n      onlyMode,\n    );\n  }\n\n  getResponseType(\n    responses?: OpenAPIResponsesObject,\n  ): \"json\" | \"text\" | \"blob\" {\n    // backwards-compatibility\n    if (!responses) return \"text\";\n\n    const resolvedResponses = Object.values(responses).map((response) =>\n      this.resolve(response),\n    );\n\n    // if no content is specified, assume `text` (backwards-compatibility)\n    if (\n      !resolvedResponses.some(\n        (res) => Object.keys(res.content ?? {}).length > 0,\n      )\n    ) {\n      return \"text\";\n    }\n\n    const isJson = resolvedResponses.some((response) => {\n      const responseMimeTypes = Object.keys(response.content ?? {});\n      return responseMimeTypes.some(isJsonMimeType);\n    });\n\n    // if there’s `application/json` or `*/*`, assume `json`\n    if (isJson) {\n      return \"json\";\n    }\n\n    // if there’s `text/*`, assume `text`\n    if (\n      resolvedResponses.some((res) =>\n        Object.keys(res.content ?? []).some((type) => type.startsWith(\"text/\")),\n      )\n    ) {\n      return \"text\";\n    }\n\n    // for the rest, assume `blob`\n    return \"blob\";\n  }\n\n  getSchemaFromContent(\n    content: Record<string, OpenAPIMediaTypeObject>,\n  ): OpenAPISchemaObject | OpenAPIReferenceObject {\n    const contentType = Object.keys(content).find(isMimeType);\n    if (contentType) {\n      const { schema } = content[contentType];\n      if (schema) {\n        return schema;\n      }\n    }\n\n    // if no content is specified -> string\n    // `text/*` -> string\n    if (\n      Object.keys(content).length === 0 ||\n      Object.keys(content).some((type) => type.startsWith(\"text/\"))\n    ) {\n      return { type: \"string\" };\n    }\n\n    // rest (e.g. `application/octet-stream`, `application/gzip`, …) -> binary\n    return { type: \"string\", format: \"binary\" };\n  }\n\n  getTypeFromParameter(p: OpenAPIParameterObject) {\n    if (p.content) {\n      const schema = this.getSchemaFromContent(p.content);\n      return this.getTypeFromSchema(schema);\n    }\n    return this.getTypeFromSchema(isReference(p) ? p : p.schema);\n  }\n\n  wrapResult(ex: ts.Expression) {\n    return this.opts?.optimistic ? callOazapftsFunction(\"ok\", [ex]) : ex;\n  }\n\n  /**\n   * Does three things:\n   * 1. Add a `x-component-ref-path` property.\n   * 2. Record discriminating schemas in `this.discriminatingSchemas`. A discriminating schema\n   *    refers to a schema that has a `discriminator` property which is neither used in conjunction\n   *    with `oneOf` nor `anyOf`.\n   * 3. Make all mappings of discriminating schemas explicit to generate types immediately.\n   */\n  preprocessComponents(schemas: {\n    [key: string]: OpenAPIReferenceObject | SchemaObject;\n  }) {\n    const prefix = \"#/components/schemas/\";\n\n    // First scan: Add `x-component-ref-path` property and record discriminating schemas\n    for (const name of Object.keys(schemas)) {\n      const schema = schemas[name];\n      if (isReference(schema) || typeof schema === \"boolean\") continue;\n\n      schema[\"x-component-ref-path\"] = prefix + name;\n\n      if (\n        typeof schema !== \"boolean\" &&\n        schema.discriminator &&\n        !schema.oneOf &&\n        !schema.anyOf\n      ) {\n        this.discriminatingSchemas.add(prefix + name);\n      }\n    }\n\n    const isExplicit = (\n      discriminator: OpenAPIDiscriminatorObject,\n      ref: string,\n    ) => {\n      const refs = Object.values(discriminator.mapping || {});\n      return refs.includes(ref);\n    };\n\n    // Second scan: Make all mappings of discriminating schemas explicit\n    for (const name of Object.keys(schemas)) {\n      const schema = schemas[name];\n\n      if (isReference(schema) || typeof schema === \"boolean\" || !schema.allOf) {\n        continue;\n      }\n\n      for (const childSchema of schema.allOf) {\n        if (\n          !isReference(childSchema) ||\n          !this.discriminatingSchemas.has(childSchema.$ref)\n        ) {\n          continue;\n        }\n\n        const discriminatingSchema = schemas[\n          getRefBasename(childSchema.$ref)\n        ] as DiscriminatingSchemaObject;\n        const discriminator = discriminatingSchema.discriminator!;\n\n        if (isExplicit(discriminator, prefix + name)) continue;\n        if (!discriminator.mapping) {\n          discriminator.mapping = {};\n        }\n        discriminator.mapping[name] = prefix + name;\n      }\n    }\n  }\n\n  generateApi() {\n    this.reset();\n\n    // Parse ApiStub.ts so that we don't have to generate everything manually\n    const stub = ts.createSourceFile(\n      \"ApiStub.ts\",\n      __API_STUB_PLACEHOLDER__, // replaced with ApiStub.ts during build\n      ts.ScriptTarget.Latest,\n      /*setParentNodes*/ false,\n      ts.ScriptKind.TS,\n    );\n\n    // ApiStub contains `const servers = {}`, find it ...\n    const servers = cg.findFirstVariableDeclaration(stub.statements, \"servers\");\n    // servers.initializer is readonly, this might break in a future TS version, but works fine for now.\n    Object.assign(servers, {\n      initializer: generateServers(this.spec.servers || []),\n    });\n\n    const { initializer } = cg.findFirstVariableDeclaration(\n      stub.statements,\n      \"defaults\",\n    );\n    if (!initializer || !ts.isObjectLiteralExpression(initializer)) {\n      throw new Error(\"No object literal: defaults\");\n    }\n\n    cg.changePropertyValue(\n      initializer,\n      \"baseUrl\",\n      defaultBaseUrl(this.spec.servers || []),\n    );\n\n    // Collect class functions to be added...\n    const functions: ts.FunctionDeclaration[] = [];\n\n    // Keep track of names to detect duplicates\n    const names: Record<string, number> = {};\n\n    if (this.spec.paths) {\n      Object.keys(this.spec.paths).forEach((path) => {\n        if (!this.spec.paths) return;\n\n        const item = this.spec.paths[path];\n\n        if (!item) {\n          return;\n        }\n\n        Object.keys(this.resolve(item)).forEach((verb) => {\n          const method = verb.toUpperCase();\n          // skip summary/description/parameters etc...\n          if (!verbs.includes(method)) return;\n\n          const op: OpenAPIOperationObject = (item as any)[verb];\n          const {\n            operationId,\n            requestBody,\n            responses,\n            summary,\n            description,\n            tags,\n          } = op;\n\n          if (this.skip(tags)) {\n            return;\n          }\n\n          let name = getOperationName(verb, path, operationId);\n          const count = (names[name] = (names[name] || 0) + 1);\n          if (count > 1) {\n            // The name is already taken, which means that the spec is probably\n            // invalid as operationIds must be unique. Since this is quite common\n            // nevertheless we append a counter:\n            name += count;\n          }\n\n          // merge item and op parameters\n          const resolvedParameters = this.resolveArray(item.parameters);\n          for (const p of this.resolveArray(op.parameters)) {\n            const existing = resolvedParameters.find(\n              (r) => r.name === p.name && r.in === p.in,\n            );\n            if (!existing) {\n              resolvedParameters.push(p);\n            }\n          }\n\n          // expand older OpenAPI parameters into deepObject style where needed\n          const parameters = this.isConverted\n            ? supportDeepObjects(resolvedParameters)\n            : resolvedParameters;\n\n          // convert parameter names to argument names ...\n          const argNames = new Map<OpenAPIParameterObject, string>();\n          _.sortBy(parameters, \"name.length\").forEach((p) => {\n            const identifier = toIdentifier(p.name);\n            const existing = [...argNames.values()];\n            const suffix = existing.includes(identifier)\n              ? _.upperFirst(p.in)\n              : \"\";\n            argNames.set(p, identifier + suffix);\n          });\n\n          const getArgName = (param: OpenAPIParameterObject) => {\n            const name = argNames.get(param);\n            if (!name) throw new Error(`Can't find parameter: ${param.name}`);\n            return name;\n          };\n\n          const methodParams: ts.ParameterDeclaration[] = [];\n          let body: OpenAPIRequestBodyObject | undefined = undefined;\n          let bodyVar: string | undefined = undefined;\n          switch (this.opts.argumentStyle ?? \"positional\") {\n            case \"positional\":\n              // split into required/optional\n              const [required, optional] = _.partition(parameters, \"required\");\n\n              // build the method signature - first all the required parameters\n              const requiredParams = required.map((p) =>\n                cg.createParameter(getArgName(this.resolve(p)), {\n                  type: this.getTypeFromParameter(p),\n                }),\n              );\n              methodParams.push(...requiredParams);\n\n              // add body if present\n              if (requestBody) {\n                body = this.resolve(requestBody);\n                const schema = this.getSchemaFromContent(body.content);\n                const type = this.getTypeFromSchema(\n                  schema,\n                  undefined,\n                  \"writeOnly\",\n                );\n                bodyVar = toIdentifier(\n                  (type as any).name || getReferenceName(schema) || \"body\",\n                );\n                methodParams.push(\n                  cg.createParameter(bodyVar, {\n                    type,\n                    questionToken: !body.required,\n                  }),\n                );\n              }\n\n              // add an object with all optional parameters\n              if (optional.length) {\n                methodParams.push(\n                  cg.createParameter(\n                    cg.createObjectBinding(\n                      optional\n                        .map((param) => this.resolve(param))\n                        .map((param) => ({ name: getArgName(param) })),\n                    ),\n                    {\n                      initializer: factory.createObjectLiteralExpression(),\n                      type: factory.createTypeLiteralNode(\n                        optional.map((p) =>\n                          cg.createPropertySignature({\n                            name: getArgName(this.resolve(p)),\n                            questionToken: true,\n                            type: this.getTypeFromParameter(p),\n                          }),\n                        ),\n                      ),\n                    },\n                  ),\n                );\n              }\n              break;\n\n            case \"object\":\n              // build the method signature - first all the required/optional parameters\n              const paramMembers = parameters.map((p) =>\n                cg.createPropertySignature({\n                  name: getArgName(this.resolve(p)),\n                  questionToken: !p.required,\n                  type: this.getTypeFromParameter(p),\n                }),\n              );\n\n              // add body if present\n              if (requestBody) {\n                body = this.resolve(requestBody);\n                const schema = this.getSchemaFromContent(body.content);\n                const type = this.getTypeFromSchema(\n                  schema,\n                  undefined,\n                  \"writeOnly\",\n                );\n                bodyVar = toIdentifier(\n                  (type as any).name || getReferenceName(schema) || \"body\",\n                );\n                paramMembers.push(\n                  cg.createPropertySignature({\n                    name: bodyVar,\n                    questionToken: !body.required,\n                    type,\n                  }),\n                );\n              }\n\n              // if there's no params, leave methodParams as is and prevent empty object argument generation\n              if (paramMembers.length === 0) {\n                break;\n              }\n\n              methodParams.push(\n                cg.createParameter(\n                  cg.createObjectBinding([\n                    ...parameters\n                      .map((param) => this.resolve(param))\n                      .map((param) => ({ name: getArgName(param) })),\n                    ...(bodyVar ? [{ name: bodyVar }] : []),\n                  ]),\n                  {\n                    type: factory.createTypeLiteralNode(paramMembers),\n                  },\n                ),\n              );\n              break;\n          }\n\n          // add oazapfts options\n          methodParams.push(\n            cg.createParameter(\"opts\", {\n              type: factory.createTypeReferenceNode(\n                \"Oazapfts.RequestOpts\",\n                undefined,\n              ),\n              questionToken: true,\n            }),\n          );\n\n          // Next, build the method body...\n\n          const returnType = this.getResponseType(responses);\n          const query = parameters.filter((p) => p.in === \"query\");\n          const header = parameters.filter((p) => p.in === \"header\");\n\n          let qs;\n          if (query.length) {\n            const paramsByFormatter = _.groupBy(query, getFormatter);\n            qs = callQsFunction(\n              \"query\",\n              Object.entries(paramsByFormatter).map(([format, params]) => {\n                //const [allowReserved, encodeReserved] = _.partition(params, \"allowReserved\");\n                return callQsFunction(format, [\n                  cg.createObjectLiteral(\n                    params.map((p) => [p.name, getArgName(p)]),\n                  ),\n                ]);\n              }),\n            );\n          }\n\n          const url = createUrlExpression(path, qs);\n          const init: ts.ObjectLiteralElementLike[] = [\n            factory.createSpreadAssignment(factory.createIdentifier(\"opts\")),\n          ];\n\n          if (method !== \"GET\") {\n            init.push(\n              factory.createPropertyAssignment(\n                \"method\",\n                factory.createStringLiteral(method),\n              ),\n            );\n          }\n\n          if (bodyVar) {\n            init.push(\n              cg.createPropertyAssignment(\n                \"body\",\n                factory.createIdentifier(bodyVar),\n              ),\n            );\n          }\n\n          if (header.length) {\n            init.push(\n              factory.createPropertyAssignment(\n                \"headers\",\n                callOazapftsFunction(\"mergeHeaders\", [\n                  factory.createPropertyAccessChain(\n                    factory.createIdentifier(\"opts\"),\n                    factory.createToken(ts.SyntaxKind.QuestionDotToken),\n                    \"headers\",\n                  ),\n                  factory.createObjectLiteralExpression(\n                    [\n                      ...header.map((param) =>\n                        cg.createPropertyAssignment(\n                          param.name,\n                          factory.createIdentifier(getArgName(param)),\n                        ),\n                      ),\n                    ],\n                    true,\n                  ),\n                ]),\n              ),\n            );\n          }\n\n          const args: ts.Expression[] = [url];\n\n          if (init.length) {\n            const formatter = getBodyFormatter(body); // json, form, multipart\n            const initObj = factory.createObjectLiteralExpression(init, true);\n            args.push(\n              formatter ? callOazapftsFunction(formatter, [initObj]) : initObj,\n            );\n          }\n\n          functions.push(\n            cg.addComment(\n              cg.createFunctionDeclaration(\n                name,\n                {\n                  modifiers: [cg.modifier.export],\n                },\n                methodParams,\n                cg.block(\n                  factory.createReturnStatement(\n                    this.wrapResult(\n                      callOazapftsFunction(\n                        {\n                          json: \"fetchJson\",\n                          text: \"fetchText\",\n                          blob: \"fetchBlob\",\n                        }[returnType],\n                        args,\n                        returnType === \"json\" || returnType === \"blob\"\n                          ? [\n                              this.getTypeFromResponses(\n                                responses!,\n                                \"readOnly\",\n                              ) || ts.SyntaxKind.AnyKeyword,\n                            ]\n                          : undefined,\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n              summary || description,\n            ),\n          );\n        });\n      });\n    }\n\n    Object.assign(stub, {\n      statements: cg.appendNodes(\n        stub.statements,\n        ...[...this.aliases, ...functions],\n        ...this.enumAliases,\n      ),\n    });\n\n    return stub;\n  }\n}\n","import ts from \"typescript\";\nimport { toIdentifier } from \"./generate\";\n\nconst factory = ts.factory;\n\nexport const questionToken = factory.createToken(ts.SyntaxKind.QuestionToken);\n\nexport function createQuestionToken(token?: boolean | ts.QuestionToken) {\n  if (!token) return undefined;\n  if (token === true) return questionToken;\n  return token;\n}\n\nexport const keywordType = {\n  any: factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n  number: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),\n  integer: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),\n  object: factory.createKeywordTypeNode(ts.SyntaxKind.ObjectKeyword),\n  string: factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n  boolean: factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword),\n  undefined: factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword),\n  void: factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword),\n  never: factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword),\n  null: factory.createLiteralTypeNode(factory.createNull()),\n  unknown: factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),\n};\n\ntype KeywordTypeName = keyof typeof keywordType;\n\nexport function createKeywordType(type: KeywordTypeName) {\n  return keywordType[type];\n}\n\nexport const modifier = {\n  async: factory.createModifier(ts.SyntaxKind.AsyncKeyword),\n  export: factory.createModifier(ts.SyntaxKind.ExportKeyword),\n};\n\nexport function createLiteral(v: string | boolean | number) {\n  switch (typeof v) {\n    case \"string\":\n      return factory.createStringLiteral(v);\n    case \"boolean\":\n      return v ? factory.createTrue() : factory.createFalse();\n    case \"number\":\n      return String(v).charAt(0) === \"-\"\n        ? factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            factory.createNumericLiteral(String(-v)),\n          )\n        : factory.createNumericLiteral(String(v));\n  }\n}\n\nexport function createEnumTypeNode(values: Array<string | boolean | number>) {\n  const types = values.map((v) =>\n    v === null\n      ? keywordType.null\n      : factory.createLiteralTypeNode(createLiteral(v)),\n  );\n  return types.length > 1 ? factory.createUnionTypeNode(types) : types[0];\n}\n\nexport function createTypeAliasDeclaration({\n  modifiers,\n  name,\n  typeParameters,\n  type,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  name: string | ts.Identifier;\n  typeParameters?: Array<ts.TypeParameterDeclaration>;\n  type: ts.TypeNode;\n}) {\n  return factory.createTypeAliasDeclaration(\n    modifiers,\n    name,\n    typeParameters,\n    type,\n  );\n}\n\nexport function createInterfaceAliasDeclaration({\n  modifiers,\n  name,\n  typeParameters,\n  type,\n  inheritedNodeNames,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  name: string | ts.Identifier;\n  typeParameters?: Array<ts.TypeParameterDeclaration>;\n  type: ts.TypeNode;\n  inheritedNodeNames?: (string | ts.Identifier)[];\n}) {\n  const heritageClauses = inheritedNodeNames\n    ? [\n        factory.createHeritageClause(\n          ts.SyntaxKind.ExtendsKeyword,\n          inheritedNodeNames.map((name) => {\n            const extendedInterfaceName =\n              typeof name === \"string\" ? name : name.escapedText.toString();\n            return factory.createExpressionWithTypeArguments(\n              factory.createIdentifier(\n                toIdentifier(extendedInterfaceName, true),\n              ),\n              undefined,\n            );\n          }),\n        ),\n      ]\n    : [];\n  return factory.createInterfaceDeclaration(\n    modifiers,\n    name,\n    typeParameters,\n    heritageClauses,\n    (type as ts.TypeLiteralNode).members,\n  );\n}\n\nexport function toExpression(ex: ts.Expression | string) {\n  if (typeof ex === \"string\") return factory.createIdentifier(ex);\n  return ex;\n}\n\nexport function createCall(\n  expression: ts.Expression | string,\n  {\n    typeArgs,\n    args,\n  }: {\n    typeArgs?: Array<ts.TypeNode>;\n    args?: Array<ts.Expression>;\n  } = {},\n) {\n  return factory.createCallExpression(toExpression(expression), typeArgs, args);\n}\n\nexport function createMethodCall(\n  method: string,\n  opts: {\n    typeArgs?: Array<ts.TypeNode>;\n    args?: Array<ts.Expression>;\n  },\n) {\n  return createCall(\n    factory.createPropertyAccessExpression(factory.createThis(), method),\n    opts,\n  );\n}\n\nexport function createObjectLiteral(props: [string, string | ts.Expression][]) {\n  return factory.createObjectLiteralExpression(\n    props.map(([name, identifier]) =>\n      createPropertyAssignment(name, toExpression(identifier)),\n    ),\n    true,\n  );\n}\n\nexport function createPropertyAssignment(\n  name: string,\n  expression: ts.Expression,\n) {\n  if (ts.isIdentifier(expression)) {\n    if (expression.text === name) {\n      return factory.createShorthandPropertyAssignment(name);\n    }\n  }\n  return factory.createPropertyAssignment(propertyName(name), expression);\n}\n\nexport function block(...statements: ts.Statement[]) {\n  return factory.createBlock(statements, true);\n}\n\nexport function createArrowFunction(\n  parameters: ts.ParameterDeclaration[],\n  body: ts.ConciseBody,\n  {\n    modifiers,\n    typeParameters,\n    type,\n    equalsGreaterThanToken,\n  }: {\n    modifiers?: ts.Modifier[];\n    typeParameters?: ts.TypeParameterDeclaration[];\n    type?: ts.TypeNode;\n    equalsGreaterThanToken?: ts.EqualsGreaterThanToken;\n  } = {},\n) {\n  return factory.createArrowFunction(\n    modifiers,\n    typeParameters,\n    parameters,\n    type,\n    equalsGreaterThanToken,\n    body,\n  );\n}\n\nexport function createFunctionDeclaration(\n  name: string | ts.Identifier | undefined,\n  {\n    modifiers,\n    asteriskToken,\n    typeParameters,\n    type,\n  }: {\n    modifiers?: ts.Modifier[];\n    asteriskToken?: ts.AsteriskToken;\n    typeParameters?: ts.TypeParameterDeclaration[];\n    type?: ts.TypeNode;\n  },\n  parameters: ts.ParameterDeclaration[],\n  body?: ts.Block,\n): ts.FunctionDeclaration {\n  return factory.createFunctionDeclaration(\n    modifiers,\n    asteriskToken,\n    name,\n    typeParameters,\n    parameters,\n    type,\n    body,\n  );\n}\n\nexport function createClassDeclaration({\n  modifiers,\n  name,\n  typeParameters,\n  heritageClauses,\n  members,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  name?: string | ts.Identifier;\n  typeParameters?: Array<ts.TypeParameterDeclaration>;\n  heritageClauses?: Array<ts.HeritageClause>;\n  members: Array<ts.ClassElement>;\n}) {\n  return factory.createClassDeclaration(\n    modifiers,\n    name,\n    typeParameters,\n    heritageClauses,\n    members,\n  );\n}\n\nexport function createConstructor({\n  modifiers,\n  parameters,\n  body,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  parameters: Array<ts.ParameterDeclaration>;\n  body?: ts.Block;\n}) {\n  return factory.createConstructorDeclaration(modifiers, parameters, body);\n}\n\nexport function createMethod(\n  name:\n    | string\n    | ts.Identifier\n    | ts.StringLiteral\n    | ts.NumericLiteral\n    | ts.ComputedPropertyName,\n  {\n    modifiers,\n    asteriskToken,\n    questionToken,\n    typeParameters,\n    type,\n  }: {\n    modifiers?: ts.Modifier[];\n    asteriskToken?: ts.AsteriskToken;\n    questionToken?: ts.QuestionToken | boolean;\n    typeParameters?: ts.TypeParameterDeclaration[];\n    type?: ts.TypeNode;\n  } = {},\n  parameters: ts.ParameterDeclaration[] = [],\n  body?: ts.Block,\n): ts.MethodDeclaration {\n  return factory.createMethodDeclaration(\n    modifiers,\n    asteriskToken,\n    name,\n    createQuestionToken(questionToken),\n    typeParameters,\n    parameters,\n    type,\n    body,\n  );\n}\n\nexport function createParameter(\n  name: string | ts.BindingName,\n  {\n    modifiers,\n    dotDotDotToken,\n    questionToken,\n    type,\n    initializer,\n  }: {\n    modifiers?: Array<ts.Modifier>;\n    dotDotDotToken?: ts.DotDotDotToken;\n    questionToken?: ts.QuestionToken | boolean;\n    type?: ts.TypeNode;\n    initializer?: ts.Expression;\n  },\n): ts.ParameterDeclaration {\n  return factory.createParameterDeclaration(\n    modifiers,\n    dotDotDotToken,\n    name,\n    createQuestionToken(questionToken),\n    type,\n    initializer,\n  );\n}\n\nfunction propertyName(name: string | ts.PropertyName): ts.PropertyName {\n  if (typeof name === \"string\") {\n    return isValidIdentifier(name)\n      ? factory.createIdentifier(name)\n      : factory.createStringLiteral(name);\n  }\n  return name;\n}\n\nexport function createPropertySignature({\n  modifiers,\n  name,\n  questionToken,\n  type,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  name: ts.PropertyName | string;\n  questionToken?: ts.QuestionToken | boolean;\n  type?: ts.TypeNode;\n}) {\n  return factory.createPropertySignature(\n    modifiers,\n    propertyName(name),\n    createQuestionToken(questionToken),\n    type,\n  );\n}\n\nexport function createIndexSignature(\n  type: ts.TypeNode,\n  {\n    modifiers,\n    indexName = \"key\",\n    indexType = keywordType.string,\n  }: {\n    indexName?: string;\n    indexType?: ts.TypeNode;\n    modifiers?: Array<ts.Modifier>;\n  } = {},\n) {\n  return factory.createIndexSignature(\n    modifiers,\n    [createParameter(indexName, { type: indexType })],\n    type,\n  );\n}\n\nexport function createObjectBinding(\n  elements: Array<{\n    name: string | ts.BindingName;\n    dotDotDotToken?: ts.DotDotDotToken;\n    propertyName?: string | ts.PropertyName;\n    initializer?: ts.Expression;\n  }>,\n) {\n  return factory.createObjectBindingPattern(\n    elements.map(({ dotDotDotToken, propertyName, name, initializer }) =>\n      factory.createBindingElement(\n        dotDotDotToken,\n        propertyName,\n        name,\n        initializer,\n      ),\n    ),\n  );\n}\n\nexport function createTemplateString(\n  head: string,\n  spans: Array<{ literal: string; expression: ts.Expression }>,\n) {\n  if (!spans.length) return factory.createStringLiteral(head);\n  return factory.createTemplateExpression(\n    factory.createTemplateHead(head),\n    spans.map(({ expression, literal }, i) =>\n      factory.createTemplateSpan(\n        expression,\n        i === spans.length - 1\n          ? factory.createTemplateTail(literal)\n          : factory.createTemplateMiddle(literal),\n      ),\n    ),\n  );\n}\n\nexport function findNode<T extends ts.Node>(\n  nodes: ts.NodeArray<ts.Node>,\n  kind: T extends { kind: infer K } ? K : never,\n  test?: (node: T) => boolean | undefined,\n): T {\n  const node = nodes.find(\n    (s) => s.kind === kind && (!test || test(s as T)),\n  ) as T;\n  if (!node) throw new Error(`Node not found: ${kind}`);\n  return node;\n}\n\nexport function getName(name: ts.Node) {\n  if (ts.isIdentifier(name)) {\n    return name.escapedText;\n  }\n  if (ts.isLiteralExpression(name)) {\n    return name.text;\n  }\n  return \"\";\n}\n\nexport function getFirstDeclarationName(n: ts.VariableStatement) {\n  const name = ts.getNameOfDeclaration(n.declarationList.declarations[0]);\n  return name ? getName(name) : \"\";\n}\n\nexport function findFirstVariableDeclaration(\n  nodes: ts.NodeArray<ts.Node>,\n  name: string,\n) {\n  const statement = findNode<ts.VariableStatement>(\n    nodes,\n    ts.SyntaxKind.VariableStatement,\n    (n) => getFirstDeclarationName(n) === name,\n  );\n  const [first] = statement.declarationList.declarations;\n  if (!first) throw new Error(\"Missing declaration\");\n  return first;\n}\n\nexport function changePropertyValue(\n  o: ts.ObjectLiteralExpression,\n  property: string,\n  value: ts.Expression,\n) {\n  const p = o.properties.find(\n    (p) => ts.isPropertyAssignment(p) && getName(p.name) === property,\n  );\n  if (p && ts.isPropertyAssignment(p)) {\n    // p.initializer is readonly, this might break in a future TS version, but works fine for now.\n    Object.assign(p, { initializer: value });\n  } else {\n    throw new Error(`No such property: ${property}`);\n  }\n}\n\nexport function appendNodes<T extends ts.Node>(\n  array: ts.NodeArray<T>,\n  ...nodes: T[]\n) {\n  return factory.createNodeArray([...array, ...nodes]);\n}\n\nexport function addComment<T extends ts.Node>(node: T, comment?: string) {\n  if (!comment) return node;\n  return ts.addSyntheticLeadingComment(\n    node,\n    ts.SyntaxKind.MultiLineCommentTrivia,\n    `*\\n * ${comment.replace(/\\n/g, \"\\n * \")}\\n `,\n    true,\n  );\n}\n\nconst printer = ts.createPrinter({\n  newLine: ts.NewLineKind.LineFeed,\n});\n\nexport function printNode(node: ts.Node) {\n  const file = ts.createSourceFile(\n    \"someFileName.ts\",\n    \"\",\n    ts.ScriptTarget.Latest,\n    /*setParentNodes*/ false,\n    ts.ScriptKind.TS,\n  );\n  return printer.printNode(ts.EmitHint.Unspecified, node, file);\n}\n\nexport function printNodes(nodes: ts.Node[]) {\n  const file = ts.createSourceFile(\n    \"someFileName.ts\",\n    \"\",\n    ts.ScriptTarget.Latest,\n    /*setParentNodes*/ false,\n    ts.ScriptKind.TS,\n  );\n  return nodes\n    .map((node) => printer.printNode(ts.EmitHint.Unspecified, node, file))\n    .join(\"\\n\");\n}\n\nexport function printFile(sourceFile: ts.SourceFile) {\n  return printer.printFile(sourceFile);\n}\n\nexport function isValidIdentifier(str: string) {\n  if (!str.length || str.trim() !== str) return false;\n  const node = ts.parseIsolatedEntityName(str, ts.ScriptTarget.Latest);\n  return (\n    !!node &&\n    node.kind === ts.SyntaxKind.Identifier &&\n    ts.identifierToKeywordKind(node) === undefined\n  );\n}\n"],"names":["factory","ts","createTemplate","url","tokens","chunks","_","cg.createTemplateString","expression","literal","createServerFunction","template","vars","params","cg.createParameter","cg.createObjectBinding","name","value","cg.createLiteral","cg.createPropertySignature","cg.createEnumTypeNode","cg.keywordType","cg.createArrowFunction","generateServerExpression","server","defaultUrl","variables","m","defaultBaseUrl","servers","serverName","index","generateServers","cg.createObjectLiteral","i","verbs","contentTypes","isMimeType","s","isJsonMimeType","mime","getBodyFormatter","body","contentType","formatter","getFormatter","style","explode","content","medias","getOperationIdentifier","id","cg.isValidIdentifier","getOperationName","verb","path","operationId","toIdentifier","isNullable","schema","isReference","obj","refPathToPropertyPath","ref","getRefBasename","getRefName","base","getReferenceName","onlyModeSuffixes","getOnlyModeSuffix","onlyMode","upperFirst","cc","createUrlExpression","qs","spans","head","_substr","cg.createCall","callQsFunction","args","callOazapftsFunction","typeArgs","supportDeepObjects","res","merged","p","prop","isKeyOfKeywordType","key","ApiGenerator","spec","opts","isConverted","resolved","array","el","tags","t","available","used","values","ignoreDiscriminator","$ref","identifier","alias","type","cg.createTypeAliasDeclaration","cg.modifier","readOnly","writeOnly","readOnlyAlias","readOnlyType","writeOnlyAlias","writeOnlyType","variants","discriminator","mappedValues","discriminatorValue","variantRef","variant","schemaBaseName","discriminatorProperty","clone","objValue","srcValue","mapping","types","childSchema","discriminatingSchema","matches","subSchema","schemaItems","enumType","discriminatingSchemaRef","propertyName","discriminatorPropertySchema","allOfSchema","resolvedAllOf","enumTypeRef","enumMemberName","enumName","memberTypes","propName","proposedName","n","stringEnumValue","names","members","resolveRefs","check","history","cached","ret","subSchemas","result","props","required","additionalProperties","isRequired","signature","description","cg.createIndexSignature","responses","code","statusType","dataType","resOrRef","resolvedResponses","response","ex","schemas","prefix","isExplicit","stub","cg.findFirstVariableDeclaration","initializer","cg.changePropertyValue","functions","item","method","op","requestBody","summary","count","resolvedParameters","r","parameters","argNames","suffix","getArgName","param","methodParams","bodyVar","optional","requiredParams","paramMembers","returnType","query","header","paramsByFormatter","format","init","cg.createPropertyAssignment","initObj","cg.addComment","cg.createFunctionDeclaration","cg.block","cg.appendNodes","questionToken","createQuestionToken","token","keywordType","createKeywordType","modifier","createLiteral","v","createEnumTypeNode","createTypeAliasDeclaration","modifiers","typeParameters","createInterfaceAliasDeclaration","inheritedNodeNames","heritageClauses","extendedInterfaceName","toExpression","createCall","createMethodCall","createObjectLiteral","createPropertyAssignment","block","statements","createArrowFunction","equalsGreaterThanToken","createFunctionDeclaration","asteriskToken","createClassDeclaration","createConstructor","createMethod","createParameter","dotDotDotToken","isValidIdentifier","createPropertySignature","createIndexSignature","indexName","indexType","createObjectBinding","elements","createTemplateString","findNode","nodes","kind","test","node","getName","getFirstDeclarationName","findFirstVariableDeclaration","statement","first","changePropertyValue","o","property","appendNodes","addComment","comment","printer","printNode","file","printNodes","printFile","sourceFile","str"],"mappings":"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"}