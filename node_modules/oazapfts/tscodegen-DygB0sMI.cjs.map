{"version":3,"file":"tscodegen-DygB0sMI.cjs","sources":["../src/generateServers.ts","../src/generate.ts","../src/tscodegen.ts"],"sourcesContent":["import _ from \"lodash\";\nimport * as cg from \"./tscodegen\";\nimport ts from \"typescript\";\nimport { OpenAPIV3 } from \"openapi-types\";\n\nconst factory = ts.factory;\n\nfunction createTemplate(url: string) {\n  const tokens = url.split(/{([\\s\\S]+?)}/g);\n  const chunks = _.chunk(tokens.slice(1), 2);\n  return cg.createTemplateString(\n    tokens[0],\n    chunks.map(([expression, literal]) => ({\n      expression: factory.createIdentifier(expression),\n      literal,\n    })),\n  );\n}\n\nfunction createServerFunction(\n  template: string,\n  vars: Record<string, OpenAPIV3.ServerVariableObject>,\n) {\n  const params = [\n    cg.createParameter(\n      cg.createObjectBinding(\n        Object.entries(vars || {}).map(([name, value]) => {\n          return {\n            name,\n            initializer: cg.createLiteral(value.default),\n          };\n        }),\n      ),\n      {\n        type: factory.createTypeLiteralNode(\n          Object.entries(vars || {}).map(([name, value]) => {\n            return cg.createPropertySignature({\n              name,\n              type: value.enum\n                ? cg.createEnumTypeNode(value.enum)\n                : factory.createUnionTypeNode([\n                    cg.keywordType.string,\n                    cg.keywordType.number,\n                    cg.keywordType.boolean,\n                  ]),\n            });\n          }),\n        ),\n      },\n    ),\n  ];\n\n  return cg.createArrowFunction(params, createTemplate(template));\n}\n\nfunction generateServerExpression(server: OpenAPIV3.ServerObject) {\n  return server.variables\n    ? createServerFunction(server.url, server.variables)\n    : factory.createStringLiteral(server.url);\n}\n\nfunction defaultUrl(server?: OpenAPIV3.ServerObject) {\n  if (!server) return \"/\";\n  const { url, variables } = server;\n  if (!variables) return url;\n  return url.replace(/\\{(.+?)\\}/g, (m, name) =>\n    variables[name] ? String(variables[name].default) : m,\n  );\n}\n\nexport function defaultBaseUrl(servers: OpenAPIV3.ServerObject[]) {\n  return factory.createStringLiteral(defaultUrl(servers[0]));\n}\n\nfunction serverName(server: OpenAPIV3.ServerObject, index: number) {\n  return server.description\n    ? _.camelCase(server.description.replace(/\\W+/, \" \"))\n    : `server${index + 1}`;\n}\n\nexport default function generateServers(\n  servers: OpenAPIV3.ServerObject[],\n): ts.ObjectLiteralExpression {\n  return cg.createObjectLiteral(\n    servers.map((server, i) => [\n      serverName(server, i),\n      generateServerExpression(server),\n    ]),\n  );\n}\n","import _ from \"lodash\";\nimport ts from \"typescript\";\nimport { OpenAPIV3, OpenAPIV3_1 } from \"openapi-types\";\nimport * as cg from \"./tscodegen\";\nimport generateServers, { defaultBaseUrl } from \"./generateServers\";\nimport { Opts } from \".\";\n\nexport * from \"./tscodegen\";\nexport * from \"./generateServers\";\n\nconst factory = ts.factory;\n\nexport const verbs = [\n  \"GET\",\n  \"PUT\",\n  \"POST\",\n  \"DELETE\",\n  \"OPTIONS\",\n  \"HEAD\",\n  \"PATCH\",\n  \"TRACE\",\n];\n\ntype ContentType = \"json\" | \"form\" | \"multipart\";\ntype OnlyMode = \"readOnly\" | \"writeOnly\";\ntype OnlyModes = Record<OnlyMode, boolean>;\n\n// Use union of OAS 3.0 and 3.1 types throughout\n// openapi-types does not define boolean json schemas (https://json-schema.org/draft/2020-12/json-schema-core#section-4.3.2)\ntype OpenAPISchemaObject =\n  | OpenAPIV3.SchemaObject\n  | OpenAPIV3_1.SchemaObject\n  | boolean;\ntype OpenAPIReferenceObject =\n  | OpenAPIV3.ReferenceObject\n  | OpenAPIV3_1.ReferenceObject;\ntype OpenAPIParameterObject =\n  | OpenAPIV3.ParameterObject\n  | OpenAPIV3_1.ParameterObject;\nexport type OpenAPIDocument = OpenAPIV3.Document | OpenAPIV3_1.Document;\ntype OpenAPIDiscriminatorObject =\n  | OpenAPIV3.DiscriminatorObject\n  | OpenAPIV3_1.DiscriminatorObject;\ntype OpenAPIResponseObject =\n  | OpenAPIV3.ResponseObject\n  | OpenAPIV3_1.ResponseObject;\ntype OpenAPIResponsesObject =\n  | OpenAPIV3.ResponsesObject\n  | OpenAPIV3_1.ResponsesObject;\ntype OpenAPIRequestBodyObject =\n  | OpenAPIV3.RequestBodyObject\n  | OpenAPIV3_1.RequestBodyObject;\ntype OpenAPIMediaTypeObject =\n  | OpenAPIV3.MediaTypeObject\n  | OpenAPIV3_1.MediaTypeObject;\ntype OpenAPIOperationObject =\n  | OpenAPIV3.OperationObject\n  | OpenAPIV3_1.OperationObject;\n\nconst contentTypes: Record<string, ContentType> = {\n  \"*/*\": \"json\",\n  \"application/json\": \"json\",\n  \"application/x-www-form-urlencoded\": \"form\",\n  \"multipart/form-data\": \"multipart\",\n};\n\nexport function isMimeType(s: unknown) {\n  return typeof s === \"string\" && /^[^/]+\\/[^/]+$/.test(s);\n}\n\nexport function isJsonMimeType(mime: string) {\n  return contentTypes[mime] === \"json\" || /\\bjson\\b/i.test(mime);\n}\n\nexport function getBodyFormatter(body?: OpenAPIRequestBodyObject) {\n  if (body?.content) {\n    for (const contentType of Object.keys(body.content)) {\n      const formatter = contentTypes[contentType];\n      if (formatter) return formatter;\n      if (isJsonMimeType(contentType)) return \"json\";\n    }\n  }\n}\n\n// Augment SchemaObject type to allow slowly adopting new OAS3.1+ features\n// and support custom vendor extensions.\nexport type SchemaObject = OpenAPISchemaObject & {\n  const?: unknown;\n  \"x-enumNames\"?: string[];\n  \"x-enum-varnames\"?: string[];\n  \"x-component-ref-path\"?: string;\n  prefixItems?: (OpenAPIReferenceObject | SchemaObject)[];\n};\n\nexport type DiscriminatingSchemaObject = Exclude<SchemaObject, boolean> & {\n  discriminator: NonNullable<Exclude<SchemaObject, boolean>[\"discriminator\"]>;\n};\n\n/**\n * Get the name of a formatter function for a given parameter.\n */\nexport function getFormatter({\n  style = \"form\",\n  explode = true,\n  content,\n}: OpenAPIParameterObject) {\n  if (content) {\n    const medias = Object.keys(content);\n    if (medias.length !== 1) {\n      throw new Error(\n        \"Parameters with content property must specify one media type\",\n      );\n    }\n    if (!isJsonMimeType(medias[0])) {\n      throw new Error(\n        \"Parameters with content property must specify a JSON compatible media type\",\n      );\n    }\n    return \"json\";\n  }\n  if (explode && style === \"deepObject\") return \"deep\";\n  if (explode) return \"explode\";\n  if (style === \"spaceDelimited\") return \"space\";\n  if (style === \"pipeDelimited\") return \"pipe\";\n  return \"form\";\n}\n\nexport function getOperationIdentifier(id?: string) {\n  if (!id) return;\n  if (id.match(/[^\\w\\s]/)) return;\n  id = _.camelCase(id);\n  if (cg.isValidIdentifier(id)) return id;\n}\n\n/**\n * Create a method name for a given operation, either from its operationId or\n * the HTTP verb and path.\n */\nexport function getOperationName(\n  verb: string,\n  path: string,\n  operationId?: string,\n) {\n  const id = getOperationIdentifier(operationId);\n  if (id) return id;\n  path = path.replace(/\\{(.+?)\\}/, \"by $1\").replace(/\\{(.+?)\\}/, \"and $1\");\n  return toIdentifier(`${verb} ${path}`);\n}\n\nexport function isNullable(schema?: SchemaObject | OpenAPIReferenceObject) {\n  if (typeof schema === \"boolean\") return schema;\n\n  if (schema && \"nullable\" in schema)\n    return !isReference(schema) && schema.nullable;\n\n  return false;\n}\n\nexport function isReference(obj: unknown): obj is OpenAPIReferenceObject {\n  return typeof obj === \"object\" && obj !== null && \"$ref\" in obj;\n}\n\n/**\n * Converts a local reference path into an array of property names.\n */\nexport function refPathToPropertyPath(ref: string) {\n  if (!ref.startsWith(\"#/\")) {\n    throw new Error(\n      `External refs are not supported (${ref}). Make sure to call SwaggerParser.bundle() first.`,\n    );\n  }\n  return ref\n    .slice(2)\n    .split(\"/\")\n    .map((s) => decodeURI(s.replace(/~1/g, \"/\").replace(/~0/g, \"~\")));\n}\n\n/**\n * Get the last path component of the given ref.\n */\nfunction getRefBasename(ref: string) {\n  return ref.replace(/.+\\//, \"\");\n}\n\n/**\n * Returns a name for the given ref that can be used as basis for a type\n * alias. This usually is the baseName, unless the ref starts with a number,\n * in which case the whole ref is returned, with slashes turned into\n * underscores.\n */\nfunction getRefName(ref: string) {\n  const base = getRefBasename(ref);\n  if (/^\\d+/.test(base)) {\n    return refPathToPropertyPath(ref).join(\"_\");\n  }\n  return base;\n}\n\n/**\n * If the given object is a ReferenceObject, return the last part of its path.\n */\nexport function getReferenceName(obj: unknown) {\n  if (isReference(obj)) {\n    return getRefBasename(obj.$ref);\n  }\n}\n\nconst onlyModeSuffixes: Record<OnlyMode, string> = {\n  readOnly: \"Read\",\n  writeOnly: \"Write\",\n};\n\nfunction getOnlyModeSuffix(onlyMode?: OnlyMode) {\n  if (!onlyMode) return \"\";\n  return onlyModeSuffixes[onlyMode];\n}\n\nexport function toIdentifier(\n  s: string,\n  upperFirst = false,\n  onlyMode?: OnlyMode,\n) {\n  let cc = _.camelCase(s) + getOnlyModeSuffix(onlyMode);\n  if (upperFirst) cc = _.upperFirst(cc);\n  if (cg.isValidIdentifier(cc)) return cc;\n  return \"$\" + cc;\n}\n\n/**\n * Create a template string literal from the given OpenAPI urlTemplate.\n * Curly braces in the path are turned into identifier expressions,\n * which are read from the local scope during runtime.\n */\nexport function createUrlExpression(path: string, qs?: ts.Expression) {\n  const spans: Array<{ expression: ts.Expression; literal: string }> = [];\n  // Use a replacer function to collect spans as a side effect:\n  const head = path.replace(\n    /(.*?)\\{(.+?)\\}(.*?)(?=\\{|$)/g,\n    (_substr, head, name, literal) => {\n      const expression = toIdentifier(name);\n      spans.push({\n        expression: cg.createCall(\n          factory.createIdentifier(\"encodeURIComponent\"),\n          { args: [factory.createIdentifier(expression)] },\n        ),\n        literal,\n      });\n      return head;\n    },\n  );\n\n  if (qs) {\n    // add the query string as last span\n    spans.push({ expression: qs, literal: \"\" });\n  }\n  return cg.createTemplateString(head, spans);\n}\n\n/**\n * Create a call expression for one of the QS runtime functions.\n */\nexport function callQsFunction(name: string, args: ts.Expression[]) {\n  return cg.createCall(\n    factory.createPropertyAccessExpression(\n      factory.createIdentifier(\"QS\"),\n      name,\n    ),\n    { args },\n  );\n}\n\n/**\n * Create a call expression for one of the oazapfts runtime functions.\n */\nexport function callOazapftsFunction(\n  name: string,\n  args: ts.Expression[],\n  typeArgs?: ts.TypeNode[],\n) {\n  return cg.createCall(\n    factory.createPropertyAccessExpression(\n      factory.createIdentifier(\"oazapfts\"),\n      name,\n    ),\n    { args, typeArgs },\n  );\n}\n\n/**\n * Despite its name, OpenApi's `deepObject` serialization does not support\n * deeply nested objects. As a workaround we detect parameters that contain\n * square brackets and merge them into a single object.\n */\nexport function supportDeepObjects(params: OpenAPIParameterObject[]) {\n  const res: OpenAPIParameterObject[] = [];\n  const merged: any = {};\n  params.forEach((p) => {\n    const m = /^(.+?)\\[(.*?)\\]/.exec(p.name);\n    if (!m) {\n      res.push(p);\n      return;\n    }\n    const [, name, prop] = m;\n    let obj = merged[name];\n    if (!obj) {\n      obj = merged[name] = {\n        name,\n        in: p.in,\n        style: \"deepObject\",\n        schema: {\n          type: \"object\",\n          properties: {},\n        },\n      };\n      res.push(obj);\n    }\n    obj.schema.properties[prop] = p.schema;\n  });\n  return res;\n}\n\nfunction isKeyOfKeywordType(key: string): key is keyof typeof cg.keywordType {\n  return key in cg.keywordType;\n}\n\n/**\n * Main entry point that generates TypeScript code from a given API spec.\n */\nexport default class ApiGenerator {\n  constructor(\n    public readonly spec: OpenAPIDocument,\n    public readonly opts: Opts = {},\n    /** Indicates if the document was converted from an older version of the OpenAPI specification. */\n    public readonly isConverted = false,\n  ) {\n    if (this.spec.components?.schemas) {\n      this.preprocessComponents(this.spec.components.schemas);\n    }\n  }\n\n  // see `preprocessComponents` for the definition of a discriminating schema\n  discriminatingSchemas: Set<string> = new Set();\n\n  aliases: (ts.TypeAliasDeclaration | ts.InterfaceDeclaration)[] = [];\n\n  enumAliases: ts.Statement[] = [];\n  enumRefs: Record<string, { values: string; type: ts.TypeReferenceNode }> = {};\n\n  // Collect the types of all referenced schemas so we can export them later\n  // Referenced schemas can be pointing at the following versions:\n  // - \"base\": The regular type/interface e.g. ExampleSchema\n  // - \"readOnly\": The readOnly version e.g. ExampleSchemaRead\n  // - \"writeOnly\": The writeOnly version e.g. ExampleSchemaWrite\n  refs: Record<\n    string,\n    {\n      base: ts.TypeReferenceNode;\n      readOnly?: ts.TypeReferenceNode;\n      writeOnly?: ts.TypeReferenceNode;\n    }\n  > = {};\n\n  // Maps a referenced schema to its readOnly/writeOnly status\n  // This field should be used exclusively within the `checkSchemaOnlyMode` method\n  refsOnlyMode: Map<string, OnlyModes> = new Map();\n\n  // Keep track of already used type aliases\n  typeAliases: Record<string, number> = {};\n\n  reset() {\n    this.aliases = [];\n    this.enumAliases = [];\n    this.refs = {};\n    this.typeAliases = {};\n  }\n\n  resolve<T>(obj: T | OpenAPIReferenceObject) {\n    if (!isReference(obj)) return obj;\n    const ref = obj.$ref;\n    const path = refPathToPropertyPath(ref);\n    const resolved = _.get(this.spec, path);\n    if (typeof resolved === \"undefined\") {\n      throw new Error(`Can't find ${path}`);\n    }\n    return resolved as T;\n  }\n\n  resolveArray<T>(array?: Array<T | OpenAPIReferenceObject>) {\n    return array ? array.map((el) => this.resolve(el)) : [];\n  }\n\n  skip(tags?: string[]) {\n    const excluded = tags && tags.some((t) => this.opts?.exclude?.includes(t));\n    if (excluded) {\n      return true;\n    }\n    if (this.opts?.include) {\n      const included = tags && tags.some((t) => this.opts.include?.includes(t));\n      return !included;\n    }\n    return false;\n  }\n\n  findAvailableRef(ref: string) {\n    const available = (ref: string) => {\n      try {\n        this.resolve({ $ref: ref });\n        return false;\n      } catch (error) {\n        return true;\n      }\n    };\n\n    if (available(ref)) return ref;\n\n    let i = 2;\n    while (true) {\n      const key = ref + String(i);\n      if (available(key)) return key;\n      i += 1;\n    }\n  }\n\n  getUniqueAlias(name: string) {\n    let used = this.typeAliases[name] || 0;\n    if (used) {\n      this.typeAliases[name] = ++used;\n      name += used;\n    }\n    this.typeAliases[name] = 1;\n    return name;\n  }\n\n  getEnumUniqueAlias(name: string, values: string) {\n    // If enum name already exists and have the same values\n    if (this.enumRefs[name] && this.enumRefs[name].values == values) {\n      return name;\n    }\n\n    return this.getUniqueAlias(name);\n  }\n\n  /**\n   * Create a type alias for the schema referenced by the given ReferenceObject\n   */\n  getRefAlias(\n    obj: OpenAPIReferenceObject,\n    onlyMode?: OnlyMode,\n    // If true, the discriminator property of the schema referenced by `obj` will be ignored.\n    // This is meant to be used when getting the type of a discriminating schema in an `allOf`\n    // construct.\n    ignoreDiscriminator?: boolean,\n  ) {\n    const $ref = ignoreDiscriminator\n      ? this.findAvailableRef(obj.$ref + \"Base\")\n      : obj.$ref;\n\n    if (!this.refs[$ref]) {\n      let schema = this.resolve<SchemaObject>(obj);\n\n      if (typeof schema !== \"boolean\" && ignoreDiscriminator) {\n        schema = _.cloneDeep(schema);\n        delete schema.discriminator;\n      }\n      const name =\n        (typeof schema !== \"boolean\" && schema.title) || getRefName($ref);\n      const identifier = toIdentifier(name, true);\n\n      // When this is a true enum we can reference it directly,\n      // no need to create a type alias\n      if (this.isTrueEnum(schema, name)) {\n        return this.getTypeFromSchema(schema, name);\n      }\n\n      const alias = this.getUniqueAlias(identifier);\n\n      this.refs[$ref] = {\n        base: factory.createTypeReferenceNode(alias, undefined),\n        readOnly: undefined,\n        writeOnly: undefined,\n      };\n\n      const type = this.getTypeFromSchema(schema, undefined);\n      this.aliases.push(\n        cg.createTypeAliasDeclaration({\n          modifiers: [cg.modifier.export],\n          name: alias,\n          type,\n        }),\n      );\n\n      const { readOnly, writeOnly } = this.checkSchemaOnlyMode(schema);\n\n      if (readOnly) {\n        const readOnlyAlias = this.getUniqueAlias(\n          toIdentifier(name, true, \"readOnly\"),\n        );\n        this.refs[$ref][\"readOnly\"] = factory.createTypeReferenceNode(\n          readOnlyAlias,\n          undefined,\n        );\n\n        const readOnlyType = this.getTypeFromSchema(schema, name, \"readOnly\");\n        this.aliases.push(\n          cg.createTypeAliasDeclaration({\n            modifiers: [cg.modifier.export],\n            name: readOnlyAlias,\n            type: readOnlyType,\n          }),\n        );\n      }\n\n      if (writeOnly) {\n        const writeOnlyAlias = this.getUniqueAlias(\n          toIdentifier(name, true, \"writeOnly\"),\n        );\n        this.refs[$ref][\"writeOnly\"] = factory.createTypeReferenceNode(\n          writeOnlyAlias,\n          undefined,\n        );\n        const writeOnlyType = this.getTypeFromSchema(schema, name, \"writeOnly\");\n        this.aliases.push(\n          cg.createTypeAliasDeclaration({\n            modifiers: [cg.modifier.export],\n            name: writeOnlyAlias,\n            type: writeOnlyType,\n          }),\n        );\n      }\n    }\n\n    // If not ref fallback to the regular reference\n    return this.refs[$ref][onlyMode || \"base\"] ?? this.refs[$ref].base;\n  }\n\n  getUnionType(\n    variants: (OpenAPIReferenceObject | SchemaObject)[],\n    discriminator?: OpenAPIDiscriminatorObject,\n    onlyMode?: OnlyMode,\n  ) {\n    if (discriminator) {\n      // oneOf + discriminator -> tagged union (polymorphism)\n      if (discriminator.propertyName === undefined) {\n        throw new Error(\"Discriminators require a propertyName\");\n      }\n\n      // By default, the last component of the ref name (i.e., after the last trailing slash) is\n      // used as the discriminator value for each variant. This can be overridden using the\n      // discriminator.mapping property.\n      const mappedValues = new Set(\n        Object.values(discriminator.mapping || {}).map(getRefBasename),\n      );\n\n      return factory.createUnionTypeNode(\n        (\n          [\n            ...Object.entries(discriminator.mapping || {}).map(\n              ([discriminatorValue, variantRef]) => [\n                discriminatorValue,\n                { $ref: variantRef },\n              ],\n            ),\n            ...variants\n              .filter((variant) => {\n                if (!isReference(variant)) {\n                  // From the Swagger spec: \"When using the discriminator, inline schemas will not be\n                  // considered.\"\n                  throw new Error(\n                    \"Discriminators require references, not inline schemas\",\n                  );\n                }\n                return !mappedValues.has(getRefBasename(variant.$ref));\n              })\n              .map((schema) => {\n                const schemaBaseName = getRefBasename(\n                  (schema as OpenAPIV3.ReferenceObject).$ref,\n                );\n                const resolvedSchema = this.resolve(\n                  schema,\n                ) as OpenAPIV3.SchemaObject;\n                const discriminatorProperty =\n                  resolvedSchema.properties?.[discriminator.propertyName];\n                const variantName =\n                  discriminatorProperty && \"enum\" in discriminatorProperty\n                    ? discriminatorProperty?.enum?.[0]\n                    : \"\";\n                return [variantName || schemaBaseName, schema];\n              }),\n          ] as [string, OpenAPIReferenceObject][]\n        ).map(([discriminatorValue, variant]) =>\n          // Yields: { [discriminator.propertyName]: discriminatorValue } & variant\n          factory.createIntersectionTypeNode([\n            factory.createTypeLiteralNode([\n              cg.createPropertySignature({\n                name: discriminator.propertyName,\n                type: this.getDiscriminatorType(\n                  variant,\n                  discriminator.propertyName,\n                  [discriminatorValue],\n                ),\n              }),\n            ]),\n            this.getTypeFromSchema(variant, undefined, onlyMode),\n          ]),\n        ),\n      );\n    } else {\n      // oneOf -> untagged union\n      return factory.createUnionTypeNode(\n        _.uniq(\n          variants.map((schema) =>\n            this.getTypeFromSchema(schema, undefined, onlyMode),\n          ),\n        ),\n      );\n    }\n  }\n\n  /**\n   * Creates a type node from a given schema.\n   * Delegates to getBaseTypeFromSchema internally and\n   * optionally adds a union with null.\n   */\n  getTypeFromSchema(\n    schema?: SchemaObject | OpenAPIReferenceObject,\n    name?: string,\n    onlyMode?: OnlyMode,\n  ) {\n    const type = this.getBaseTypeFromSchema(schema, name, onlyMode);\n    return isNullable(schema)\n      ? factory.createUnionTypeNode([type, cg.keywordType.null])\n      : type;\n  }\n\n  getEmptySchemaType() {\n    return this.opts.useUnknown ? cg.keywordType.unknown : cg.keywordType.any;\n  }\n\n  /**\n   * This is the very core of the OpenAPI to TS conversion - it takes a\n   * schema and returns the appropriate type.\n   */\n  getBaseTypeFromSchema(\n    schema?: SchemaObject | OpenAPIReferenceObject,\n    name?: string,\n    onlyMode?: OnlyMode,\n  ): ts.TypeNode {\n    if (!schema && typeof schema !== \"boolean\")\n      return this.getEmptySchemaType();\n    if (isReference(schema)) {\n      return this.getRefAlias(schema, onlyMode) as ts.TypeReferenceNode;\n    }\n\n    if (schema === true) {\n      return this.getEmptySchemaType();\n    }\n\n    if (schema === false) {\n      return cg.keywordType.never;\n    }\n\n    if (schema.oneOf) {\n      const clone = { ...schema };\n      delete clone.oneOf;\n      // oneOf -> union\n      return this.getUnionType(\n        schema.oneOf.map((variant) =>\n          // ensure that base properties from the schema are included in the oneOf variants\n          _.mergeWith({}, clone, variant, (objValue, srcValue) => {\n            if (_.isArray(objValue)) {\n              return objValue.concat(srcValue);\n            }\n          }),\n        ),\n        schema.discriminator,\n        onlyMode,\n      );\n    }\n    if (schema.anyOf) {\n      // anyOf -> union\n      return this.getUnionType(schema.anyOf, undefined, onlyMode);\n    }\n    if (schema.discriminator?.mapping) {\n      // discriminating schema -> union\n      const mapping = schema.discriminator.mapping;\n      return this.getUnionType(\n        Object.values(mapping).map((ref) => ({ $ref: ref })),\n        undefined,\n        onlyMode,\n      );\n    }\n    if (schema.allOf) {\n      // allOf -> intersection\n      const types: Array<ts.TypeNode> = [];\n      for (const childSchema of schema.allOf) {\n        if (\n          isReference(childSchema) &&\n          this.discriminatingSchemas.has(childSchema.$ref)\n        ) {\n          const discriminatingSchema =\n            this.resolve<DiscriminatingSchemaObject>(childSchema);\n          const discriminator = discriminatingSchema.discriminator;\n          const matches = Object.entries(discriminator.mapping ?? {})\n            .filter(([, ref]) => ref === schema[\"x-component-ref-path\"])\n            .map(([discriminatorValue]) => discriminatorValue);\n          if (matches.length > 0) {\n            types.push(\n              factory.createTypeLiteralNode([\n                cg.createPropertySignature({\n                  name: discriminator.propertyName,\n                  type: this.getDiscriminatorType(\n                    discriminatingSchema,\n                    discriminator.propertyName,\n                    matches,\n                  ),\n                }),\n              ]),\n            );\n          }\n          types.push(\n            this.getRefAlias(\n              childSchema,\n              onlyMode,\n              /* ignoreDiscriminator */ true,\n            ),\n          );\n        } else {\n          types.push(\n            this.getTypeFromSchema(\n              {\n                required: schema.required,\n                ...childSchema,\n              },\n              undefined,\n              onlyMode,\n            ),\n          );\n        }\n      }\n\n      if (schema.properties || schema.additionalProperties) {\n        // properties -> literal type\n        types.push(\n          this.getTypeFromProperties(\n            schema.properties || {},\n            schema.required,\n            schema.additionalProperties,\n            onlyMode,\n          ),\n        );\n      }\n      return factory.createIntersectionTypeNode(types);\n    }\n    // Union types defined by an array in schema.type\n    if (Array.isArray(schema.type)) {\n      return factory.createUnionTypeNode(\n        schema.type.map((type) => {\n          const subSchema = { ...schema, type } as SchemaObject;\n          // Remove items if the type isn't array since it's not relevant\n          if (\"items\" in subSchema && type !== \"array\") {\n            delete subSchema.items;\n          }\n          if (\"properties\" in subSchema && type !== \"object\") {\n            delete subSchema.properties;\n          }\n\n          return this.getBaseTypeFromSchema(subSchema, name, onlyMode);\n        }),\n      );\n    }\n    if (\"items\" in schema) {\n      const schemaItems = schema.items as OpenAPIV3.BaseSchemaObject;\n\n      // items -> array of enums or unions\n      if (schemaItems.enum) {\n        const enumType = this.isTrueEnum(schemaItems, name)\n          ? this.getTrueEnum(schemaItems, name)\n          : cg.createEnumTypeNode(schemaItems.enum);\n\n        return factory.createArrayTypeNode(enumType);\n      }\n\n      // items -> array\n      return factory.createArrayTypeNode(\n        this.getTypeFromSchema(schema.items, undefined, onlyMode),\n      );\n    }\n    if (\"prefixItems\" in schema && schema.prefixItems) {\n      // prefixItems -> typed tuple\n      return factory.createTupleTypeNode(\n        schema.prefixItems.map((schema) => this.getTypeFromSchema(schema)),\n      );\n    }\n    if (schema.properties || schema.additionalProperties) {\n      // properties -> literal type\n      return this.getTypeFromProperties(\n        schema.properties || {},\n        schema.required,\n        schema.additionalProperties,\n        onlyMode,\n      );\n    }\n    if (schema.enum) {\n      // enum -> enum or union\n      return this.isTrueEnum(schema, name)\n        ? this.getTrueEnum(schema, name)\n        : cg.createEnumTypeNode(schema.enum);\n    }\n    if (schema.format == \"binary\") {\n      return factory.createTypeReferenceNode(\"Blob\", []);\n    }\n    if (schema.const) {\n      return this.getTypeFromEnum([schema.const]);\n    }\n    if (schema.type !== undefined) {\n      if (schema.type === null) return cg.keywordType.null;\n      if (isKeyOfKeywordType(schema.type)) return cg.keywordType[schema.type];\n    }\n\n    return this.getEmptySchemaType();\n  }\n\n  isTrueEnum(schema: SchemaObject, name?: string): name is string {\n    return Boolean(\n      typeof schema !== \"boolean\" &&\n      schema.enum &&\n      this.opts.useEnumType &&\n      name &&\n      schema.type !== \"boolean\",\n    );\n  }\n\n  /**\n   * Get enum member reference type for discriminator values when useEnumType is enabled\n   */\n  getDiscriminatorType(\n    discriminatingSchemaRef:\n      | Exclude<SchemaObject, boolean>\n      | OpenAPIReferenceObject,\n    propertyName: string,\n    matches: string[],\n  ): ts.TypeNode {\n    if (!this.opts.useEnumType) {\n      return this.getTypeFromEnum(matches);\n    }\n\n    const discriminatingSchema = this.resolve(discriminatingSchemaRef);\n    // Get the discriminator property schema to check if it should use enum types\n    // Check the schema's own properties first, then search in allOf parents\n    let discriminatorPropertySchema = this.resolve(\n      discriminatingSchema.properties?.[propertyName],\n    );\n\n    if (!discriminatorPropertySchema && discriminatingSchema.allOf) {\n      // Search in allOf parents\n      for (const allOfSchema of discriminatingSchema.allOf) {\n        const resolvedAllOf = this.resolve(allOfSchema);\n        if (resolvedAllOf.properties?.[propertyName]) {\n          discriminatorPropertySchema = this.resolve(\n            resolvedAllOf.properties[propertyName],\n          );\n          break;\n        }\n      }\n    }\n\n    if (\n      !discriminatorPropertySchema ||\n      !this.isTrueEnum(discriminatorPropertySchema, propertyName)\n    ) {\n      return this.getTypeFromEnum(matches);\n    }\n\n    // Get the enum type reference\n    const enumTypeRef = this.getTrueEnum(\n      discriminatorPropertySchema,\n      propertyName,\n    );\n\n    if (matches.length === 1) {\n      // Single value: return EnumName.MemberName as a type reference\n      const enumMemberName = factory.createIdentifier(\n        toIdentifier(matches[0], true),\n      );\n      const enumName = (enumTypeRef as ts.TypeReferenceNode)\n        .typeName as ts.Identifier;\n      return factory.createTypeReferenceNode(\n        factory.createQualifiedName(enumName, enumMemberName),\n        undefined,\n      );\n    } else {\n      // Multiple matches: return union of EnumName.MemberName1 | EnumName.MemberName2\n      const enumName = (enumTypeRef as ts.TypeReferenceNode)\n        .typeName as ts.Identifier;\n      const memberTypes = matches.map((value) => {\n        const enumMemberName = factory.createIdentifier(\n          toIdentifier(value, true),\n        );\n        return factory.createTypeReferenceNode(\n          factory.createQualifiedName(enumName, enumMemberName),\n          undefined,\n        );\n      });\n\n      return factory.createUnionTypeNode(memberTypes);\n    }\n  }\n\n  /**\n   * Creates literal type (or union) from an array of values\n   */\n  getTypeFromEnum(values: unknown[]) {\n    const types = values.map((s) => {\n      if (s === null) return cg.keywordType.null;\n      if (typeof s === \"boolean\")\n        return s\n          ? factory.createLiteralTypeNode(\n              ts.factory.createToken(ts.SyntaxKind.TrueKeyword),\n            )\n          : factory.createLiteralTypeNode(\n              ts.factory.createToken(ts.SyntaxKind.FalseKeyword),\n            );\n      if (typeof s === \"number\")\n        return factory.createLiteralTypeNode(factory.createNumericLiteral(s));\n      if (typeof s === \"string\")\n        return factory.createLiteralTypeNode(factory.createStringLiteral(s));\n      throw new Error(`Unexpected ${String(s)} of type ${typeof s} in enum`);\n    });\n    return types.length > 1 ? factory.createUnionTypeNode(types) : types[0];\n  }\n\n  getEnumValuesString(values: string[]) {\n    return values.join(\"_\");\n  }\n\n  /*\n    Creates a enum \"ref\" if not used, reuse existing if values and name matches or creates a new one\n    with a new name adding a number\n  */\n  getTrueEnum(schema: SchemaObject, propName: string) {\n    if (typeof schema === \"boolean\") {\n      // this should never be thrown, since the only `getTrueEnum` call is\n      // behind an `isTrueEnum` check, which returns false for boolean schemas.\n      throw new Error(\n        \"cannot get enum from boolean schema. schema must be an object\",\n      );\n    }\n    const baseName = schema.title || _.upperFirst(propName);\n    // TODO: use _.camelCase in future major version\n    // (currently we allow _ and $ for backwards compatibility)\n    const proposedName = baseName\n      .split(/[^A-Za-z0-9$_]/g)\n      .map((n) => _.upperFirst(n))\n      .join(\"\");\n    const stringEnumValue = this.getEnumValuesString(\n      schema.enum ? schema.enum : [],\n    );\n\n    const name = this.getEnumUniqueAlias(proposedName, stringEnumValue);\n\n    if (this.enumRefs[proposedName] && proposedName === name) {\n      return this.enumRefs[proposedName].type;\n    }\n\n    const values = schema.enum ? schema.enum : [];\n\n    const names = schema[\"x-enumNames\"] ?? schema[\"x-enum-varnames\"];\n    if (names) {\n      if (!Array.isArray(names)) {\n        throw new Error(\"enum names must be an array\");\n      }\n      if (names.length !== values.length) {\n        throw new Error(\"enum names must have the same length as enum values\");\n      }\n    }\n\n    const members = values.map((s, index) => {\n      if (\n        schema.type === \"number\" ||\n        schema.type === \"integer\" ||\n        schema.type === \"string\"\n      ) {\n        const name = names ? names[index] : String(s);\n        return factory.createEnumMember(\n          factory.createIdentifier(toIdentifier(name, true)),\n          cg.createLiteral(s),\n        );\n      }\n      return factory.createEnumMember(\n        factory.createIdentifier(toIdentifier(s, true)),\n        cg.createLiteral(s),\n      );\n    });\n    this.enumAliases.push(\n      factory.createEnumDeclaration([cg.modifier.export], name, members),\n    );\n\n    const type = factory.createTypeReferenceNode(name, undefined);\n\n    this.enumRefs[proposedName] = {\n      values: stringEnumValue,\n      type: factory.createTypeReferenceNode(name, undefined),\n    };\n\n    return type;\n  }\n\n  /**\n   * Checks if readOnly/writeOnly properties are present in the given schema.\n   * Returns a tuple of booleans; the first one is about readOnly, the second\n   * one is about writeOnly.\n   */\n  checkSchemaOnlyMode(\n    schema: SchemaObject | OpenAPIReferenceObject,\n    resolveRefs = true,\n  ): OnlyModes {\n    if (this.opts.mergeReadWriteOnly) {\n      return { readOnly: false, writeOnly: false };\n    }\n\n    const check = (\n      schema: SchemaObject | OpenAPIReferenceObject,\n      history: Set<string>,\n    ): OnlyModes => {\n      if (isReference(schema)) {\n        if (!resolveRefs) return { readOnly: false, writeOnly: false };\n\n        // history is used to prevent infinite recursion\n        if (history.has(schema.$ref))\n          return { readOnly: false, writeOnly: false };\n\n        // check if the result is cached in `this.refsOnlyMode`\n        const cached = this.refsOnlyMode.get(schema.$ref);\n        if (cached) return cached;\n\n        history.add(schema.$ref);\n        const ret = check(this.resolve(schema), history);\n        history.delete(schema.$ref);\n\n        // cache the result\n        this.refsOnlyMode.set(schema.$ref, ret);\n\n        return ret;\n      }\n\n      if (typeof schema === \"boolean\") {\n        return { readOnly: false, writeOnly: false };\n      }\n\n      let readOnly = schema.readOnly ?? false;\n      let writeOnly = schema.writeOnly ?? false;\n\n      const subSchemas: (OpenAPIReferenceObject | SchemaObject)[] = [];\n      if (\"items\" in schema && schema.items) {\n        subSchemas.push(schema.items);\n      } else {\n        subSchemas.push(...Object.values(schema.properties ?? {}));\n        subSchemas.push(...(schema.allOf ?? []));\n        subSchemas.push(...(schema.anyOf ?? []));\n        subSchemas.push(...(schema.oneOf ?? []));\n      }\n\n      for (const schema of subSchemas) {\n        // `readOnly` and `writeOnly` do not change once they become true,\n        // so you can exit early if both are true.\n        if (readOnly && writeOnly) break;\n\n        const result = check(schema, history);\n        readOnly = readOnly || result.readOnly;\n        writeOnly = writeOnly || result.writeOnly;\n      }\n\n      return { readOnly, writeOnly };\n    };\n\n    return check(schema, new Set<string>());\n  }\n\n  /**\n   * Recursively creates a type literal with the given props.\n   */\n  getTypeFromProperties(\n    props: {\n      [prop: string]: SchemaObject | OpenAPIReferenceObject;\n    },\n    required?: string[],\n    additionalProperties?:\n      | boolean\n      | OpenAPISchemaObject\n      | OpenAPIReferenceObject,\n    onlyMode?: OnlyMode,\n  ): ts.TypeLiteralNode {\n    // Check if any of the props are readOnly or writeOnly schemas\n    const propertyNames = Object.keys(props);\n    const filteredPropertyNames = propertyNames.filter((name) => {\n      const schema = props[name];\n      const { readOnly, writeOnly } = this.checkSchemaOnlyMode(schema, false);\n\n      switch (onlyMode) {\n        case \"readOnly\":\n          return readOnly || !writeOnly;\n        case \"writeOnly\":\n          return writeOnly || !readOnly;\n        default:\n          return !readOnly && !writeOnly;\n      }\n    });\n\n    const members: ts.TypeElement[] = filteredPropertyNames.map((name) => {\n      const schema = props[name];\n      const isRequired = required && required.includes(name);\n      let type = this.getTypeFromSchema(schema, name, onlyMode);\n      if (!isRequired && this.opts.unionUndefined) {\n        type = factory.createUnionTypeNode([type, cg.keywordType.undefined]);\n      }\n\n      const signature = cg.createPropertySignature({\n        questionToken: !isRequired,\n        name,\n        type,\n      });\n\n      if (\n        typeof schema !== \"boolean\" &&\n        \"description\" in schema &&\n        schema.description\n      ) {\n        // Escape any JSDoc comment closing tags in description\n        const description = schema.description.replace(\"*/\", \"*\\\\/\");\n\n        ts.addSyntheticLeadingComment(\n          signature,\n          ts.SyntaxKind.MultiLineCommentTrivia,\n          // Ensures it is formatted like a JSDoc comment: /** description here */\n          `* ${description} `,\n          true,\n        );\n      }\n\n      return signature;\n    });\n    if (additionalProperties) {\n      const type =\n        additionalProperties === true\n          ? this.getEmptySchemaType()\n          : this.getTypeFromSchema(additionalProperties, undefined, onlyMode);\n\n      members.push(cg.createIndexSignature(type));\n    }\n    return factory.createTypeLiteralNode(members);\n  }\n\n  getTypeFromResponses(responses: OpenAPIResponsesObject, onlyMode?: OnlyMode) {\n    return factory.createUnionTypeNode(\n      Object.entries(responses).map(([code, res]) => {\n        const statusType =\n          code === \"default\"\n            ? cg.keywordType.number\n            : factory.createLiteralTypeNode(factory.createNumericLiteral(code));\n\n        const props = [\n          cg.createPropertySignature({\n            name: \"status\",\n            type: statusType,\n          }),\n        ];\n\n        const dataType = this.getTypeFromResponse(res, onlyMode);\n        if (dataType !== cg.keywordType.void) {\n          props.push(\n            cg.createPropertySignature({\n              name: \"data\",\n              type: dataType,\n            }),\n          );\n        }\n        return factory.createTypeLiteralNode(props);\n      }),\n    );\n  }\n\n  getTypeFromResponse(\n    resOrRef: OpenAPIResponseObject | OpenAPIReferenceObject,\n    onlyMode?: OnlyMode,\n  ) {\n    const res = this.resolve(resOrRef);\n    if (!res || !res.content) return cg.keywordType.void;\n    return this.getTypeFromSchema(\n      this.getSchemaFromContent(res.content),\n      undefined,\n      onlyMode,\n    );\n  }\n\n  getResponseType(\n    responses?: OpenAPIResponsesObject,\n  ): \"json\" | \"text\" | \"blob\" {\n    // backwards-compatibility\n    if (!responses) return \"text\";\n\n    const resolvedResponses = Object.values(responses).map((response) =>\n      this.resolve(response),\n    );\n\n    // if no content is specified, assume `text` (backwards-compatibility)\n    if (\n      !resolvedResponses.some(\n        (res) => Object.keys(res.content ?? {}).length > 0,\n      )\n    ) {\n      return \"text\";\n    }\n\n    const isJson = resolvedResponses.some((response) => {\n      const responseMimeTypes = Object.keys(response.content ?? {});\n      return responseMimeTypes.some(isJsonMimeType);\n    });\n\n    // if there’s `application/json` or `*/*`, assume `json`\n    if (isJson) {\n      return \"json\";\n    }\n\n    // if there’s `text/*`, assume `text`\n    if (\n      resolvedResponses.some((res) =>\n        Object.keys(res.content ?? []).some((type) => type.startsWith(\"text/\")),\n      )\n    ) {\n      return \"text\";\n    }\n\n    // for the rest, assume `blob`\n    return \"blob\";\n  }\n\n  getSchemaFromContent(\n    content: Record<string, OpenAPIMediaTypeObject>,\n  ): OpenAPISchemaObject | OpenAPIReferenceObject {\n    const contentType = Object.keys(content).find(isMimeType);\n    if (contentType) {\n      const { schema } = content[contentType];\n      if (schema) {\n        return schema;\n      }\n    }\n\n    // if no content is specified -> string\n    // `text/*` -> string\n    if (\n      Object.keys(content).length === 0 ||\n      Object.keys(content).some((type) => type.startsWith(\"text/\"))\n    ) {\n      return { type: \"string\" };\n    }\n\n    // rest (e.g. `application/octet-stream`, `application/gzip`, …) -> binary\n    return { type: \"string\", format: \"binary\" };\n  }\n\n  getTypeFromParameter(p: OpenAPIParameterObject) {\n    if (p.content) {\n      const schema = this.getSchemaFromContent(p.content);\n      return this.getTypeFromSchema(schema);\n    }\n    return this.getTypeFromSchema(isReference(p) ? p : p.schema);\n  }\n\n  wrapResult(ex: ts.Expression) {\n    return this.opts?.optimistic ? callOazapftsFunction(\"ok\", [ex]) : ex;\n  }\n\n  /**\n   * Does three things:\n   * 1. Add a `x-component-ref-path` property.\n   * 2. Record discriminating schemas in `this.discriminatingSchemas`. A discriminating schema\n   *    refers to a schema that has a `discriminator` property which is neither used in conjunction\n   *    with `oneOf` nor `anyOf`.\n   * 3. Make all mappings of discriminating schemas explicit to generate types immediately.\n   */\n  preprocessComponents(schemas: {\n    [key: string]: OpenAPIReferenceObject | SchemaObject;\n  }) {\n    const prefix = \"#/components/schemas/\";\n\n    // First scan: Add `x-component-ref-path` property and record discriminating schemas\n    for (const name of Object.keys(schemas)) {\n      const schema = schemas[name];\n      if (isReference(schema) || typeof schema === \"boolean\") continue;\n\n      schema[\"x-component-ref-path\"] = prefix + name;\n\n      if (\n        typeof schema !== \"boolean\" &&\n        schema.discriminator &&\n        !schema.oneOf &&\n        !schema.anyOf\n      ) {\n        this.discriminatingSchemas.add(prefix + name);\n      }\n    }\n\n    const isExplicit = (\n      discriminator: OpenAPIDiscriminatorObject,\n      ref: string,\n    ) => {\n      const refs = Object.values(discriminator.mapping || {});\n      return refs.includes(ref);\n    };\n\n    // Second scan: Make all mappings of discriminating schemas explicit\n    for (const name of Object.keys(schemas)) {\n      const schema = schemas[name];\n\n      if (isReference(schema) || typeof schema === \"boolean\" || !schema.allOf) {\n        continue;\n      }\n\n      for (const childSchema of schema.allOf) {\n        if (\n          !isReference(childSchema) ||\n          !this.discriminatingSchemas.has(childSchema.$ref)\n        ) {\n          continue;\n        }\n\n        const discriminatingSchema = schemas[\n          getRefBasename(childSchema.$ref)\n        ] as DiscriminatingSchemaObject;\n        const discriminator = discriminatingSchema.discriminator!;\n\n        if (isExplicit(discriminator, prefix + name)) continue;\n        if (!discriminator.mapping) {\n          discriminator.mapping = {};\n        }\n        discriminator.mapping[name] = prefix + name;\n      }\n    }\n  }\n\n  generateApi() {\n    this.reset();\n\n    // Parse ApiStub.ts so that we don't have to generate everything manually\n    const stub = ts.createSourceFile(\n      \"ApiStub.ts\",\n      __API_STUB_PLACEHOLDER__, // replaced with ApiStub.ts during build\n      ts.ScriptTarget.Latest,\n      /*setParentNodes*/ false,\n      ts.ScriptKind.TS,\n    );\n\n    // ApiStub contains `const servers = {}`, find it ...\n    const servers = cg.findFirstVariableDeclaration(stub.statements, \"servers\");\n    // servers.initializer is readonly, this might break in a future TS version, but works fine for now.\n    Object.assign(servers, {\n      initializer: generateServers(this.spec.servers || []),\n    });\n\n    const { initializer } = cg.findFirstVariableDeclaration(\n      stub.statements,\n      \"defaults\",\n    );\n    if (!initializer || !ts.isObjectLiteralExpression(initializer)) {\n      throw new Error(\"No object literal: defaults\");\n    }\n\n    cg.changePropertyValue(\n      initializer,\n      \"baseUrl\",\n      defaultBaseUrl(this.spec.servers || []),\n    );\n\n    // Collect class functions to be added...\n    const functions: ts.FunctionDeclaration[] = [];\n\n    // Keep track of names to detect duplicates\n    const names: Record<string, number> = {};\n\n    if (this.spec.paths) {\n      Object.keys(this.spec.paths).forEach((path) => {\n        if (!this.spec.paths) return;\n\n        const item = this.spec.paths[path];\n\n        if (!item) {\n          return;\n        }\n\n        Object.keys(this.resolve(item)).forEach((verb) => {\n          const method = verb.toUpperCase();\n          // skip summary/description/parameters etc...\n          if (!verbs.includes(method)) return;\n\n          const op: OpenAPIOperationObject = (item as any)[verb];\n          const {\n            operationId,\n            requestBody,\n            responses,\n            summary,\n            description,\n            tags,\n          } = op;\n\n          if (this.skip(tags)) {\n            return;\n          }\n\n          let name = getOperationName(verb, path, operationId);\n          const count = (names[name] = (names[name] || 0) + 1);\n          if (count > 1) {\n            // The name is already taken, which means that the spec is probably\n            // invalid as operationIds must be unique. Since this is quite common\n            // nevertheless we append a counter:\n            name += count;\n          }\n\n          // merge item and op parameters\n          const resolvedParameters = this.resolveArray(item.parameters);\n          for (const p of this.resolveArray(op.parameters)) {\n            const existing = resolvedParameters.find(\n              (r) => r.name === p.name && r.in === p.in,\n            );\n            if (!existing) {\n              resolvedParameters.push(p);\n            }\n          }\n\n          // expand older OpenAPI parameters into deepObject style where needed\n          const parameters = this.isConverted\n            ? supportDeepObjects(resolvedParameters)\n            : resolvedParameters;\n\n          // convert parameter names to argument names ...\n          const argNames = new Map<OpenAPIParameterObject, string>();\n          _.sortBy(parameters, \"name.length\").forEach((p) => {\n            const identifier = toIdentifier(p.name);\n            const existing = [...argNames.values()];\n            const suffix = existing.includes(identifier)\n              ? _.upperFirst(p.in)\n              : \"\";\n            argNames.set(p, identifier + suffix);\n          });\n\n          const getArgName = (param: OpenAPIParameterObject) => {\n            const name = argNames.get(param);\n            if (!name) throw new Error(`Can't find parameter: ${param.name}`);\n            return name;\n          };\n\n          const methodParams: ts.ParameterDeclaration[] = [];\n          let body: OpenAPIRequestBodyObject | undefined = undefined;\n          let bodyVar: string | undefined = undefined;\n          switch (this.opts.argumentStyle ?? \"positional\") {\n            case \"positional\":\n              // split into required/optional\n              const [required, optional] = _.partition(parameters, \"required\");\n\n              // build the method signature - first all the required parameters\n              const requiredParams = required.map((p) =>\n                cg.createParameter(getArgName(this.resolve(p)), {\n                  type: this.getTypeFromParameter(p),\n                }),\n              );\n              methodParams.push(...requiredParams);\n\n              // add body if present\n              if (requestBody) {\n                body = this.resolve(requestBody);\n                const schema = this.getSchemaFromContent(body.content);\n                const type = this.getTypeFromSchema(\n                  schema,\n                  undefined,\n                  \"writeOnly\",\n                );\n                bodyVar = toIdentifier(\n                  (type as any).name || getReferenceName(schema) || \"body\",\n                );\n                methodParams.push(\n                  cg.createParameter(bodyVar, {\n                    type,\n                    questionToken: !body.required,\n                  }),\n                );\n              }\n\n              // add an object with all optional parameters\n              if (optional.length) {\n                methodParams.push(\n                  cg.createParameter(\n                    cg.createObjectBinding(\n                      optional\n                        .map((param) => this.resolve(param))\n                        .map((param) => ({ name: getArgName(param) })),\n                    ),\n                    {\n                      initializer: factory.createObjectLiteralExpression(),\n                      type: factory.createTypeLiteralNode(\n                        optional.map((p) =>\n                          cg.createPropertySignature({\n                            name: getArgName(this.resolve(p)),\n                            questionToken: true,\n                            type: this.getTypeFromParameter(p),\n                          }),\n                        ),\n                      ),\n                    },\n                  ),\n                );\n              }\n              break;\n\n            case \"object\":\n              // build the method signature - first all the required/optional parameters\n              const paramMembers = parameters.map((p) =>\n                cg.createPropertySignature({\n                  name: getArgName(this.resolve(p)),\n                  questionToken: !p.required,\n                  type: this.getTypeFromParameter(p),\n                }),\n              );\n\n              // add body if present\n              if (requestBody) {\n                body = this.resolve(requestBody);\n                const schema = this.getSchemaFromContent(body.content);\n                const type = this.getTypeFromSchema(\n                  schema,\n                  undefined,\n                  \"writeOnly\",\n                );\n                bodyVar = toIdentifier(\n                  (type as any).name || getReferenceName(schema) || \"body\",\n                );\n                paramMembers.push(\n                  cg.createPropertySignature({\n                    name: bodyVar,\n                    questionToken: !body.required,\n                    type,\n                  }),\n                );\n              }\n\n              // if there's no params, leave methodParams as is and prevent empty object argument generation\n              if (paramMembers.length === 0) {\n                break;\n              }\n\n              methodParams.push(\n                cg.createParameter(\n                  cg.createObjectBinding([\n                    ...parameters\n                      .map((param) => this.resolve(param))\n                      .map((param) => ({ name: getArgName(param) })),\n                    ...(bodyVar ? [{ name: bodyVar }] : []),\n                  ]),\n                  {\n                    type: factory.createTypeLiteralNode(paramMembers),\n                  },\n                ),\n              );\n              break;\n          }\n\n          // add oazapfts options\n          methodParams.push(\n            cg.createParameter(\"opts\", {\n              type: factory.createTypeReferenceNode(\n                \"Oazapfts.RequestOpts\",\n                undefined,\n              ),\n              questionToken: true,\n            }),\n          );\n\n          // Next, build the method body...\n\n          const returnType = this.getResponseType(responses);\n          const query = parameters.filter((p) => p.in === \"query\");\n          const header = parameters.filter((p) => p.in === \"header\");\n\n          let qs;\n          if (query.length) {\n            const paramsByFormatter = _.groupBy(query, getFormatter);\n            qs = callQsFunction(\n              \"query\",\n              Object.entries(paramsByFormatter).map(([format, params]) => {\n                //const [allowReserved, encodeReserved] = _.partition(params, \"allowReserved\");\n                return callQsFunction(format, [\n                  cg.createObjectLiteral(\n                    params.map((p) => [p.name, getArgName(p)]),\n                  ),\n                ]);\n              }),\n            );\n          }\n\n          const url = createUrlExpression(path, qs);\n          const init: ts.ObjectLiteralElementLike[] = [\n            factory.createSpreadAssignment(factory.createIdentifier(\"opts\")),\n          ];\n\n          if (method !== \"GET\") {\n            init.push(\n              factory.createPropertyAssignment(\n                \"method\",\n                factory.createStringLiteral(method),\n              ),\n            );\n          }\n\n          if (bodyVar) {\n            init.push(\n              cg.createPropertyAssignment(\n                \"body\",\n                factory.createIdentifier(bodyVar),\n              ),\n            );\n          }\n\n          if (header.length) {\n            init.push(\n              factory.createPropertyAssignment(\n                \"headers\",\n                callOazapftsFunction(\"mergeHeaders\", [\n                  factory.createPropertyAccessChain(\n                    factory.createIdentifier(\"opts\"),\n                    factory.createToken(ts.SyntaxKind.QuestionDotToken),\n                    \"headers\",\n                  ),\n                  factory.createObjectLiteralExpression(\n                    [\n                      ...header.map((param) =>\n                        cg.createPropertyAssignment(\n                          param.name,\n                          factory.createIdentifier(getArgName(param)),\n                        ),\n                      ),\n                    ],\n                    true,\n                  ),\n                ]),\n              ),\n            );\n          }\n\n          const args: ts.Expression[] = [url];\n\n          if (init.length) {\n            const formatter = getBodyFormatter(body); // json, form, multipart\n            const initObj = factory.createObjectLiteralExpression(init, true);\n            args.push(\n              formatter ? callOazapftsFunction(formatter, [initObj]) : initObj,\n            );\n          }\n\n          functions.push(\n            cg.addComment(\n              cg.createFunctionDeclaration(\n                name,\n                {\n                  modifiers: [cg.modifier.export],\n                },\n                methodParams,\n                cg.block(\n                  factory.createReturnStatement(\n                    this.wrapResult(\n                      callOazapftsFunction(\n                        {\n                          json: \"fetchJson\",\n                          text: \"fetchText\",\n                          blob: \"fetchBlob\",\n                        }[returnType],\n                        args,\n                        returnType === \"json\" || returnType === \"blob\"\n                          ? [\n                              this.getTypeFromResponses(\n                                responses!,\n                                \"readOnly\",\n                              ) || ts.SyntaxKind.AnyKeyword,\n                            ]\n                          : undefined,\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n              summary || description,\n            ),\n          );\n        });\n      });\n    }\n\n    Object.assign(stub, {\n      statements: cg.appendNodes(\n        stub.statements,\n        ...[...this.aliases, ...functions],\n        ...this.enumAliases,\n      ),\n    });\n\n    return stub;\n  }\n}\n","import ts from \"typescript\";\nimport { toIdentifier } from \"./generate\";\n\nconst factory = ts.factory;\n\nexport const questionToken = factory.createToken(ts.SyntaxKind.QuestionToken);\n\nexport function createQuestionToken(token?: boolean | ts.QuestionToken) {\n  if (!token) return undefined;\n  if (token === true) return questionToken;\n  return token;\n}\n\nexport const keywordType = {\n  any: factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n  number: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),\n  integer: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),\n  object: factory.createKeywordTypeNode(ts.SyntaxKind.ObjectKeyword),\n  string: factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n  boolean: factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword),\n  undefined: factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword),\n  void: factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword),\n  never: factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword),\n  null: factory.createLiteralTypeNode(factory.createNull()),\n  unknown: factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),\n};\n\ntype KeywordTypeName = keyof typeof keywordType;\n\nexport function createKeywordType(type: KeywordTypeName) {\n  return keywordType[type];\n}\n\nexport const modifier = {\n  async: factory.createModifier(ts.SyntaxKind.AsyncKeyword),\n  export: factory.createModifier(ts.SyntaxKind.ExportKeyword),\n};\n\nexport function createLiteral(v: string | boolean | number) {\n  switch (typeof v) {\n    case \"string\":\n      return factory.createStringLiteral(v);\n    case \"boolean\":\n      return v ? factory.createTrue() : factory.createFalse();\n    case \"number\":\n      return String(v).charAt(0) === \"-\"\n        ? factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            factory.createNumericLiteral(String(-v)),\n          )\n        : factory.createNumericLiteral(String(v));\n  }\n}\n\nexport function createEnumTypeNode(values: Array<string | boolean | number>) {\n  const types = values.map((v) =>\n    v === null\n      ? keywordType.null\n      : factory.createLiteralTypeNode(createLiteral(v)),\n  );\n  return types.length > 1 ? factory.createUnionTypeNode(types) : types[0];\n}\n\nexport function createTypeAliasDeclaration({\n  modifiers,\n  name,\n  typeParameters,\n  type,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  name: string | ts.Identifier;\n  typeParameters?: Array<ts.TypeParameterDeclaration>;\n  type: ts.TypeNode;\n}) {\n  return factory.createTypeAliasDeclaration(\n    modifiers,\n    name,\n    typeParameters,\n    type,\n  );\n}\n\nexport function createInterfaceAliasDeclaration({\n  modifiers,\n  name,\n  typeParameters,\n  type,\n  inheritedNodeNames,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  name: string | ts.Identifier;\n  typeParameters?: Array<ts.TypeParameterDeclaration>;\n  type: ts.TypeNode;\n  inheritedNodeNames?: (string | ts.Identifier)[];\n}) {\n  const heritageClauses = inheritedNodeNames\n    ? [\n        factory.createHeritageClause(\n          ts.SyntaxKind.ExtendsKeyword,\n          inheritedNodeNames.map((name) => {\n            const extendedInterfaceName =\n              typeof name === \"string\" ? name : name.escapedText.toString();\n            return factory.createExpressionWithTypeArguments(\n              factory.createIdentifier(\n                toIdentifier(extendedInterfaceName, true),\n              ),\n              undefined,\n            );\n          }),\n        ),\n      ]\n    : [];\n  return factory.createInterfaceDeclaration(\n    modifiers,\n    name,\n    typeParameters,\n    heritageClauses,\n    (type as ts.TypeLiteralNode).members,\n  );\n}\n\nexport function toExpression(ex: ts.Expression | string) {\n  if (typeof ex === \"string\") return factory.createIdentifier(ex);\n  return ex;\n}\n\nexport function createCall(\n  expression: ts.Expression | string,\n  {\n    typeArgs,\n    args,\n  }: {\n    typeArgs?: Array<ts.TypeNode>;\n    args?: Array<ts.Expression>;\n  } = {},\n) {\n  return factory.createCallExpression(toExpression(expression), typeArgs, args);\n}\n\nexport function createMethodCall(\n  method: string,\n  opts: {\n    typeArgs?: Array<ts.TypeNode>;\n    args?: Array<ts.Expression>;\n  },\n) {\n  return createCall(\n    factory.createPropertyAccessExpression(factory.createThis(), method),\n    opts,\n  );\n}\n\nexport function createObjectLiteral(props: [string, string | ts.Expression][]) {\n  return factory.createObjectLiteralExpression(\n    props.map(([name, identifier]) =>\n      createPropertyAssignment(name, toExpression(identifier)),\n    ),\n    true,\n  );\n}\n\nexport function createPropertyAssignment(\n  name: string,\n  expression: ts.Expression,\n) {\n  if (ts.isIdentifier(expression)) {\n    if (expression.text === name) {\n      return factory.createShorthandPropertyAssignment(name);\n    }\n  }\n  return factory.createPropertyAssignment(propertyName(name), expression);\n}\n\nexport function block(...statements: ts.Statement[]) {\n  return factory.createBlock(statements, true);\n}\n\nexport function createArrowFunction(\n  parameters: ts.ParameterDeclaration[],\n  body: ts.ConciseBody,\n  {\n    modifiers,\n    typeParameters,\n    type,\n    equalsGreaterThanToken,\n  }: {\n    modifiers?: ts.Modifier[];\n    typeParameters?: ts.TypeParameterDeclaration[];\n    type?: ts.TypeNode;\n    equalsGreaterThanToken?: ts.EqualsGreaterThanToken;\n  } = {},\n) {\n  return factory.createArrowFunction(\n    modifiers,\n    typeParameters,\n    parameters,\n    type,\n    equalsGreaterThanToken,\n    body,\n  );\n}\n\nexport function createFunctionDeclaration(\n  name: string | ts.Identifier | undefined,\n  {\n    modifiers,\n    asteriskToken,\n    typeParameters,\n    type,\n  }: {\n    modifiers?: ts.Modifier[];\n    asteriskToken?: ts.AsteriskToken;\n    typeParameters?: ts.TypeParameterDeclaration[];\n    type?: ts.TypeNode;\n  },\n  parameters: ts.ParameterDeclaration[],\n  body?: ts.Block,\n): ts.FunctionDeclaration {\n  return factory.createFunctionDeclaration(\n    modifiers,\n    asteriskToken,\n    name,\n    typeParameters,\n    parameters,\n    type,\n    body,\n  );\n}\n\nexport function createClassDeclaration({\n  modifiers,\n  name,\n  typeParameters,\n  heritageClauses,\n  members,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  name?: string | ts.Identifier;\n  typeParameters?: Array<ts.TypeParameterDeclaration>;\n  heritageClauses?: Array<ts.HeritageClause>;\n  members: Array<ts.ClassElement>;\n}) {\n  return factory.createClassDeclaration(\n    modifiers,\n    name,\n    typeParameters,\n    heritageClauses,\n    members,\n  );\n}\n\nexport function createConstructor({\n  modifiers,\n  parameters,\n  body,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  parameters: Array<ts.ParameterDeclaration>;\n  body?: ts.Block;\n}) {\n  return factory.createConstructorDeclaration(modifiers, parameters, body);\n}\n\nexport function createMethod(\n  name:\n    | string\n    | ts.Identifier\n    | ts.StringLiteral\n    | ts.NumericLiteral\n    | ts.ComputedPropertyName,\n  {\n    modifiers,\n    asteriskToken,\n    questionToken,\n    typeParameters,\n    type,\n  }: {\n    modifiers?: ts.Modifier[];\n    asteriskToken?: ts.AsteriskToken;\n    questionToken?: ts.QuestionToken | boolean;\n    typeParameters?: ts.TypeParameterDeclaration[];\n    type?: ts.TypeNode;\n  } = {},\n  parameters: ts.ParameterDeclaration[] = [],\n  body?: ts.Block,\n): ts.MethodDeclaration {\n  return factory.createMethodDeclaration(\n    modifiers,\n    asteriskToken,\n    name,\n    createQuestionToken(questionToken),\n    typeParameters,\n    parameters,\n    type,\n    body,\n  );\n}\n\nexport function createParameter(\n  name: string | ts.BindingName,\n  {\n    modifiers,\n    dotDotDotToken,\n    questionToken,\n    type,\n    initializer,\n  }: {\n    modifiers?: Array<ts.Modifier>;\n    dotDotDotToken?: ts.DotDotDotToken;\n    questionToken?: ts.QuestionToken | boolean;\n    type?: ts.TypeNode;\n    initializer?: ts.Expression;\n  },\n): ts.ParameterDeclaration {\n  return factory.createParameterDeclaration(\n    modifiers,\n    dotDotDotToken,\n    name,\n    createQuestionToken(questionToken),\n    type,\n    initializer,\n  );\n}\n\nfunction propertyName(name: string | ts.PropertyName): ts.PropertyName {\n  if (typeof name === \"string\") {\n    return isValidIdentifier(name)\n      ? factory.createIdentifier(name)\n      : factory.createStringLiteral(name);\n  }\n  return name;\n}\n\nexport function createPropertySignature({\n  modifiers,\n  name,\n  questionToken,\n  type,\n}: {\n  modifiers?: Array<ts.Modifier>;\n  name: ts.PropertyName | string;\n  questionToken?: ts.QuestionToken | boolean;\n  type?: ts.TypeNode;\n}) {\n  return factory.createPropertySignature(\n    modifiers,\n    propertyName(name),\n    createQuestionToken(questionToken),\n    type,\n  );\n}\n\nexport function createIndexSignature(\n  type: ts.TypeNode,\n  {\n    modifiers,\n    indexName = \"key\",\n    indexType = keywordType.string,\n  }: {\n    indexName?: string;\n    indexType?: ts.TypeNode;\n    modifiers?: Array<ts.Modifier>;\n  } = {},\n) {\n  return factory.createIndexSignature(\n    modifiers,\n    [createParameter(indexName, { type: indexType })],\n    type,\n  );\n}\n\nexport function createObjectBinding(\n  elements: Array<{\n    name: string | ts.BindingName;\n    dotDotDotToken?: ts.DotDotDotToken;\n    propertyName?: string | ts.PropertyName;\n    initializer?: ts.Expression;\n  }>,\n) {\n  return factory.createObjectBindingPattern(\n    elements.map(({ dotDotDotToken, propertyName, name, initializer }) =>\n      factory.createBindingElement(\n        dotDotDotToken,\n        propertyName,\n        name,\n        initializer,\n      ),\n    ),\n  );\n}\n\nexport function createTemplateString(\n  head: string,\n  spans: Array<{ literal: string; expression: ts.Expression }>,\n) {\n  if (!spans.length) return factory.createStringLiteral(head);\n  return factory.createTemplateExpression(\n    factory.createTemplateHead(head),\n    spans.map(({ expression, literal }, i) =>\n      factory.createTemplateSpan(\n        expression,\n        i === spans.length - 1\n          ? factory.createTemplateTail(literal)\n          : factory.createTemplateMiddle(literal),\n      ),\n    ),\n  );\n}\n\nexport function findNode<T extends ts.Node>(\n  nodes: ts.NodeArray<ts.Node>,\n  kind: T extends { kind: infer K } ? K : never,\n  test?: (node: T) => boolean | undefined,\n): T {\n  const node = nodes.find(\n    (s) => s.kind === kind && (!test || test(s as T)),\n  ) as T;\n  if (!node) throw new Error(`Node not found: ${kind}`);\n  return node;\n}\n\nexport function getName(name: ts.Node) {\n  if (ts.isIdentifier(name)) {\n    return name.escapedText;\n  }\n  if (ts.isLiteralExpression(name)) {\n    return name.text;\n  }\n  return \"\";\n}\n\nexport function getFirstDeclarationName(n: ts.VariableStatement) {\n  const name = ts.getNameOfDeclaration(n.declarationList.declarations[0]);\n  return name ? getName(name) : \"\";\n}\n\nexport function findFirstVariableDeclaration(\n  nodes: ts.NodeArray<ts.Node>,\n  name: string,\n) {\n  const statement = findNode<ts.VariableStatement>(\n    nodes,\n    ts.SyntaxKind.VariableStatement,\n    (n) => getFirstDeclarationName(n) === name,\n  );\n  const [first] = statement.declarationList.declarations;\n  if (!first) throw new Error(\"Missing declaration\");\n  return first;\n}\n\nexport function changePropertyValue(\n  o: ts.ObjectLiteralExpression,\n  property: string,\n  value: ts.Expression,\n) {\n  const p = o.properties.find(\n    (p) => ts.isPropertyAssignment(p) && getName(p.name) === property,\n  );\n  if (p && ts.isPropertyAssignment(p)) {\n    // p.initializer is readonly, this might break in a future TS version, but works fine for now.\n    Object.assign(p, { initializer: value });\n  } else {\n    throw new Error(`No such property: ${property}`);\n  }\n}\n\nexport function appendNodes<T extends ts.Node>(\n  array: ts.NodeArray<T>,\n  ...nodes: T[]\n) {\n  return factory.createNodeArray([...array, ...nodes]);\n}\n\nexport function addComment<T extends ts.Node>(node: T, comment?: string) {\n  if (!comment) return node;\n  return ts.addSyntheticLeadingComment(\n    node,\n    ts.SyntaxKind.MultiLineCommentTrivia,\n    `*\\n * ${comment.replace(/\\n/g, \"\\n * \")}\\n `,\n    true,\n  );\n}\n\nconst printer = ts.createPrinter({\n  newLine: ts.NewLineKind.LineFeed,\n});\n\nexport function printNode(node: ts.Node) {\n  const file = ts.createSourceFile(\n    \"someFileName.ts\",\n    \"\",\n    ts.ScriptTarget.Latest,\n    /*setParentNodes*/ false,\n    ts.ScriptKind.TS,\n  );\n  return printer.printNode(ts.EmitHint.Unspecified, node, file);\n}\n\nexport function printNodes(nodes: ts.Node[]) {\n  const file = ts.createSourceFile(\n    \"someFileName.ts\",\n    \"\",\n    ts.ScriptTarget.Latest,\n    /*setParentNodes*/ false,\n    ts.ScriptKind.TS,\n  );\n  return nodes\n    .map((node) => printer.printNode(ts.EmitHint.Unspecified, node, file))\n    .join(\"\\n\");\n}\n\nexport function printFile(sourceFile: ts.SourceFile) {\n  return printer.printFile(sourceFile);\n}\n\nexport function isValidIdentifier(str: string) {\n  if (!str.length || str.trim() !== str) return false;\n  const node = ts.parseIsolatedEntityName(str, ts.ScriptTarget.Latest);\n  return (\n    !!node &&\n    node.kind === ts.SyntaxKind.Identifier &&\n    ts.identifierToKeywordKind(node) === undefined\n  );\n}\n"],"names":["factory","ts","createTemplate","url","tokens","chunks","_","cg.createTemplateString","expression","literal","createServerFunction","template","vars","params","cg.createParameter","cg.createObjectBinding","name","value","cg.createLiteral","cg.createPropertySignature","cg.createEnumTypeNode","cg.keywordType","cg.createArrowFunction","generateServerExpression","server","defaultUrl","variables","m","defaultBaseUrl","servers","serverName","index","generateServers","cg.createObjectLiteral","i","verbs","contentTypes","isMimeType","s","isJsonMimeType","mime","getBodyFormatter","body","contentType","formatter","getFormatter","style","explode","content","medias","getOperationIdentifier","id","cg.isValidIdentifier","getOperationName","verb","path","operationId","toIdentifier","isNullable","schema","isReference","obj","refPathToPropertyPath","ref","getRefBasename","getRefName","base","getReferenceName","onlyModeSuffixes","getOnlyModeSuffix","onlyMode","upperFirst","cc","createUrlExpression","qs","spans","head","_substr","cg.createCall","callQsFunction","args","callOazapftsFunction","typeArgs","supportDeepObjects","res","merged","p","prop","isKeyOfKeywordType","key","ApiGenerator","spec","opts","isConverted","__publicField","_a","resolved","array","el","tags","t","_b","available","error","used","values","ignoreDiscriminator","$ref","identifier","alias","type","cg.createTypeAliasDeclaration","cg.modifier","readOnly","writeOnly","readOnlyAlias","readOnlyType","writeOnlyAlias","writeOnlyType","variants","discriminator","mappedValues","discriminatorValue","variantRef","variant","schemaBaseName","discriminatorProperty","clone","__spreadValues","objValue","srcValue","mapping","types","childSchema","discriminatingSchema","matches","subSchema","__spreadProps","schemaItems","enumType","discriminatingSchemaRef","propertyName","discriminatorPropertySchema","allOfSchema","resolvedAllOf","enumTypeRef","enumMemberName","enumName","memberTypes","propName","proposedName","n","stringEnumValue","names","members","resolveRefs","check","history","cached","ret","subSchemas","result","props","required","additionalProperties","isRequired","signature","description","cg.createIndexSignature","responses","code","statusType","dataType","resOrRef","resolvedResponses","response","ex","schemas","prefix","isExplicit","stub","cg.findFirstVariableDeclaration","initializer","cg.changePropertyValue","functions","item","method","op","requestBody","summary","count","resolvedParameters","r","parameters","argNames","suffix","getArgName","param","methodParams","bodyVar","optional","requiredParams","paramMembers","returnType","query","header","paramsByFormatter","format","init","cg.createPropertyAssignment","initObj","cg.addComment","cg.createFunctionDeclaration","cg.block","cg.appendNodes","questionToken","createQuestionToken","token","keywordType","createKeywordType","modifier","createLiteral","v","createEnumTypeNode","createTypeAliasDeclaration","modifiers","typeParameters","createInterfaceAliasDeclaration","inheritedNodeNames","heritageClauses","extendedInterfaceName","toExpression","createCall","createMethodCall","createObjectLiteral","createPropertyAssignment","block","statements","createArrowFunction","equalsGreaterThanToken","createFunctionDeclaration","asteriskToken","createClassDeclaration","createConstructor","createMethod","createParameter","dotDotDotToken","isValidIdentifier","createPropertySignature","createIndexSignature","indexName","indexType","createObjectBinding","elements","createTemplateString","findNode","nodes","kind","test","node","getName","getFirstDeclarationName","findFirstVariableDeclaration","statement","first","changePropertyValue","o","property","appendNodes","addComment","comment","printer","printNode","file","printNodes","printFile","sourceFile","str"],"mappings":"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"}