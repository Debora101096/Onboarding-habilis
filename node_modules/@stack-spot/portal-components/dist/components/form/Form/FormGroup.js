import { jsxs as _jsxs, jsx as _jsx } from "react/jsx-runtime";
import { Box, Flex, IconBox, Input, Label } from '@citric/core';
import { InfoCircle, TimesCircle } from '@citric/icons';
import { FieldAddon, FieldGroup, FormHelper, FormItem, Tooltip } from '@citric/ui';
import { useTranslate } from '@stack-spot/portal-translate';
import { debounce, get } from 'lodash';
import { useEffect } from 'react';
import { useFormContext } from 'react-hook-form';
const registerFieldWithDebounceChangeValidation = (name, delay, trigger, register, options) => {
    const useFormRegisterReturn = register(name, options);
    const { onChange } = useFormRegisterReturn;
    const debouncedValidate = debounce(() => {
        trigger(name);
    }, delay);
    const debouncedChange = debounce((event) => {
        onChange?.(event);
    }, delay);
    return {
        ...useFormRegisterReturn,
        onChange: (e) => {
            debouncedChange(e);
            debouncedValidate();
        },
    };
};
export const FormGroup = ({ fieldAddonAfter, fieldAddonBefore, formHelper, id, name, component, label, registerOptions = {}, formGroupSx = {}, formItemSx = {}, componentSx = {}, disabled, readOnly, onChange, tooltipProps, required, colorScheme: propColorScheme, fieldAddonBeforeSx, fieldAddonAfterSx, standalone, delay, hideRequiredSymbol, shouldUnregister = false, ...props }) => {
    const t = useTranslate(dictionary);
    const { register, getFieldState, trigger, unregister } = useFormContext();
    const Component = component || Input;
    const colorScheme = propColorScheme;
    let formRegistry = {};
    if (!standalone) {
        const options = {
            onChange,
            required: { message: hideRequiredSymbol ? t.requiredTest : t.required, value: !!required }, validate: (value) => {
                if (required && typeof value === 'string') {
                    return !!value?.trim();
                }
            },
            ...registerOptions,
        };
        formRegistry = delay ? registerFieldWithDebounceChangeValidation(name, delay, trigger, register, options) : register(name, options);
    }
    useEffect(() => () => {
        shouldUnregister && unregister(name);
    }, [name, unregister]);
    return (_jsxs(FormItem, { sx: formItemSx, children: [label && (_jsxs(Flex, { children: [_jsxs(Label, { appearance: "body2", htmlFor: id || name, sx: { pointerEvents: disabled || readOnly ? 'none' : undefined }, children: [label, "\u00A0", required && !hideRequiredSymbol && '*'] }), tooltipProps?.text && (_jsx(Tooltip, { ...tooltipProps, children: _jsx(IconBox, { children: _jsx(InfoCircle, {}) }) }))] })), !fieldAddonBefore && !fieldAddonAfter ? (_jsx(Component, { id: id || name, disabled: disabled, readOnly: readOnly, ...props, colorScheme, ...formRegistry, required: required, sx: componentSx, "aria-errormessage": `err${(id || name)}`, "aria-invalid": getFieldState(name).invalid })) : (_jsxs(FieldGroup, { sx: formGroupSx, children: [fieldAddonBefore && (_jsx(FieldAddon, { sx: { borderColor: colorScheme ? colorScheme : 'light.600', ...fieldAddonBeforeSx }, children: fieldAddonBefore })), _jsx(Component, { disabled: disabled, readOnly: readOnly, id: id || name, ...props, colorScheme, ...formRegistry, required: required, sx: componentSx, "aria-errormessage": `err${(id || name)}`, "aria-invalid": getFieldState(name).invalid }), fieldAddonAfter && (_jsx(FieldAddon, { sx: { borderColor: colorScheme ? colorScheme : 'light.600', ...fieldAddonAfterSx }, children: fieldAddonAfter }))] })), _jsx(FormItemError, { name: name, id: id || name }), formHelper && (_jsx(Box, { mt: "2", children: _jsx(FormHelper, { children: formHelper }) }))] }));
};
export const FormItemError = ({ name, id }) => {
    const t = useTranslate(dictionary);
    const { formState } = useFormContext();
    const formItemError = get(formState.errors, name);
    if (formItemError) {
        return (_jsxs(Flex, { alignItems: "center", flexWrap: "nowrap", children: [_jsx(IconBox, { size: "xs", appearance: "circle", colorIcon: "danger", colorBg: "danger.500", children: _jsx(TimesCircle, {}) }), _jsx(Box, { ml: "3", children: _jsx(FormHelper, { colorScheme: "danger", "aria-live": "assertive", id: `err${id}`, children: formItemError.message?.toString() || formItemError?.root?.message?.toString() || t.invalidGenericError }) })] }));
    }
    return null;
};
const dictionary = {
    en: {
        invalidGenericError: 'Invalid field',
        required: 'Required field',
        // text for tests of usability
        requiredTest: 'Fill in the required field to continue.',
    },
    pt: {
        invalidGenericError: 'Campo inválido',
        required: 'Campo obrigatório',
        // text for tests of usability
        requiredTest: 'Preencha este campo obrigatório para continuar.',
    },
};
//# sourceMappingURL=FormGroup.js.map