import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Button, IconBox, Text } from '@citric/core';
import { Trash } from '@citric/icons';
import { LoadingCircular, Table, Tbody, Td, Th, Thead, Tr } from '@citric/ui';
import { theme } from '@stack-spot/portal-theme';
import { useTranslate } from '@stack-spot/portal-translate';
import { useState } from 'react';
import styled from 'styled-components';
import { ContentValidateFilter } from '../ContentValidateFilter.js';
import { HeaderSort } from './HeaderItem.js';
import { SettingsVerticalMenu } from './SettingsVerticalMenu.js';
const StyledTh = styled(Th) `
  border-top: ${({ $hasBorder }) => ($hasBorder ? `1px solid ${theme.color.light[400]}` : '')};
  border-bottom: ${({ $hasBorder }) => ($hasBorder ? `1px solid ${theme.color.light[400]}` : '')};
  &:first-child {
    border-left: ${({ $hasBorder }) => ($hasBorder ? `1px solid ${theme.color.light[400]}` : '')};
    border-top-left-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  &:last-child {
    border-right: ${({ $hasBorder }) => ($hasBorder ? `1px solid ${theme.color.light[400]}` : '')};
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
  }
`;
const StyledTd = styled(Td) `
  border-radius: 0px !important;
  
  &:first-child {
    border-top-left-radius: 4px !important;
    border-bottom-left-radius: 4px !important;
  }
  &:last-child {
    border-top-right-radius: 4px !important;
    border-bottom-right-radius: 4px !important;
  }
`;
const TableHeader = ({ columns, onSort, onRemove, sxTh, hasBorder, initialSortDetails }) => {
    const [sort, setSort] = useState(initialSortDetails?.direction);
    const [activeSort, setActiveSort] = useState(initialSortDetails?.index);
    const Sortable = ({ sort, direction, index }) => {
        onSort?.({ sort, direction, index });
        setSort(direction);
        setActiveSort(index);
    };
    return (_jsx(Thead, { children: _jsxs(Tr, { children: [columns.map((column, index) => column?.sortable && onSort ? (_jsx(StyledTh, { sx: sxTh, "$hasBorder": hasBorder, children: _jsx(HeaderSort, { sortType: activeSort !== index ? undefined : sort, onSort: (sortType) => Sortable?.({ sort: column.key, direction: sortType, index }), children: column.header }) }, column.key.toString())) : (_jsx(StyledTh, { sx: sxTh, "$hasBorder": hasBorder, children: _jsx(Text, { appearance: "microtext1", mr: "2", children: column.header }) }, column.key.toString()))), onRemove && _jsx(Th, {})] }) }));
};
function RemoveButton({ row, onRemove, canRemove }) {
    const t = useTranslate(dictionary);
    const [isLoading, setLoading] = useState(false);
    if (!onRemove || (canRemove && !canRemove(row))) {
        return null;
    }
    const handleRemove = async () => {
        if (isLoading)
            return;
        setLoading(true);
        try {
            await onRemove(row);
        }
        finally {
            setLoading(false);
        }
    };
    return (_jsx(Button, { colorScheme: "danger", onClick: handleRemove, size: "sm", children: isLoading ? _jsx(LoadingCircular, {}) : _jsxs(_Fragment, { children: [_jsx(IconBox, { size: "xs", mr: 2, colorIcon: "danger", children: _jsx(Trash, {}) }), _jsx(Text, { appearance: "microtext1", mr: "2", children: t.remove })] }) }));
}
const TableRows = ({ data, columns, options, onRemove, canRemove }) => {
    const rows = data.map((row, index) => (_jsxs(Tr, { children: [columns.map((column, columnIndex) => (_jsx(StyledTd, { sx: { ...column.sx }, children: _jsxs(_Fragment, { children: [" ", column?.customRender ? column.customRender(row) : row[column.key]] }) }, columnIndex))), canRemove && _jsx(StyledTd, { children: _jsx(RemoveButton, { row: row, onRemove: onRemove, canRemove: canRemove }) }), options && _jsx(StyledTd, { children: _jsx(SettingsVerticalMenu, { id: "workflow-studio-menu", items: options, size: "xs" }) })] }, `row-${index}`)));
    return _jsx(Tbody, { sx: { borderSpacing: '0 8px' }, children: rows });
};
export const TableData = ({ data, columns, onSort, onRemove, canRemove, tableAppearance = 'striped', options, sxHeader, hasHeaderBorder, searchParamName = 'search', initialSortDetails, afterContent, }) => {
    const searchParams = new URLSearchParams(window.location.search);
    const search = searchParams.get(searchParamName) ?? '';
    return (_jsx(ContentValidateFilter, { listLength: data.length, searchText: search, children: !!data.length && (_jsxs(_Fragment, { children: [_jsxs(Table, { appearance: tableAppearance, sx: { mb: 5 }, children: [_jsx("colgroup", { children: columns.map((column, index) => (_jsx("col", { style: { width: column.width || 'auto' } }, index))) }), _jsx(TableHeader, { sxTh: sxHeader, columns: columns, onSort: onSort, onRemove: onRemove, hasBorder: tableAppearance === 'striped' ? false : hasHeaderBorder, initialSortDetails: initialSortDetails }), _jsx(TableRows, { data: data, columns: columns, onRemove: onRemove, canRemove: canRemove, options: options })] }), !!afterContent && afterContent] })) }));
};
const dictionary = {
    en: {
        remove: 'Remove',
    },
    pt: {
        remove: 'Remover',
    },
};
//# sourceMappingURL=TableData.js.map