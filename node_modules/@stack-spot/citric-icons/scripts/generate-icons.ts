/* eslint-disable no-console */

import { createReadStream, createWriteStream } from 'fs'
import { cp, mkdir, readFile, rm, writeFile } from 'fs/promises'
import svg2ttf from 'svg2ttf'
// @ts-ignore
import SVGFixer from 'oslllo-svg-fixer'
import { SVGIcons2SVGFontStream } from 'svgicons2svgfont'
import { forbiddenIntervals, maps, source, target, temp } from './constants'
import skipFix from './skip-fix.json'
import { IconInfo } from './types'
import { capitalize, getIconGroups, getIconMap, getIconsInGroup } from './utils'

async function fixSVGs(name: string) {
  await mkdir(`${temp}/${name}`, { recursive: true })
  await SVGFixer(`${source}/${name}`, `${temp}/${name}`, {}).fix()
  const toSkip = skipFix[name as keyof typeof skipFix] ?? []
  for (const skip of toSkip) {
    await cp(`${source}/${name}/${skip}.svg`, `${temp}/${name}/${skip}.svg`)
  }
}

function generateSVGFont(name: string): Promise<IconInfo[]> {
  return new Promise<IconInfo[]>((resolve, reject) => {
    (async () => {
      const files = await getIconsInGroup(name)
      await fixSVGs(name)
      const fontStream = new SVGIcons2SVGFontStream({ fontName: name })
      const icons: IconInfo[] = []
      await mkdir(target, { recursive: true })
      const { lastUnicode, mappings } = await getIconMap(name)
      let next = lastUnicode + 1
      fontStream
        .pipe(createWriteStream(`${target}/${name}.svg`))
        .on('finish', async () => resolve(icons))
        .on('error', reject)
      for (const f of files) {
        while (forbiddenIntervals.some(({ min, max }) => next >= min && next <= max)) next++
        const glyph = createReadStream(`${temp}/${name}/${f}`)
        const iconName = f.replace(/\.svg$/, '')
        const icon: IconInfo = {
          name: iconName,
          unicode: mappings[iconName] ?? next++,
        }
        // @ts-ignore
        glyph.metadata = { name: icon.name, unicode: [String.fromCharCode(icon.unicode)] }
        fontStream.write(glyph)
        icons.push(icon)
      }
      
      fontStream.end()
    })()
  })
}

async function generateTTFFont(name: string) {
  const svg = await readFile(`${target}/${name}.svg`, 'utf8')
  const ttf = svg2ttf(svg, {})
  await writeFile(`${target}/${name}.ttf`, Buffer.from(ttf.buffer))
}

async function generateCSS(name: string, icons: IconInfo[]) {
  const fontName = `CitricIcons${capitalize(name)}`
  const css = [
    '@font-face {',
    `  font-family: '${fontName}';`,
    `  src: url('./${name}.ttf');`,
    '  font-weight: normal;',
    '  font-style: normal;',
    '}\n',
    'body {',
  ]
  for (const icon of icons) {
    css.push(`  --citric-icon-${name}-${icon.name}: '\\${icon.unicode.toString(16)}';`)
  }
  css.push(
    '}',
    `.citric-icon.${name} {`,
    `  font-family: ${fontName};`,
    '  line-height: 1;',
    '  font-style: normal;',
    '  &.xxl { font-size: 32px }',
    '  &.xl { font-size: 22px }',
    '  &.lg { font-size: 18px }',
    '  &.md { font-size: 14px }',
    '  &.sm { font-size: 12px }',
    '  &.xs { font-size: 10px }',
    '  &.xxs { font-size: 8px }\n',
  )
  for (const icon of icons) {
    css.push(`  &.${icon.name}:before { content: var(--citric-icon-${name}-${icon.name}); }`)
  }
  css.push('}')
  await writeFile(`${target}/${name}.css`, css.join('\n'), { encoding: 'utf8' })
}

async function generateIconMaps(name: string, icons: IconInfo[]) {
  const map = icons.reduce<Record<string, number>>(
    (result, current) => ({ ...result, [current.name]: current.unicode }), {})
  try {
    await mkdir(maps)
  } catch { /* empty */ }
  return writeFile(`${maps}/${name}.json`, JSON.stringify(map, null, 2), { encoding: 'utf8' })
}

function generateExample(name: string, icons: IconInfo[]) {
  const code = [
    '<html>',
    '<head>',
    `  <title>Citric Icons ${capitalize(name)}</title>`,
    `  <link rel="stylesheet" href="./${name}.css">`,
    '</head>',
    '<body style="background-color: #2c2c2e; font-size: 96px; color: #989898">',
    '  <div style="display: flex; gap: 10px; flex-wrap: wrap;">',
  ]
  for (const icon of icons) {
    code.push(`    <i class="citric-icon ${name} ${icon.name}" title="${icon.name}"></i>`)
  }
  code.push('  </div>')
  code.push('</body>')
  code.push('</html>')
  return writeFile(`${target}/${name}.html`, code.join('\n'), { encoding: 'utf8' })
}

async function start(): Promise<void> {
  await rm(temp, { recursive: true, force: true })
  console.log('fixed icons')
  const iconGroups = await getIconGroups()
  let hasError = false
  await Promise.all(iconGroups.map(async (group) => {
    try {
      const icons = await generateSVGFont(group)
      await Promise.all([generateCSS(group, icons), generateIconMaps(group, icons), generateExample(group, icons), generateTTFFont(group)])
      console.log('Icons successfully generated for', group)
    } catch (error) {
      hasError = true
      console.error(`Error while generating icons for: ${group}. Check the error below for more details.`)
      console.error(error)
    }
  }))
  await rm(temp, { recursive: true, force: true })
  process.exit(hasError ? 1 : 0)
}

start()
