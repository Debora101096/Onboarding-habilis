import type * as datadogT from '@datadog/browser-rum'
import { datadogRum } from '@datadog/browser-rum'
import { Session } from '@stack-spot/auth'
import { useSession } from '@stack-spot/auth-react'
import { eventBusClient } from '@stack-spot/portal-network'
import { getLanguage } from '@stack-spot/portal-translate'
import getXPath from 'get-xpath'
import { useEffect } from 'react'
import apisItauJson from './apis-itau.json'
import apisJson from './apis.json'
import { EventPageDetails, getCommonProps, Portal, prepareEvent, prepareRouteDetails } from './event-bus-events'

interface ElementClicked {
  tag?: string,
  page?: string,
  id?: string,
  text?: string,
  ariaLabel?: string,
  href?: string,
  metadata?: any,
  icon?: string,
  path: string,
}

type Tenant = 'stackspot' | 'itau'

type Apis = Partial<typeof apisJson>
interface DatadogInitProps extends datadogT.RumInitConfiguration {
  tenant?: 'stackspot' | 'itau',
}

const apis: Record<Tenant, Apis> = {
  'stackspot': apisJson,
  'itau': apisItauJson,
}

export function isDatadogInitialized() {
  if (datadogRum.getInitConfiguration()) {
    return true
  } else {
    return false
  }
}

/**
 * Initializes Datadog RUM, allowing tracing only for URLs from the selected tenant's API catalog.
 *
 * @param config Datadog RUM configuration, including the tenant to select the allowed API catalog.
 */
export async function datadogInit({ applicationId, clientToken, env, service, tenant = 'stackspot', ...rest }: DatadogInitProps) {
  const allowedAddresses = Object.values(apis[tenant]).map(it => it.url?.[env as keyof typeof it.url] ?? it.url.prd)
  const allowedTracingUrls = (value: string) => allowedAddresses.some(it => value.startsWith(it))

  if (clientToken) {
    datadogRum.init({
      applicationId,
      clientToken,
      site: 'datadoghq.com',
      service,
      env,
      trackViewsManually: true,
      sessionSampleRate: 100,
      sessionReplaySampleRate: 10,
      trackUserInteractions: true,
      trackResources: true,
      trackLongTasks: true,
      defaultPrivacyLevel: 'mask-user-input',
      compressIntakeRequests: true,
      allowedTracingUrls: [{ match: allowedTracingUrls, propagatorTypes: ['datadog'] }],
      ...rest,
    })
  }
}

let userSession: Session | undefined

export function useDatadogSetUser() {
  const session = useSession()
  useEffect(() => {
    userSession = session
    const setUserInDatadog = async () => {
      if (session) {
        const tokenData = session.getTokenData()
        const { account_name, email, sub } = tokenData
        datadogRum.setUser({ name: account_name, email, 'customer-id': sub, id: sub })
      }
    }
    setUserInDatadog()
  }, [session])
}

/**
 * Creates an event in the analytics tool saying an action was performed.
 * @param action the action name.
 * @param context a free-form object where you can pass any relevant information.
 */
export async function trackAction(action: string, context?: object | undefined) {
  datadogRum.addAction(action, context)
}

let targetOfLastTrackedEvent: ElementClicked | undefined

/**
 * Creates an event in the analytics tool saying an action was performed. All the data is extracted from the JS Event.
 * @param event the js event.
 * @param context a free-form object where you can pass any relevant information.
 */
export function trackEvent(event: React.UIEvent, context?: Record<string, any>) {
  const target = event.target instanceof HTMLElement ? event.target : undefined
  if (!target) return
  targetOfLastTrackedEvent = {
    tag: target.tagName,
    id: target.id,
    text: target.textContent ?? undefined,
    ariaLabel: target.ariaLabel ?? undefined,
    href: target.getAttribute('href') ?? undefined,
    icon: target.querySelector('citric-icon')?.className.replace(/\s?citric-icon\s?/, ''),
    path: getXPath(target),
    ...context,
  }
  trackAction(
    targetOfLastTrackedEvent.id || targetOfLastTrackedEvent.text || targetOfLastTrackedEvent.icon || targetOfLastTrackedEvent.tag || 'unknown',
    targetOfLastTrackedEvent,
  )
}


/**
 * Sends an error to the remote tracking tool.
 * @param error the error object.
 * @param context a free-form object where you can pass any relevant information.
 */
export async function trackError(error: unknown, context?: object | undefined) {
  datadogRum.addError(error, { targetOfLastTrackedEvent, ...context })
}

export async function sendClickToEventBus(itemText: string, routeDetails: EventPageDetails, portal: Portal,
  sendToEventBus: boolean = true) {
  const customerId = userSession?.getTokenData().sub
  const { entirePath, routeParams, path, currentUrl } = prepareRouteDetails(routeDetails)

  const data = {
    itemText: itemText,
    entirePath,
    routeParams,
    path,
    customerId,
    currentUrl,
    ...getCommonProps(userSession),
  }

  const event = prepareEvent({ type: 'click', portal, data })
  if (sendToEventBus) {
    try {
      await eventBusClient.sendEvent(event)
    } catch { /* empty */ }
  }
}

async function sendPageLoadedToEventBus(routeDetails: EventPageDetails, portal: Portal, customerId?: string,
  sendToEventBus: boolean = true) {

  const language = getLanguage()
  const { entirePath, queryParams, routeParams, path, currentUrl } = prepareRouteDetails(routeDetails)
  const data = {
    entirePath,
    queryParams,
    routeParams,
    path,
    customerId,
    language,
    currentUrl,
    ...getCommonProps(userSession),
  }

  const event = prepareEvent({ type: 'page_loaded', portal, data })
  if (sendToEventBus) {
    try {
      await eventBusClient.sendEvent(event)
    } catch { /* empty */ }
  }
}

export async function trackPageLoaded(routeDetails: EventPageDetails, portal: Portal, customerId?: string, sendToEventBus?: boolean) {
  const { pathNameWithParams } = routeDetails
  const manualTracking = datadogRum.getInitConfiguration()?.trackViewsManually
  await sendPageLoadedToEventBus(routeDetails, portal, customerId, sendToEventBus)

  if (!manualTracking) {
    // eslint-disable-next-line no-console
    console.warn('@datadog/rum-react-integration: The trackViewsManually flag in RUM initialization must be set to true')
    return
  }

  datadogRum.startView({ name: pathNameWithParams })
}


export function formatRouteForAnalytics(path: string, params: Record<string, any>) {
  const onlyQueryParams = new URLSearchParams()
  const onlyQueryParamsVariableName = new URLSearchParams()
  if (params) {
    for (const [key, value] of Object.entries(params)) {
      if (!path.includes(key)) {
        onlyQueryParams.append(key, value)
        onlyQueryParamsVariableName.append(key, `[${key}]`)
      }
    }
  }

  return {
    pathname: path,
    pathNameWithParams: path.replace(/{/g, '[').replace(/}/g, ']'),
    searchParams: onlyQueryParams.toString().replace(/%5B/g, '[').replace(/%5D/g, ']'),
    searchParamsWithVariableName: onlyQueryParamsVariableName.toString().replace(/%5B/g, '[').replace(/%5D/g, ']'),
    routeParams: params,
  }
}

/**
 * @deprecated
 * Use the hook `usePageTracking` instead.
 */
export function getRouteForAnalytics({ route, params }: { route: Record<string, any>, params: Record<string, any> }) {
  return formatRouteForAnalytics(route.$path, params)
}

/**
 * Whenever "path" or "params" change, a new analytics entry for a page navigation is created.
 * @param path the path to the current page, may include path variables as "{variable_name}".
 * @param params the parameters in the path: route params and query params.
 */
export function usePageTracking(path: string, params: Record<string, any>, portal: Portal) {
  const session = useSession()
  useEffect(() => {
    const sub: any = session?.getTokenData().sub
    if (!sub) return
    const routeForAnalytics = formatRouteForAnalytics(path, params)
    trackPageLoaded(routeForAnalytics, portal, sub)
  }, [path, params])
}
