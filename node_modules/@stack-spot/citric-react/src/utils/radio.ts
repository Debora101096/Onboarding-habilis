import { useEffect, useMemo, useRef, useState } from 'react'
import { defaultRenderKey } from './options'

export interface RadioGroupHookParams<T, F = string> {
  /**
   * The initial value for the radio group.
   */
  initialValue?: T,
  /**
   * A function to apply a filter to an option. Must return true if the option respects the filter and false otherwise.
   * @param filter the current filter.
   * @param option the current option.
   * @returns true if the option should pass the filter, false if the option should be discarded.
   */
  applyFilter?: (filter: F, option: T) => boolean,
  /**
   * The full set of options for the radio group.
   */
  options: T[],
  /**
   * A function that produces a unique id for an option.
   * @param option the current option.
   * @returns a unique key.
   */
  renderKey: (option: T) => string | number | undefined,
  /**
   * A function to call whenever the value changes.
   * @param newValue the new value.
   * @param previousValue the previous value.
   */
  onChange?: (newValue: T | undefined, previousValue: T | undefined) => void,
}

/**
 * Use this hook to easily implement filtering for a radio group.
 * @param params the parameters to create the controls.
 * @returns the checkbox controls.
 */
export function useRadioGroupControls<T, F = string>(params: RadioGroupHookParams<T, F>) {
  const [value, setValue] = useState(params.initialValue)
  const [filter, setFilter] = useState<F | undefined>()
  const previousValue = useRef(value)
  const renderKey = params.renderKey ?? defaultRenderKey

  useEffect(() => {
    params.onChange?.(value, previousValue.current)
    previousValue.current = value
  }, [value])

  const { options, isUnfilteredButChecked } = useMemo(() => {
    if (!params.applyFilter || !filter) return { options: params.options, isUnfilteredButChecked: () => false }
    const valueKey = value ? renderKey(value) : undefined
    const isValueFilteredOut = value && !params.applyFilter?.(filter, value)
    const filtered = params.options.filter(o => params.applyFilter?.(filter, o))
    return {
      options: isValueFilteredOut ? [value, ...filtered] : filtered,
      isUnfilteredButChecked: (o: T) => isValueFilteredOut && renderKey(o) === valueKey,
    }
  }, [params.options, filter])

  return {
    /**
     * The current filter applied.
     */
    filter,
    /**
     * Apply a new filter.
     */
    setFilter: setFilter,
    /**
     * The options that should be passed to the radio group.
     */
    options,
    /**
     * The value that should be passed to the radio group.
     */
    value,
    /**
     * Changes the current value, should be passed to the property `onChange` of the radio group.
     */
    setValue,
    /**
     * A function to render a unique key for an option. Should be passed to the property `renderKey` of the radio group.
     */
    renderKey,
    /**
     * A function that returns true if the option is filtered out, but checked.
     * @param option the option to check.
     * @returns true if the option was filtered out, but is checked; false otherwise.
     */
    isUnfilteredButChecked,
  }
}
