import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { defaultRenderKey } from './options'

export interface CheckboxGroupHookParams<T, F = string> {
  /**
   * The initial value for the checkbox group.
   * 
   * @default []
   */
  initialValue?: T[],
  /**
   * A function to apply a filter to an option. Must return true if the option respects the filter and false otherwise.
   * @param filter the current filter.
   * @param option the current option.
   * @returns true if the option should pass the filter, false if the option should be discarded.
   */
  applyFilter?: (filter: F, option: T) => boolean,
  /**
   * The full set of options for the checkbox group.
   */
  options: T[],
  /**
   * A function that produces a unique id for an option.
   * @param option the current option.
   * @returns a unique key.
   */
  renderKey: (option: T) => string | number | undefined,
  /**
   * A function to call whenever the value changes.
   * @param newValue the new value.
   * @param previousValue the previous value.
   */
  onChange?: (newValue: T[], previousValue: T[]) => void,
}

/**
 * Use this hook to easily implement filtering and selection controls for a checkbox group.
 * @param params the parameters to create the controls.
 * @returns the checkbox controls.
 */
export function useCheckboxGroupControls<T, F = string>(params: CheckboxGroupHookParams<T, F>) {
  const [value, setValue] = useState(params.initialValue ?? [])
  const [filter, setFilter] = useState<F | undefined>()
  const previousValue = useRef(value)
  const renderKey = params.renderKey ?? defaultRenderKey

  useEffect(() => {
    params.onChange?.(value, previousValue.current)
    previousValue.current = value
  }, [value])

  const { options, isUnfilteredButChecked } = useMemo(() => {
    if (!params.applyFilter || !filter) return { options: params.options, isUnfilteredButChecked: () => false }
    const filtered: T[] = []
    const unfilteredButChecked: T[] = []
    const map = new Map<number | string | undefined, boolean>()
    const valueKeys = value.map(o => renderKey(o))
    for (const o of params.options) {
      const key = renderKey(o)
      if (params.applyFilter(filter, o)) filtered.push(o)
      else if (valueKeys.includes(key)) {
        unfilteredButChecked.push(o)
        map.set(key, true)
      }
    }
    return { options: [...unfilteredButChecked, ...filtered], isUnfilteredButChecked: (o: T) => map.has(renderKey(o)) }
  }, [params.options, filter])

  const selectAll = useCallback(() => {
    setValue([...options])
  }, [options])

  const removeSelection = useCallback(() => {
    setValue([])
  }, [])

  return {
    /**
     * Selects all the options currently visible.
     */
    selectAll,
    /**
     * Removes all options from the selection.
     */
    removeSelection,
    /**
     * The current filter applied.
     */
    filter,
    /**
     * Apply a new filter.
     */
    setFilter,
    /**
     * The options that should be passed to the checkbox group.
     */
    options,
    /**
     * The value that should be passed to the checkbox group.
     */
    value,
    /**
     * Changes the current value, should be passed to the property `onChange` of the checkbox group.
     */
    setValue,
    /**
     * A function to render a unique key for an option. Should be passed to the property `renderKey` of the checkbox group.
     */
    renderKey,
    /**
     * A function that returns true if the option is filtered out, but checked.
     * @param option the option to check.
     * @returns true if the option was filtered out, but is checked; false otherwise.
     */
    isUnfilteredButChecked,
    /**
     * True if all options showing are selected, false otherwise.
     */
    isAllSelected: value.length === options.length,
  }
}
