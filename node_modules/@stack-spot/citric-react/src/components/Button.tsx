import { listToClass } from '@stack-spot/portal-theme'
import { Children, useMemo, useState } from 'react'
import { useCitricController } from '../context/hooks'
import { WithColorScheme } from '../types'
import { withRef } from '../utils/react'
import { CitricComponent } from './CitricComponent'
import { ProgressCircular } from './ProgressCircular'

export interface BaseButtonProps extends WithColorScheme {
  /**
   * - contained for buttons with background;
   * - outlined for transparent buttons with borders;
   * - text for buttons with no borders or background;
   * - none for buttons with no borders, background, paddings or any state effect (e.g. hover).
   * @default 'contained'
   */
  appearance?: 'outlined' | 'text' | 'contained' | 'none',
  /**
   * Size of the button.
   * @default 'md'
   */
  size?: 'sm' | 'md' | 'lg',
  /**
   * Animated text to show on when the button is clicked.
   */
  feedback?: string,
  /**
   * Whether or not to show a loading feedback instead of the button's content.
   * 
   * Buttons in the loading state are also disabled.
   */
  loading?: boolean,
  /**
   * Function to run when the button is clicked. If this function returns a promise, the button will automatically show a loading feedback
   * until the promise completes.
   */
  onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => any,
  /**
   * Metadata for the general onClick event, set by the CitricController. Useful for creating analytics data.
   * 
   * This only takes effect if there's a CitricController in React's context. The value of `metadata` is passed to the function
   * `onClickButton` of the controller.
   * 
   * @default false
   */
  metadata?: any,
}

export type ButtonProps = Omit<React.JSX.IntrinsicElements['button'], 'onClick'> & BaseButtonProps

/**
 * Renders a button. The type is "button" by default.
 * 
 * Whenever a button is clicked, the function `onClickButton` of the nearest CitricController is called with the event and the value of the
 * prop `metadata`.
 * 
 * @example
 * ```
 * <Button>My Button</Button>
 * ```
 */
export const Button = withRef((
  { appearance, size, feedback, loading, disabled, onClick, className, children, type = 'button', metadata, ...props }: ButtonProps,
) => {
  const citric = useCitricController()
  const [waiting, setWaiting] = useState(false)
  const busy = loading || waiting
  const isAllLowercase = useMemo(
    () => !Children.toArray(children).some(c => typeof c === 'string' && c.toLocaleLowerCase() !== c),
    [children],
  )

  async function handleClick(e: React.MouseEvent<HTMLButtonElement, MouseEvent>) {
    const result = onClick?.(e)
    citric?.onClickButton?.(e, metadata)
    if (result instanceof Promise) {
      setWaiting(true)
      try {
        await result
      } catch { /* empty */ }
      setWaiting(false)
    }
  }

  return (
    <CitricComponent
      tag="button"
      component="button"
      className={listToClass([size, appearance, isAllLowercase && 'short-text', className])}
      data-feedback={feedback || undefined}
      onClick={handleClick}
      aria-busy={busy}
      disabled={disabled || busy}
      type={type}
      {...props}
    >
      {busy ? <div>{children}</div> : children}
      {busy && (
        <div className="loader">
          <ProgressCircular size="sm" />
        </div>
      )}
    </CitricComponent>
  )
})
