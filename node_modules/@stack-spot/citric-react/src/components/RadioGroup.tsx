import { isNil } from 'lodash'
import { useMemo } from 'react'
import { WithColorScheme } from '../types'
import { defaultRenderKey, defaultRenderLabel } from '../utils/options'
import { withRef } from '../utils/react'
import { CitricComponent } from './CitricComponent'
import { Column } from './layout'

export interface BaseRadioGroupProps<T> extends WithColorScheme {
  /**
   * The field name.
   */
  name?: string,
  /**
   * The current value.
   */
  value?: T,
  /**
   * All the items (radio buttons) to render.
   */
  options: T[],
  /**
   * Called whenever the selected radio button changes.
   * @param value the currently selected item.
   */
  onChange?: (value: T) => void,
  /**
   * A function to render the item label.
   * 
   * Attention: ignored if `renderItem` is set.
   * 
   * @example
   * `(option) => option.name`
   * @default "the item's toString() result."
   * @param option the item to render.
   * @returns a React Node to render.
   */
  renderLabel?: (option: T) => React.ReactNode,
  /**
   * A function to render the item with the radio button. When set, `renderLabel` is ignored.
   * @example
   * ```
   * (radio, option) => <label>{radio} {option.name}</label>
   * ```
   * @param radio the radio button.
   * @param option the current item.
   * @returns a React Node to render.
   */
  renderItem?: (radio: React.ReactElement, option: T) => React.ReactNode,
  /**
   * A function to render the item value, a unique identifier for the option.
   * @example
   * `(option) => option.id`
   * @default "if the item is a string or a number, the stringified item. Otherwise, undefined."
   * @param option the item to compute a key for.
   * @returns a string key.
   */
  renderKey?: (option: T) => string | number | undefined,
  /**
   * If this function returns true for the item, this option is disabled.
   * @default "nothing is disabled"
   * @param option the item to calculate "disabled" for.
   * @returns true if the item should be disabled, false otherwise.
   */
  isDisabled?: (option: T) => boolean,
  /**
   * The space between options.
   * 
   * @default "8px"
   */
  gap?: string,
  /**
   * If set to false, the checkboxes will have tabIndex = -1.
   * 
   * @default true
   */
  focusable?: boolean,
}

export type RadioGroupProps<T> = Omit<React.JSX.IntrinsicElements['div'], 'onChange' | 'children'> & BaseRadioGroupProps<T>

/**
 * Renders a list of radio button for single-selection. One radio button is rendered for each option.
 * 
 * Attention: single radio buttons don't make sense, this is why they're not provided by this library.
 * 
 * This component can be heavily customized via its properties. Check the storybook for complex examples.
 * 
 * Tip: if you need to implement features like "search", use the hook `useRadioGroupControls`.
 * 
 * @example
 * 
 * ```
 * const options = useMemo(() => [
 *   { id: 1, name: 'Option 1' },
 *   { id: 2, name: 'Option 2' },
 *   { id: 3, name: 'Option 3' },
 * ], [])
 * 
 * const [value, setValue] = useState<(typeof options)[number] | undefined>()
 * 
 * return <RadioGroup options={options} renderLabel={o => o.name} renderKey={o => o.id} value={value} setValue={setValue} />
 * ```
 */
export const RadioGroup = withRef(
  function RadioGroup<T>({
    name,
    value,
    options,
    onChange,
    renderLabel = defaultRenderLabel,
    renderKey = defaultRenderKey,
    renderItem,
    isDisabled,
    colorScheme,
    gap = '8px',
    focusable = true,
    style,
    ...props
  }: RadioGroupProps<T>) {
    const items = useMemo(() => {
      const valueKey = value ? renderKey(value) : undefined
      return options.map((o) => {
        const key = renderKey(o)
        const radio = <CitricComponent
          tag="input"
          component="radio"
          type="radio"
          name={name}
          value={key}
          checked={value === o || (!isNil(key) && valueKey === key)}
          onChange={() => onChange?.(o)}
          disabled={isDisabled?.(o)}
          tabIndex={focusable ? undefined : -1}
          colorScheme={colorScheme}
        />
        return renderItem ? renderItem(radio, o) : (
          <CitricComponent tag="label" component="radio-row" key={key} colorScheme={colorScheme}>
            {radio}
            {renderLabel(o)}
          </CitricComponent>
        )
      })
    }, [options, value, name, colorScheme])
    return <Column {...props} style={{ gap, ...style }}>{items}</Column>
  },
)
