import { listToClass } from '@stack-spot/portal-theme'
import { Dictionary, useTranslate } from '@stack-spot/portal-translate'
import { createContext, Suspense, useContext, useEffect, useMemo, useState } from 'react'
import { withRef } from '../../utils/react'
import { CitricComponent } from '../CitricComponent'
import { ErrorBoundary } from '../ErrorBoundary'
import { ProgressCircular } from '../ProgressCircular'
import { Center } from '../layout'
import { TabController } from './TabController'
import { TabsProps } from './types'
import { findSelectedIndex } from './utils'

const ctx = createContext<TabController<any> | undefined>(undefined)

/**
 * Builds a Tab selector. The content of a tab is a React component and it can suspend, i.e. tabs can be asynchronously loaded.
 * 
 * @example
 * 
 * ```
 * const tabs: Tab[] = useMemo(() => [
 *   { key: 'tab1', label: 'Tab 1', content: <><h1>First tab</h1><p>Content of the first tab</p></> },
 *   { key: 'tab2', label: 'Tab 2', content: <><h1>Second tab</h1><p>Content of the second tab</p></> },
 *   { key: 'tab3', label: 'Tab 3', content: <><h1>Third tab</h1><p>Content of the third tab</p></> },
 * ], [])
 * 
 * return <Tabs tabs={tabs} />
 * ```
 */
export const Tabs = withRef(
  function Tabs<Key extends string>(
    { tabs, value, equallySized, onChange, controller: ctrl, appearance, customRenderer, className, ...props }: TabsProps<Key>,
  ) {
    const controller = useMemo(() => ctrl ?? new TabController<Key>(tabs.map(t => t.key), value || tabs[0]?.key), [])
    const t = useTranslate(dictionary)
    const [selectedIndex, setSelectedIndex] = useState(findSelectedIndex(tabs, controller.getValue()))

    useEffect(() => {
      if (value) controller.setValue(value)
    }, [value])

    useEffect(() => controller.onChange((v) => {
      setSelectedIndex(findSelectedIndex(tabs, v))
      onChange?.(v)
    }), [tabs])

    const tabSelector = useMemo(
      () => (
        <nav className="tab-selector">
          {tabs.map(({ key, label, disabled }, index) => (
            <label key={key}>
              <input
                type="radio"
                role="tab"
                checked={index === selectedIndex}
                onChange={() => controller.setValue(key)} disabled={disabled}
              />
              {label || key}
            </label>
          ))}
        </nav>
      ),
      [tabs, selectedIndex],
    )

    const content = useMemo(() => (
      <section className="tab-content">
        <ErrorBoundary key={selectedIndex} message={t.error}>
          <Suspense fallback={<Center style={{ padding: '20px' }}><ProgressCircular /></Center>}>
            {selectedIndex === -1 ? null : tabs[selectedIndex]?.content}
          </Suspense>
        </ErrorBoundary>
      </section>
    ), [selectedIndex, t])

    return (
      <ctx.Provider value={controller}>
        <CitricComponent
          tag="div"
          component="tabs"
          className={listToClass([className, equallySized && 'equally-sized', appearance])}
          {...props}
        >
          {customRenderer ? customRenderer(tabSelector, content) : <>{tabSelector}{content}</>}
        </CitricComponent>
      </ctx.Provider>
    )
  },
)

/**
 * Request the tab controller of the current context. Use this to control the tabs in the parent components. This returns undefined when
 * no tab context is found.
 */
export function useTabController<Key extends string = string>(): TabController<Key> | undefined {
  return useContext(ctx)
}

const dictionary = {
  en: {
    error: 'Error while loading the tab.',
  },
  pt: {
    error: 'Ocorreu um erro ao carregar a aba.',
  },
} satisfies Dictionary
