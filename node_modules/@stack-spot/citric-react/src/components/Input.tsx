import { ControlledInput, WithColorScheme } from '../types'
import { withRef } from '../utils/react'
import { CitricComponent } from './CitricComponent'

export type SupportedInputType = 'color' | 'date' | 'datetime-local' | 'email' | 'month' | 'number' | 'password' | 'search' | 'tel' | 
  'text' | 'time' | 'url' | 'week'

export interface BaseInputProps<T extends SupportedInputType> extends WithColorScheme {
  /**
   * @default 'text'
   */
  type?: T,
  value?: T extends 'number' ? number : string,
  onChange?: (value: T extends 'number' ? (number | undefined) : string) => void,
}

export type InputProps<T extends SupportedInputType = 'text'> = 
  ControlledInput & BaseInputProps<T> & { type?: T }

/**
 * Renders a input.
 * 
 * Attention: "onChange" doesn't receive an event, instead, it receives the new value of the input: a string, unless "type" is "number",
 * in this case, it receives a number.
 * 
 * @example
 * 
 * ```
 * const [value, setValue] = useState('')
 * 
 * return <Input value={value} onChange={setValue} />
 * ```
 */
export const Input = withRef(
  function Input<T extends SupportedInputType = 'text'>({ type, value, onChange, ...props }: InputProps<T>) {
    function handleChange(e: React.ChangeEvent<HTMLInputElement>) {
      if (!onChange) return
      const newValue = e.target.value
      if (type === 'number') {
        const parsed = newValue ? parseFloat(newValue) : undefined
        onChange(parsed as any)
      } else {
        onChange(newValue as any)
      }
    }

    return <CitricComponent tag="input" component="input" type={type} value={value} onChange={handleChange} {...props} />
  },
)
