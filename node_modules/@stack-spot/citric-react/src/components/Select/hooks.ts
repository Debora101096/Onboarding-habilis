import { useEffect } from 'react'

interface OpenPanelEffectParams {
  open: boolean,
  setOpen: React.Dispatch<React.SetStateAction<boolean>>,
  setSearch: React.Dispatch<React.SetStateAction<string | undefined>>,
  element: React.MutableRefObject<HTMLDivElement | null>,
  searchable?: boolean,
}

interface FocusEffectParams {
  element: React.MutableRefObject<HTMLDivElement | null>,
  focused: boolean,
  setFocused: React.Dispatch<React.SetStateAction<boolean>>,
  setOpen: React.Dispatch<React.SetStateAction<boolean>>,
}

interface DisabledEffectParams {
  disabled?: boolean,
  setFocused: React.Dispatch<React.SetStateAction<boolean>>,
  setOpen: React.Dispatch<React.SetStateAction<boolean>>,
}

/* this runs whenever the selection panel is opened */
export function useOpenPanelEffect({ open, setOpen, setSearch, element, searchable }: OpenPanelEffectParams) {
  useEffect(() => {
    if (open) {
      setSearch('')
      const selectionPanel = element.current?.querySelector('.selection-panel') as HTMLElement | undefined
      selectionPanel?.querySelector('.options')?.scrollTo({ top: 0 })
      const getCurrent = () => selectionPanel?.querySelector('.option.focused') as HTMLElement | undefined
      const scrollTo = (item: HTMLElement) => {
        const list = item.closest('.options')
        if (!list) return
        const { top: listTop, height: listHeight } = list.getBoundingClientRect()
        const { height: itemHeight, top: itemTop } = item.getBoundingClientRect()
        const offset = itemTop + list.scrollTop - listTop
        if ((list.scrollTop + listHeight < offset + itemHeight) || list.scrollTop > offset) {
          list.scrollTo({ top: offset })
        }
      }
      /* keyboard and mouse controls */
      const listenToMouse = (event: Event) => {
        if (!selectionPanel?.contains(event.target as HTMLElement)) {
          setOpen(false)
        }
      }
      const listenToKeyboard = (event: KeyboardEvent) => {
        const isCharacter = event.key.length === 1
        if (['Escape', 'ArrowUp', 'ArrowDown', 'Enter'].includes(event.key) ||
          (searchable && (isCharacter || event.key === 'Backspace'))) {
          event.preventDefault()
          event.stopPropagation()
        }
        if (event.key === 'Escape') setOpen(false)
        if (searchable) {
          if (isCharacter) setSearch(v => `${v}${event.key}`)
          if (event.key === 'Backspace') setSearch(v => v?.substring(0, v.length - 1))
        }
        if (event.key === 'ArrowDown') {
          const current = getCurrent()
          const next = (current?.nextElementSibling ?? selectionPanel?.querySelector('.option')) as HTMLAreaElement | undefined
          if (next) {
            current?.classList.remove('focused')
            next.classList.add('focused')
            scrollTo(next)
          }
        }
        if (event.key === 'ArrowUp') {
          const current = getCurrent()
          const prev = (
            current?.previousElementSibling ?? selectionPanel?.querySelector('.option:last-child')
          ) as HTMLAreaElement | undefined
          if (prev) {
            current?.classList.remove('focused')
            prev.classList.add('focused')
            scrollTo(prev)
          }
        }
        if (event.key === 'Enter') {
          setTimeout(() => getCurrent()?.click(), 0)
        }
      }
      // below, we wait 20ms so the same click that opened the select doesn't close it. Removing it will cause problems with selects under
      // labels.
      setTimeout(() => document.addEventListener('click', listenToMouse), 20)
      document.addEventListener('keydown', listenToKeyboard)
      return () => {
        document.removeEventListener('click', listenToMouse)
        document.removeEventListener('keydown', listenToKeyboard)
        getCurrent()?.classList.remove('focused')
      }
    }
  }, [open])
}

/* this runs whenever the select is focused */
export function useFocusEffect({ element, focused, setFocused, setOpen }: FocusEffectParams) {
  useEffect(() => {
    if (focused) {
      const listenToMouse = (event: MouseEvent) => {
        if (!element.current?.contains(event.target as HTMLElement)) {
          setFocused(false)
        }
      }
      const listenToKeyboard = (event: KeyboardEvent) => {
        if (['Enter', 'ArrowDown', 'ArrowUp'].includes(event.key)) {
          event.preventDefault()
          if (!element.current?.classList.contains('open')) setOpen(true)
        }
        if (event.key === 'Tab') {
          setFocused(false)
          if (element.current?.classList.contains('open')) setOpen(false)
        }
      }
      document.addEventListener('click', listenToMouse)
      document.addEventListener('keydown', listenToKeyboard)
      return () => {
        document.removeEventListener('click', listenToMouse)
        document.removeEventListener('keydown', listenToKeyboard)
      }
    }
  }, [focused])
}

export function useDisabledEffect({ disabled, setOpen, setFocused }: DisabledEffectParams) {
  useEffect(() => {
    if (disabled) {
      setOpen(false)
      setFocused(false)
    }
  }, [disabled])
}
