import { isNil } from 'lodash'
import { useMemo } from 'react'
import { WithColorScheme } from '../types'
import { defaultRenderKey, defaultRenderLabel } from '../utils/options'
import { withRef } from '../utils/react'
import { CitricComponent } from './CitricComponent'
import { Column } from './layout'

export interface BaseCheckboxGroupProps<T = any> extends WithColorScheme {
  /**
   * "checkbox" for common check boxes, "switch" for toggles.
   * @default 'checkbox'
   */
  appearance?: 'checkbox' | 'switch',
  /**
   * The field name.
   */
  name?: string,
  /**
   * All items corresponding to the selected checkboxes.
   */
  value: T[],
  /**
   * All the items (checkboxes) to render.
   */
  options: T[],
  /**
   * Called whenever the selected checkboxes changes.
   * @param value the currently selected items.
   */
  onChange: (value: T[]) => void,
  /**
   * A function to render the item label.
   * 
   * Attention: ignored if `renderItem` is set.
   * 
   * @example
   * `(option) => option.name`
   * @default "the item's toString() result."
   * @param option the item to render.
   * @returns a React Node to render.
   */
  renderLabel?: (option: T) => React.ReactNode,
  /**
   * A function to render the item with the checkbox. When set, `renderLabel` is ignored.
   * @example
   * ```
   * (checkbox, option) => <label>{checkbox} {option.name}</label>
   * ```
   * @param checkbox the checkbox.
   * @param option the current item.
   * @returns a React Node to render.
   */
  renderItem?: (checkbox: React.ReactElement, option: T) => React.ReactNode,
  /**
   * A function to render the item value, a unique identifier for the option.
   * @example
   * `(option) => option.id`
   * @default "if the item is a string or a number, the stringified item. Otherwise, undefined."
   * @param option the item to compute a key for.
   * @returns a string key.
   */
  renderKey?: (option: T) => string | number | undefined,
  /**
   * If this function returns true for the item, this option is disabled.
   * @default "nothing is disabled"
   * @param option the item to calculate "disabled" for.
   * @returns true if the item should be disabled, false otherwise.
   */
  isDisabled?: (option: T) => boolean,
  /**
   * The space between options.
   * 
   * @default "8px"
   */
  gap?: string,
  /**
   * If set to false, the checkboxes will have tabIndex = -1.
   * 
   * @default true
   */
  focusable?: boolean,
}

export type CheckboxGroupProps<T> = Omit<React.JSX.IntrinsicElements['div'], 'onChange' | 'children'> & BaseCheckboxGroupProps<T>

/**
 * Renders a list of checkbox for multi-selection. One checkbox is rendered for each option.
 * 
 * This component can be heavily customized via its properties. Check the storybook for complex examples.
 * 
 * Tip: if you need to implement features like "search" and "select all", use the hook `useCheckboxGroupControls`.
 * 
 * Tip: If you need a checkbox group that doesn't occupy much height, consider using a MultiSelect.
 * 
 * @example
 * 
 * ```
 * const options = useMemo(() => [
 *   { id: 1, name: 'Option 1' },
 *   { id: 2, name: 'Option 2' },
 *   { id: 3, name: 'Option 3' },
 * ], [])
 * 
 * const [value, setValue] = useState<typeof options>([])
 * 
 * return <CheckboxGroup options={options} renderLabel={o => o.name} renderKey={o => o.id} value={value} setValue={setValue} />
 * ```
 */
export const CheckboxGroup = withRef(
  function CheckboxGroup<T>({
    appearance = 'checkbox',
    name,
    value = [],
    options,
    onChange,
    renderLabel = defaultRenderLabel,
    renderKey = defaultRenderKey,
    renderItem,
    isDisabled,
    colorScheme,
    style,
    gap = '8px',
    focusable = true,
    ...props
  }: CheckboxGroupProps<T>) {
    const items = useMemo(() => {
      const valueKeys = value.map(renderKey)
      return options.map((o) => {
        const key = renderKey(o)
        const checkbox = <CitricComponent
          tag="input"
          component={appearance}
          type="checkbox"
          name={name}
          value={key}
          checked={value.includes(o) || (!isNil(key) && valueKeys.includes(key))}
          onChange={(e) => onChange?.(e.target.checked ? [...(value ?? []), o] : (value?.filter(item => item != o) ?? []))}
          disabled={isDisabled?.(o)}
          tabIndex={focusable ? undefined : -1}
          colorScheme={colorScheme}
        />
        return renderItem ? renderItem(checkbox, o) : (
          <CitricComponent tag="label" component={`${appearance}-row`} key={key} colorScheme={colorScheme}>
            {checkbox}
            {renderLabel(o)}
          </CitricComponent>
        )
      })
    }, [options, value, name, colorScheme, appearance])
    return <Column {...props} style={{ gap, ...style }}>{items}</Column>
  },
)
