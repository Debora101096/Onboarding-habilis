import { MutableRefObject, useEffect, useLayoutEffect } from 'react'
import { useCitricController } from '../context/hooks'
import { LoadingStyle } from '../types'
import { withRef } from '../utils/react'
import { ErrorMessage } from './ErrorMessage'
import { LoadingPanel } from './LoadingPanel'

interface Props {
  /**
   * Whether or not to show the loading feedback.
   */
  loading: boolean,
  /**
   * A javascript error. Used to show error feedbacks.
   */
  error?: any,
  /**
   * If provided, this element will receive focus as soon as the content is loaded and has no errors.
   * Can be either a React Ref Object or a query selector.
   */
  autofocus?: string | MutableRefObject<HTMLElement>,
  /**
   * The content to show if it's not loading or has errors.
   */
  children: React.ReactNode,
  /**
   * Customizes the loading component.
   */
  loadingStyle?: LoadingStyle,
}

/**
 * Renders a component that provides user feedback on async requests. It renders either a loading component, an error component or its
 * children.
 * 
 * The loading and error views can be customized through a CitricController.
 * 
 * Errors can be watched through the function `onError` of a CitricController.
 * 
 * Attention: for React Suspense, use the component "FallbackBoundary" instead.
 * 
 * @example
 * 
 * ```
 * const [data, isLoading, error] = useRemoteData()
 * 
 * return (
 *   <AsyncContent loading={isLoading} error={error}>
 *     {data}
 *   </AsyncContent>
 * )
 * ```
 */

export const AsyncContent = withRef(({ loading, error, autofocus, children, loadingStyle }: Props) => {
  const citric = useCitricController()

  useEffect(() => {
    if (error) {
      citric?.onError?.(error)
      // eslint-disable-next-line no-console
      console.error(error)
    }
  }, [error])

  useLayoutEffect(() => {
    if (!loading && !error) {
      typeof autofocus === 'string' ? (document.querySelector(autofocus) as HTMLElement)?.focus?.() : autofocus?.current?.focus()
    }
  }, [loading, error])

  if (loading) return citric?.renderLoading ? citric.renderLoading(loadingStyle) : <LoadingPanel {...loadingStyle} />
  if (error) return citric?.renderError ? citric.renderError(error) : <ErrorMessage error={error} />
  return children
})
