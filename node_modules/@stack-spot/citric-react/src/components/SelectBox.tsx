import { listToClass } from '@stack-spot/portal-theme'
import { useMemo } from 'react'
import { WithColorPalette, WithColorScheme } from '../types'
import { defaultRenderKey, defaultRenderLabel } from '../utils/options'
import { withRef } from '../utils/react'
import { CitricComponent } from './CitricComponent'
import { layout } from './layout'

export interface SelectBoxLabel {
  icon?: React.ReactElement,
  title: string,
  description?: string,
}

export interface CommonSelectBoxProps<T> extends WithColorPalette, WithColorScheme {
  /**
   * If multiple is true, checkboxes will be rendered instead of radio buttons.
   * 
   * @default false
   */
  multiple?: boolean,
  /**
   * The name for all checkboxes or radio buttons.
   */
  name?: string,
  /**
   * The options to show as select boxes.
   */
  options: T[],
  /**
   * A function that returns the data to render a select box for an option.
   * 
   * @default "extracts the title by converting the option to a string"
   */
  renderLabel?: (option: T) => SelectBoxLabel,
  /**
   * A function that returns a unique identifier for an option.
   * 
   * @default "if the option is a string, uses it as the key. Otherwise, the key won't be specified."
   */
  renderKey?: (option: T) => string | number | undefined,
  /**
   * A function that receives an option and decides if it's disabled or not.
   */
  isDisabled?: (option: T) => boolean,
  /**
   * Whether to render a row (horizontal) or a column (vertical).
   * 
   * @default 'horizontal'
   */
  direction?: 'horizontal' | 'vertical',
  /**
   * The background color level.
   * 
   * @default 300
   */
  bgLevel?: 300 | 400 | 500 | 600 | 700,
  /**
   * The appearance of each option.
   * 
   * Attention: the appearance "button" hides the description text.
   * 
   * @default 'box'
   */
  appearance?: 'box' | 'button',
}

interface CheckboxProps<T> extends CommonSelectBoxProps<T> {
  multiple: true,
  value?: T[],
  onChange?: (value: T[]) => void,
}

interface RadioProps<T> extends CommonSelectBoxProps<T> {
  multiple?: false,
  value?: T,
  onChange?: (value: T) => void,
}

export type BaseSelectBoxProps<T> = RadioProps<T> | CheckboxProps<T>

export type SelectBoxProps<T> = Omit<React.JSX.IntrinsicElements['div'], 'onChange' | 'children'> & BaseSelectBoxProps<T>

/**
 * This component does exactly the same thing as "CheckboxGroup" and "RadioGroup", but with different visuals and less customization.
 * 
 * Each option is rendered as a selectable card. The user can select a single option (radio buttons) or multiple options (checkboxes),
 * depending on the value of the property "multiple", which is false by default.
 * 
 * Use `renderLabel` to determine what to render inside each card. This is not a free react element, it must return an object containing an
 * icon, a title and a description.
 * 
 * @example
 * 
 * ```
 * const options = useMemo(() => [
 *   { id: 1, image: 'https://images.com/1.png', name: 'Basic plan', price: 59 },
 *   { id: 2, image: 'https://images.com/2.png', name: 'Gold plan', price: 69 },
 *   { id: 3, image: 'https://images.com/3.png', name: 'Safira plan', price: 79' },
 *   { id: 4, image: 'https://images.com/4.png', name: 'Diamond plan', price: 99 },
 * ], [])
 * 
 * return <SelectBox
 *   options={options}
 *   renderKey={o => o.id}
 *   renderLabel={o => ({
 *     icon: <img src={o.image} />,
 *     title: o.name,
 *     description: `$${price.toFixed(2)}`,
 *   })}
 * />
 * ```
 */
export const SelectBox = withRef(
  function SelectBox<T>({
    multiple,
    name,
    value,
    options,
    onChange,
    renderLabel = o => ({ title: defaultRenderLabel(o) }),
    renderKey = defaultRenderKey,
    isDisabled,
    className,
    style,
    direction,
    bgLevel,
    colorPalette,
    colorScheme,
    appearance,
    ...props
  }: SelectBoxProps<T>) {
    const items = useMemo(() => {
      const valueAsArray = value ? (Array.isArray(value) ? value : [value]) : []
      const valueKeys = valueAsArray.map(renderKey)
      return options.map((o) => {
        const key = renderKey(o)
        const label = renderLabel(o)
        const checked = value ? valueKeys.includes(key) : undefined
        return (
          <CitricComponent key={key} tag="label" component="select-box" className={listToClass([bgLevel && `bg-${bgLevel}`, appearance])}>
            <input
              // Fixes a super weird bug that happens only when rendering this component in an external project (not in Storybook). The bug
              // prevents the initially checked option from ever being unchecked. By attaching this key to the checked attribute, we can
              // guarantee this input will always be destroyed and reconstructed whenever the value changes.
              key={`${key}-${checked}`}
              type={multiple ? 'checkbox' : 'radio'}
              name={name}
              value={key}
              checked={checked}
              disabled={isDisabled?.(o)}
              onChange={onChange ? (e) => {
                if (multiple) {
                  onChange(e.target.checked ? [...valueAsArray, o] : valueAsArray.filter(v => renderKey(v) !== key)) 
                } else {
                  onChange(o)
                }
              } : undefined}
            />
            <div className="option">
              {label.icon}
              <p className="title">{label.title}</p>
              {label.description && appearance !== 'button' && <p className="description">{label.description}</p>}
            </div>
          </CitricComponent>
        )
      })
    }, [options, value, name, multiple, bgLevel, appearance])
    return (
      <div
        data-color-palette={colorPalette}
        data-color-scheme={colorScheme}
        className={listToClass([className, direction === 'vertical' ? layout.column : layout.row])}
        style={{ gap: '5px', ...style }}
        {...props}
      >
        {items}
      </div>
    )
  },
)
