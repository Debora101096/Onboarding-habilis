const selectors = {
    a: 'a[href]:not(:disabled)',
    button: 'button:not(:disabled)',
    input: 'input:not(:disabled):not([type="hidden"])',
    select: 'textarea:not(:disabled)',
    textarea: 'select:not(:disabled)',
    other: '[tabindex]:not([tabindex="-1"])',
};
/**
 * Focus the first focusable child of the element provided. If the element has no focusable child, nothing happens.
 *
 * A priority list can be passed in the second parameter, as an option. If it's provided, it will focus the first element according to the
 * list.
 *
 * An ignore query selector can also be passed in the options parameter. If the first focusable element matches the query selector, the
 * next element is focused instead.
 *
 * Elements with `auto-focus={false}` will be ignored.
 *
 * @example
 * Suppose the children of element are: h1, button, p, input, select.
 * 1. We don't pass a priority list. The focused element will be the button.
 * 2. Our priority list is ['button']. The focused element will be the button.
 * 3. Our priority list is ['input', 'button']. The focused element will be the input.
 * 4. Our priority list is ['select', 'input']. The focused element will be the select.
 * 5. Our priority list is [['select', 'input'], 'button']. The focused element will be the input.
 *
 * @param element the element to search a child to focus.
 * @param options optional.
 */
export function focusFirstChild(element, { priority = [], ignore } = {}) {
    const allFocusableTags = ['a', 'button', 'input', 'other', 'select', 'textarea'];
    const focusableList = [
        element?.querySelectorAll(allFocusableTags.map(t => selectors[t]).join(', ')),
    ];
    for (const p of priority) {
        const tags = Array.isArray(p) ? p : [p];
        const querySelectors = tags.map(t => selectors[t]);
        focusableList.unshift(element?.querySelectorAll(querySelectors.join(', ')));
    }
    for (const focusable of focusableList ?? []) {
        for (const f of focusable ?? []) {
            if (f.getAttribute('auto-focus') !== 'false' && (!ignore || !f.matches(ignore))) {
                const styles = window.getComputedStyle(f);
                if (styles.display != 'none' && styles.visibility != 'hidden')
                    return f.focus();
            }
        }
    }
}
/**
 * Checks if an element can receive focus.
 *
 * Elements can receive focus only if:
 * - they exist;
 * - they're visible;
 * - they're not disabled;
 * - they are a focusable tag name or have a positive tab index;
 * - they don't have a negative tab index.
 * @param element the element to check.
 * @returns true if the element is focusable, false otherwise.
 */
export function isFocusable(element) {
    if (!element)
        return false;
    // is disabled: return false
    if (element.ariaDisabled || element.getAttribute('disabled') !== null)
        return false;
    // is invisible: return false
    if (!element.checkVisibility({ checkOpacity: true, checkVisibilityCSS: true }))
        return false;
    // has tab index: return false if negative, true otherwise
    const tabIndexStr = element.getAttribute('tabindex');
    const tabIndex = tabIndexStr ? parseInt(tabIndexStr) : undefined;
    if (tabIndex !== undefined)
        return tabIndex >= 0;
    // check the tag name
    return ['a', 'button', 'input', 'iframe', 'select', 'textarea'].includes(element.tagName.toLowerCase() ?? '');
}
//# sourceMappingURL=acessibility.js.map