import { listToClass, theme } from '@stack-spot/portal-theme';
import { isNil, omit, omitBy } from 'lodash';
export function colorNameToColorVariable(name) {
    return `var(--${name.replaceAll('.', '-')})`;
}
export function applyColor(style, color) {
    return color ? { ...style, color: colorNameToColorVariable(color) } : style;
}
export function textAppearanceToClass(appearance) {
    return `text-${appearance}`;
}
export function applyTextAppearance(className, appearance) {
    return listToClass([className, appearance ? textAppearanceToClass(appearance) : undefined]);
}
export function applyCSSVariable(style, name, value) {
    if (isNil(value))
        return style;
    return { ...style, [`--${name}`]: `${value}` };
}
export function applyCSSVariables(style, vars) {
    const newStyle = { ...style };
    for (const variable of vars) {
        if (!variable)
            continue;
        newStyle[`--${variable.name}`] = variable.value;
    }
    return newStyle;
}
function spacingToStyle(spacing) {
    if (typeof spacing === 'string')
        return spacing;
    if (typeof spacing === 'number')
        return theme.spacing[spacing];
    return spacing?.map(s => theme.spacing[s]).join(' ');
}
export function getStyleFromProps({ bg, fg, border, radius, justifyContent, alignItems, flex, gap, m, mt, mb, ml, mr, p, pt, pb, pl, pr, w, h, }) {
    const [bgColor, bgLevel] = bg?.split('.') ?? [];
    const [fgColor, fgLevel] = fg?.split('.') ?? [];
    const [borderColor, borderLevel] = border?.split('.') ?? [];
    const borderColorVar = theme.color[borderColor]?.[borderLevel];
    const newStyle = {
        backgroundColor: theme.color[bgColor]?.[bgLevel],
        color: theme.color[fgColor]?.[fgLevel],
        border: borderColorVar ? `1px solid ${borderColorVar}` : undefined,
        borderRadius: radius ? theme.radius[radius] : undefined,
        justifyContent,
        alignItems,
        flex,
        gap,
        margin: spacingToStyle(m),
        marginTop: spacingToStyle(mt),
        marginBottom: spacingToStyle(mb),
        marginLeft: spacingToStyle(ml),
        marginRight: spacingToStyle(mr),
        padding: spacingToStyle(p),
        paddingTop: spacingToStyle(pt),
        paddingBottom: spacingToStyle(pb),
        paddingLeft: spacingToStyle(pl),
        paddingRight: spacingToStyle(pr),
        width: w,
        height: h,
    };
    return omitBy(newStyle, v => v === undefined);
}
export function applyStyles({ style, ...props }) {
    const styleShortcutKeys = [
        'bg', 'fg', 'border', 'radius', 'justifyContent', 'alignItems', 'flex', 'gap', 'm', 'mt', 'mb', 'ml', 'mr', 'p', 'pt', 'pb', 'pl',
        'pr', 'w', 'h',
    ];
    const newStyle = getStyleFromProps(props);
    return { style: { ...newStyle, ...style }, ...omit(props, styleShortcutKeys) };
}
// AI generated
export function styleObjectToCssString(styleObject = {}) {
    return Object.entries(styleObject)
        .map(([property, value]) => {
        // Convert camelCase to kebab-case
        const cssProperty = property.replace(/([A-Z])/g, '-$1').toLowerCase();
        // Append 'px' to numeric values for common dimension properties
        const cssValue = typeof value === 'number' &&
            !['zIndex', 'opacity', 'fontWeight', 'flex', 'flexGrow', 'flexShrink', 'flexBasis'].includes(property)
            ? `${value}px`
            : value;
        return `${cssProperty}: ${cssValue}`;
    })
        .join('; ');
}
//# sourceMappingURL=css.js.map