import { Component } from 'react';
import { CitricContext } from '../context/CitricContext.js';
interface State {
    error?: any;
}
interface Props {
    children: React.ReactNode;
    /**
     * Sets a default error string when a string is provided.
     *
     * Replaces the error component, if a function is provided.
     */
    message?: React.ReactNode | ((error: any) => React.ReactNode);
}
/**
 * An Error Boundary that renders an error feedback instead of its content if any of its children throws.
 *
 * You can customize the appearance of the error through the function `renderError` of a CitricController.
 *
 * Errors can be watched through the function `onError` of a CitricController.
 *
 * Attention: if you're using React Suspense, consider using the component "FallbackBoundary" instead.
 *
 * @example
 * ```
 * <ErrorBoundary>
 *   {content}
 * </ErrorBoundary>
 * ```
 */
export declare class ErrorBoundary extends Component<Props, State> {
    static contextType: import("react").Context<import("../index.js").CitricController | undefined>;
    context: React.ContextType<typeof CitricContext>;
    constructor(props: Props);
    static getDerivedStateFromError(error: any): {
        error: any;
    };
    componentDidCatch(error: any, errorInfo: any): void;
    componentDidUpdate(prevProps: Readonly<Props>): void;
    private renderCustomErrorUI;
    private renderErrorUI;
    render(): string | number | boolean | Iterable<import("react").ReactNode> | import("react/jsx-runtime").JSX.Element | null | undefined;
}
export {};
//# sourceMappingURL=ErrorBoundary.d.ts.map