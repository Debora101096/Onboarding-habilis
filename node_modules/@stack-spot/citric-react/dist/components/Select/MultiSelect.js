import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { listToClass } from '@stack-spot/portal-theme';
import { useTranslate } from '@stack-spot/portal-translate';
import { useEffect, useMemo, useRef, useState } from 'react';
import { useCheckboxGroupControls } from '../../utils/checkbox.js';
import { applyCSSVariable } from '../../utils/css.js';
import { defaultRenderKey, defaultRenderLabel } from '../../utils/options.js';
import { withRef } from '../../utils/react.js';
import { Checkbox } from '../Checkbox.js';
import { CheckboxGroup } from '../CheckboxGroup.js';
import { CitricComponent } from '../CitricComponent.js';
import { Input } from '../Input.js';
import { Row } from '../layout.js';
import { ProgressCircular } from '../ProgressCircular.js';
import { useDisabledEffect, useFocusEffect, useOpenPanelEffect } from './hooks.js';
/**
 * A component that looks like a Select and behaves like a CheckboxGroup. This is a component that lets the user select multiple options
 * in a list.
 *
 * Differently than then the component Select, this does not render the native select of the browser. Instead, it renders a series of
 * checkboxes.
 *
 * @example
 *
 * ```
 * const options = useMemo(() => [
 *   { id: 1, name: 'Option 1' },
 *   { id: 2, name: 'Option 2' },
 *   { id: 3, name: 'Option 3' },
 * ], [])
 *
 * const [value, setValue] = useState<typeof options>([])
 *
 * return <MultiSelect options={options} renderLabel={o => o.name} renderKey={o => o.id} value={value} setValue={setValue} />
 * ```
 */
export const MultiSelect = withRef(function MultiSelect({ ref, options, value = [], onChange, renderLabel = defaultRenderLabel, renderKey = defaultRenderKey, disabled, loading, renderOption, renderHeader, searchable, maxHeight, style, className, showArrow, placeholder, showSelectAll, ...props }) {
    const t = useTranslate(dictionary);
    const _element = useRef(null);
    const element = ref ?? _element;
    const [open, setOpen] = useState(false);
    const [focused, setFocused] = useState(false);
    const controls = useCheckboxGroupControls({
        options,
        renderKey,
        initialValue: value,
        onChange,
        applyFilter: (filter, option) => renderLabel(option).toLocaleLowerCase().includes(filter.toLocaleLowerCase()),
    });
    useOpenPanelEffect({ open, setOpen, setSearch: controls.setFilter, element, searchable });
    useFocusEffect({ element, focused, setFocused, setOpen });
    useDisabledEffect({ disabled, setOpen, setFocused });
    useEffect(() => {
        if (value !== controls.value)
            controls.setValue(value);
    }, [value.map(renderKey).join(',')]);
    const header = useMemo(() => {
        if (value.length === 0)
            return _jsx("span", { className: "placeholder header-text", children: placeholder });
        const reversed = [...value].reverse();
        return ((renderHeader?.(reversed)
            ?? (renderOption
                ? _jsx(Row, { className: "header-text", children: reversed.map(renderOption) })
                : _jsx("span", { className: "header-text", children: reversed.map(renderLabel).join(', ') }))) || _jsx("span", {}));
    }, [value, placeholder]);
    return (_jsxs(CitricComponent, { tag: "div", component: "multi-select", style: maxHeight ? applyCSSVariable(style, 'max-height', `${maxHeight}px`) : style, className: listToClass([
            className,
            showArrow === false && 'hide-arrow',
            open && 'open',
            focused && 'focused',
            disabled && 'disabled',
        ]), ref: element, "aria-busy": loading, ...props, children: [_jsxs("header", { onClick: () => {
                    if (disabled)
                        return;
                    setFocused(true);
                    setOpen(true);
                }, onFocus: () => setFocused(true), "aria-label": t.accessibilityHelp, tabIndex: disabled ? undefined : 0, className: renderHeader ? 'custom' : undefined, children: [header, loading && _jsx(ProgressCircular, { size: "xs", className: "loader" })] }), _jsxs("div", { className: "selection-panel", "aria-hidden": !open, ...(open ? {} : { inert: 'true' }), children: [searchable && _jsx("div", { className: "search-bar", children: _jsxs("div", { "data-citric": "field-group", className: "auto", children: [_jsx("i", { "data-citric": "icon-box", className: "citric-icon outline Search" }), _jsx(Input, { type: "search", value: controls.filter, onChange: controls.setFilter, "aria-label": t.searchAccessibility })] }) }), showSelectAll && (_jsx(Checkbox, { className: "select-all", onChange: checked => checked ? controls.selectAll() : controls.removeSelection(), value: controls.isAllSelected, children: controls.isAllSelected ? t.removeSelection : t.selectAll })), _jsx(CheckboxGroup, { className: "options", gap: "0", options: controls.options, onChange: controls.setValue, value: controls.value, renderKey: controls.renderKey, focusable: false, renderItem: (checkbox, option) => (_jsxs(CitricComponent, { component: "checkbox-row", tag: "label", className: listToClass(['option', controls.isUnfilteredButChecked(option) && 'unfiltered']), children: [checkbox, renderOption?.(option) ?? renderLabel(option)] })) })] })] }));
});
const dictionary = {
    en: {
        accessibilityHelp: 'Press the arrow down to select multiple options',
        searchAccessibility: 'Filter the options',
        removeSelection: 'Remove selection',
        selectAll: 'Select all',
    },
    pt: {
        accessibilityHelp: 'Pressione a seta para baixo para selecionar múltiplas opções',
        searchAccessibility: 'Filtre as opções',
        removeSelection: 'Remover seleção',
        selectAll: 'Selecionar todos',
    },
};
//# sourceMappingURL=MultiSelect.js.map