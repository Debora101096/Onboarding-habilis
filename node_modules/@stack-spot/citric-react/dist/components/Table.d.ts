export interface BaseTableProps {
    /**
     * The overall table's appearance. Includes a default configuration for every other styling related prop.
     *
     * @default 'spaced'
     */
    appearance?: 'stripped' | 'spaced';
    /**
     * Whether or not to color each row a different color. Only valid when appearance is "spaced".
     *
     * @default false
     */
    stripped?: boolean;
    /**
     * If true, there's no spacing between rows. Only valid when appearance is "spaced".
     *
     * @default false
     */
    compressed?: boolean;
    /**
     * Shows an outer border for the whole table.
     *
     * @default "true if appearance is 'stripped', false otherwise"
     */
    showBorders?: boolean;
    /**
     * Shows borders in each of the rows.
     *
     * @default false
     */
    showRowBorders?: boolean;
    /**
     * Shows borders in the header.
     *
     * @default "false if appearance is 'stripped', true otherwise"
     */
    showHeaderBorders?: boolean;
    /**
     * Whether or not the table borders are rounded.
     *
     * @default true
     */
    rounded?: boolean;
    /**
     * Whether or not each row in the table have rounded borders.
     *
     * @default "false if appearance is 'stripped', true otherwise"
     */
    roundedRows?: boolean;
    /**
     * If true, all headers are uppercase.
     *
     * @default false
     */
    uppercaseHeader?: boolean;
    /**
     * Allows rows to act as accordions. To create an accordion row, use `<tbody>` to group two `<tr>` elements, where the first is the actual
     * row and the second is the collapsible content of the row. The row with the collapsible content must be defined as `<Tr accordion>`.
     *
     * @default false
     */
    accordionRows?: boolean;
}
export type SortingDirection = 'asc' | 'desc';
interface BaseThProps {
    /**
     * Which is the current direction of the sorting? Only relevant if 'onSort' is set.
     *
     * @default 'desc'
     */
    direction?: SortingDirection;
    /**
     * What to do when the header is clicked (sorting).
     */
    onSort?: (value: SortingDirection | undefined) => void;
}
interface BaseTrProps {
    /**
     * True if this table is an accordion, false otherwise.
     *
     * @default false
     */
    accordion?: boolean;
    /**
     * If the next row is an accordion, what should make it expand or contract? A click on a button in the last column or a click anywhere in
     * the row?
     *
     * @default 'button'
     */
    accordionTrigger?: 'button' | 'row';
    /**
     * Sets the maximum height of this accordion. Only valid if `accordion` is true.
     *
     * @default '200px'
     */
    accordionMaxHeight?: string;
}
export type TableProps = React.JSX.IntrinsicElements['table'] & BaseTableProps;
export type ThProps = React.JSX.IntrinsicElements['th'] & BaseThProps;
export type TrProps = React.JSX.IntrinsicElements['tr'] & BaseTrProps;
/**
 * Renders an HTML table. Use its props for customizing the appearance.
 *
 * - If you need to use Accordion rows, use `<Tr>`instead of `<tr>`.
 * - If you need to sort columns, use `<Th>`instead of `<th>`.
 *
 * This works exactly like the HTML tag "table".
 *
 * Attention: prefer using the component "SmartTable". Use this only if you need full control over the table.
 */
export declare const Table: ({ appearance, stripped, compressed, showBorders, showHeaderBorders, showRowBorders, rounded, roundedRows, uppercaseHeader, className, children, accordionRows, ...props }: TableProps) => import("react/jsx-runtime").JSX.Element;
export declare const Th: ({ direction, onSort, children, className, ...props }: ThProps) => import("react/jsx-runtime").JSX.Element;
export declare const Tr: ({ ref: outerRef, accordion, accordionTrigger, accordionMaxHeight, children, className, style, onClick, ...props }: TrProps) => import("react/jsx-runtime").JSX.Element;
export {};
//# sourceMappingURL=Table.d.ts.map