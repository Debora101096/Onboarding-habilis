import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { listToClass } from '@stack-spot/portal-theme';
import { useTranslate } from '@stack-spot/portal-translate';
import { createElement, useEffect, useMemo } from 'react';
import { ValueController } from '../../utils/ValueController.js';
import { CitricComponent } from '../CitricComponent.js';
import { IconButton } from '../IconBox.js';
import { useOverlayController } from '../Overlay/context.js';
import { MenuProvider, useMenuController, useMenuState } from './context.js';
import { keyboardNavigation } from './keyboard.js';
// Arbitrary time (ms) to wait before running a function that needs the view to be updated with the next state value.
const RENDER_DELAY = 20;
function Submenu({ children, label, className, icon, iconRight, style }) {
    const controller = useMenuController();
    return (_jsxs("button", { className: listToClass([className, 'submenu']), style: style, onClick: (e) => {
            e.stopPropagation();
            const menu = e.target instanceof HTMLElement ? e.target.closest('[data-citric="menu"]') : undefined;
            controller?.setValue({ items: children, label, parent: controller?.getValue() });
            const isOpenedWithMouse = e.detail > 0;
            if (!isOpenedWithMouse) {
                setTimeout(() => {
                    const firstFocusable = menu?.querySelector('a, button');
                    if (firstFocusable instanceof HTMLElement)
                        firstFocusable.focus();
                }, RENDER_DELAY);
            }
        }, children: [icon, _jsx("span", { children: label }), iconRight] }));
}
function MenuSection({ children, label, className, style }) {
    return (_jsxs("section", { className: className, style: style, children: [label && _jsx("h6", { children: label }), _jsx("nav", { children: _jsx(MenuItems, { items: children }) }), !label && _jsx("hr", {})] }));
}
function MenuAction({ label, active, href, icon, iconRight, className, onClick, ...props }) {
    const overlayController = useOverlayController();
    const children = _jsxs(_Fragment, { children: [icon, typeof label === 'string' ? _jsx("span", { children: label }) : label.element, iconRight] });
    return createElement(href ? 'a' : 'button', {
        href,
        'aria-label': typeof label === 'string' ? label : label.id,
        className: listToClass([className, active && 'active']),
        onClick: (e) => {
            overlayController?.close();
            onClick?.(e);
        },
        ...props,
    }, children);
}
function hasSections(items) {
    return items.some(i => 'children' in i && i.children.length && i.type === 'section');
}
function hasSubmenus(items) {
    return items.some(i => 'children' in i && i.children.length && i.type === 'collapsible');
}
function MenuItems({ items }) {
    return useMemo(() => items.map((item, index) => {
        if ('children' in item && item.type === 'section')
            return _jsx(MenuSection, { ...item }, item.label || index);
        if ('children' in item && item.type === 'collapsible')
            return _jsx(Submenu, { ...item }, item.label || index);
        return _jsx(MenuAction, { ...item }, (typeof item.label === 'string' ? item.label : item.label?.id) || index);
    }), [items]);
}
/**
 * TODO: make the height changes animated.
 */
export function Menu({ items, appearance, bgLevel, header, roundedItems, showBorders, showShadows, spaced, className, onKeyDown, ...props }) {
    const controller = useMemo(() => new ValueController({ items }), []);
    const current = useMenuState(controller);
    const { sectioned, collapsible } = useMemo(() => ({ sectioned: hasSections(current.items), collapsible: hasSubmenus(current.items) }), [current.items]);
    const tag = header || sectioned || collapsible ? 'div' : 'nav';
    const t = useTranslate(dictionary);
    useEffect(() => {
        if (items !== controller.getValue().items)
            controller.setValue({ items });
    }, [items]);
    return (_jsx(MenuProvider, { value: controller, children: _jsxs(CitricComponent, { tag: tag, component: "menu", className: listToClass([
                className, appearance, roundedItems && 'rounded-items', showBorders && 'bordered', showShadows === false && 'no-shadow',
                spaced && 'spaced', bgLevel && `bg-${bgLevel}`,
            ]), onKeyDown: (e) => {
                keyboardNavigation(e);
                onKeyDown?.(e);
            }, ...props, children: [header && _jsx("header", { children: header }), current.parent && (_jsxs("div", { className: "back-button", children: [_jsx(IconButton, { icon: "ArrowLeft", "aria-label": t.goBack, onClick: (e) => {
                                e.stopPropagation();
                                const menu = e.target instanceof HTMLElement ? e.target.closest('[data-citric="menu"]') : undefined;
                                if (current.parent)
                                    controller.setValue(current.parent);
                                setTimeout(() => {
                                    const lastItem = Array.from(menu?.querySelectorAll('a, button') ?? []).find(el => el.textContent === current.label);
                                    if (lastItem instanceof HTMLElement)
                                        lastItem.focus();
                                }, RENDER_DELAY);
                            } }), _jsx("span", { children: current.label || t.goBack })] })), sectioned ? _jsx(MenuItems, { items: current.items }) : _jsx("nav", { children: _jsx(MenuItems, { items: current.items }) })] }) }));
}
const dictionary = {
    en: {
        goBack: 'Go back',
    },
    pt: {
        goBack: 'Voltar',
    },
};
//# sourceMappingURL=Menu.js.map