import { jsx as _jsx } from "react/jsx-runtime";
import { useEffect, useRef } from 'react';
import { showOverlay } from '../../overlay.js';
import { focusFirstChild } from '../../utils/acessibility.js';
import { delay } from '../../utils/time.js';
import { OverlayProvider } from './context.js';
export { useOverlayController } from './context.js';
/**
 * An arbitrary time to wait for the next React render to be performed
 */
const arbitraryRenderTime = 20;
/**
 * These todos are in order of priority.
 *
 * TODO: update position when the size changes. Currently, the top position seems out of place whenever the height changes. The same is
 * probably true for the left position if the width changes.
 * TODO (minor): use React Portal to implement overlays. The current implementation will lose every React context in the tree.
 */
/**
 * Creates an overlay for the child component. The overlay can be any React element. The overlay can be triggered by "click" or "hover"
 * (default).
 *
 * The overlay can be hidden from within its content through the hook `useOverlayController()`.
 *
 * @example
 *
 * ```
 * const overlay = <Card>Hey, this is my overlay!</Card>
 *
 * return (
 *   <Overlay content={overlay} attributes={{ style: { margin: '20px' } }}>
 *     <Button>Hover to see the overlay</Button>
 *   </Overlay>
 * )
 * ```
 */
export function Overlay({ tag, children, content, position = 'top', triggerOn = 'hover', alignment = 'center', attributes, onRenderChild, autoFocusBehavior = 'keyboard', openDelayMS, closeDelayMS, ...props }) {
    const controller = useRef({ close: () => Promise.resolve() });
    const wrapper = useRef(null);
    // props that don't require removing and reattaching the event listeners
    const dynamic = useRef({ tag, content, position, alignment, attributes });
    useEffect(() => {
        dynamic.current = { tag, content, position, alignment, attributes };
    }, [tag, content, position, alignment, attributes]);
    useEffect(() => {
        let visible = false;
        let hideOnClickOutside;
        let hideOnEsc;
        let hideOverlay;
        let removeRefocusTargetListener;
        function getTarget() {
            const target = wrapper.current?.firstChild;
            return target instanceof HTMLElement ? target : undefined;
        }
        if (onRenderChild) {
            const target = getTarget();
            if (target)
                onRenderChild(target);
        }
        async function show(event) {
            if (visible)
                return;
            visible = true;
            const target = getTarget();
            if (openDelayMS && triggerOn === 'hover') {
                await delay(openDelayMS);
                if (!target?.matches(':hover, :focus')) {
                    visible = false;
                    return;
                }
            }
            if (!target)
                return;
            const { overlay, hide: hideFn } = showOverlay({
                tag: dynamic.current.tag,
                content: ['string', 'number', 'boolean'].includes(typeof dynamic.current.content)
                    ? dynamic.current.content
                    : _jsx(OverlayProvider, { value: controller.current, children: dynamic.current.content }),
                target,
                position: dynamic.current.position,
                alignment: dynamic.current.alignment,
                attributes: dynamic.current.attributes,
            });
            hideOverlay?.(true); // ensures there's no lost opened overlay.
            hideOverlay = hideFn;
            function onHide(condition) {
                return (event) => {
                    if (condition(event))
                        controller.current.close();
                };
            }
            if (event.type === 'click') {
                hideOnEsc = onHide(e => e instanceof KeyboardEvent && e.key === 'Escape');
                setTimeout(() => {
                    hideOnClickOutside = onHide(e => e instanceof MouseEvent && e.button === 0 && !overlay.contains(e.target));
                    document.addEventListener('click', hideOnClickOutside);
                }, arbitraryRenderTime);
                document.addEventListener('keydown', hideOnEsc);
            }
            // focus target when the last overlay element loses focus
            function refocusTarget(e) {
                if (e.key === 'Tab' && e.target instanceof HTMLElement) {
                    const allItems = Array.from(e.target.closest('[data-citric="menu"]')?.querySelectorAll('a, button') ?? []);
                    if (e.target === allItems[allItems.length - 1]) {
                        getTarget()?.focus();
                        e.preventDefault();
                    }
                }
            }
            overlay.addEventListener('keydown', refocusTarget);
            removeRefocusTargetListener = () => overlay.removeEventListener('keydown', refocusTarget);
            // auto-focus
            const openedWithMouse = event instanceof MouseEvent && event.detail > 0;
            if (autoFocusBehavior === 'always' || (autoFocusBehavior === 'keyboard' && !openedWithMouse)) {
                setTimeout(() => focusFirstChild(overlay), arbitraryRenderTime);
            }
        }
        controller.current.close = async (immediately = false) => {
            if (!immediately && (closeDelayMS ?? 0) > 0) {
                await delay(closeDelayMS ?? 0);
            }
            visible = false;
            if (hideOnClickOutside)
                document.removeEventListener('click', hideOnClickOutside);
            if (hideOnEsc)
                document.removeEventListener('keydown', hideOnEsc);
            removeRefocusTargetListener?.();
            await hideOverlay?.();
        };
        if (triggerOn === 'hover') {
            const close = () => controller.current.close();
            getTarget()?.addEventListener('mouseenter', show);
            getTarget()?.addEventListener('mouseleave', close);
            getTarget()?.addEventListener('focus', show);
            getTarget()?.addEventListener('blur', close);
            return () => {
                getTarget()?.removeEventListener('mouseenter', show);
                getTarget()?.removeEventListener('mouseleave', close);
                getTarget()?.removeEventListener('focus', show);
                getTarget()?.removeEventListener('blur', close);
            };
        }
        if (triggerOn === 'click') {
            getTarget()?.addEventListener('click', show);
            return () => {
                controller.current.close();
                getTarget()?.removeEventListener('click', show);
                if (hideOnClickOutside)
                    document.removeEventListener('click', hideOnClickOutside);
            };
        }
    }, [wrapper.current, triggerOn]);
    useEffect(() => () => {
        controller.current?.close(true);
    }, []);
    return _jsx("div", { ref: wrapper, ...props, children: children });
}
//# sourceMappingURL=index.js.map