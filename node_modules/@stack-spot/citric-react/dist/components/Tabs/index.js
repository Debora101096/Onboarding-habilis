import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { listToClass } from '@stack-spot/portal-theme';
import { useTranslate } from '@stack-spot/portal-translate';
import { createContext, Suspense, useContext, useEffect, useMemo, useState } from 'react';
import { withRef } from '../../utils/react.js';
import { CitricComponent } from '../CitricComponent.js';
import { ErrorBoundary } from '../ErrorBoundary.js';
import { ProgressCircular } from '../ProgressCircular.js';
import { Center } from '../layout.js';
import { TabController } from './TabController.js';
import { findSelectedIndex } from './utils.js';
const ctx = createContext(undefined);
/**
 * Builds a Tab selector. The content of a tab is a React component and it can suspend, i.e. tabs can be asynchronously loaded.
 *
 * @example
 *
 * ```
 * const tabs: Tab[] = useMemo(() => [
 *   { key: 'tab1', label: 'Tab 1', content: <><h1>First tab</h1><p>Content of the first tab</p></> },
 *   { key: 'tab2', label: 'Tab 2', content: <><h1>Second tab</h1><p>Content of the second tab</p></> },
 *   { key: 'tab3', label: 'Tab 3', content: <><h1>Third tab</h1><p>Content of the third tab</p></> },
 * ], [])
 *
 * return <Tabs tabs={tabs} />
 * ```
 */
export const Tabs = withRef(function Tabs({ tabs, value, equallySized, onChange, controller: ctrl, appearance, customRenderer, className, ...props }) {
    const controller = useMemo(() => ctrl ?? new TabController(tabs.map(t => t.key), value || tabs[0]?.key), []);
    const t = useTranslate(dictionary);
    const [selectedIndex, setSelectedIndex] = useState(findSelectedIndex(tabs, controller.getValue()));
    useEffect(() => {
        if (value)
            controller.setValue(value);
    }, [value]);
    useEffect(() => controller.onChange((v) => {
        setSelectedIndex(findSelectedIndex(tabs, v));
        onChange?.(v);
    }), [tabs]);
    const tabSelector = useMemo(() => (_jsx("nav", { className: "tab-selector", children: tabs.map(({ key, label, disabled }, index) => (_jsxs("label", { children: [_jsx("input", { type: "radio", role: "tab", checked: index === selectedIndex, onChange: () => controller.setValue(key), disabled: disabled }), label || key] }, key))) })), [tabs, selectedIndex]);
    const content = useMemo(() => (_jsx("section", { className: "tab-content", children: _jsx(ErrorBoundary, { message: t.error, children: _jsx(Suspense, { fallback: _jsx(Center, { style: { padding: '20px' }, children: _jsx(ProgressCircular, {}) }), children: selectedIndex === -1 ? null : tabs[selectedIndex]?.content }) }, selectedIndex) })), [selectedIndex, t]);
    return (_jsx(ctx.Provider, { value: controller, children: _jsx(CitricComponent, { tag: "div", component: "tabs", className: listToClass([className, equallySized && 'equally-sized', appearance]), ...props, children: customRenderer ? customRenderer(tabSelector, content) : _jsxs(_Fragment, { children: [tabSelector, content] }) }) }));
});
/**
 * Request the tab controller of the current context. Use this to control the tabs in the parent components. This returns undefined when
 * no tab context is found.
 */
export function useTabController() {
    return useContext(ctx);
}
const dictionary = {
    en: {
        error: 'Error while loading the tab.',
    },
    pt: {
        error: 'Ocorreu um erro ao carregar a aba.',
    },
};
//# sourceMappingURL=index.js.map