import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { listToClass } from '@stack-spot/portal-theme';
import { useTranslate } from '@stack-spot/portal-translate';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { applyCSSVariable } from '../utils/css.js';
import { defaultRenderKey, defaultRenderLabel } from '../utils/options.js';
import { withRef } from '../utils/react.js';
import { Badge } from './Badge.js';
import { Checkbox } from './Checkbox.js';
import { CitricComponent } from './CitricComponent.js';
import { IconButton } from './IconBox.js';
import { ProgressCircular } from './ProgressCircular.js';
import { useDisabledEffect, useFocusEffect } from './Select/hooks.js';
import { Row } from './layout.js';
/**
 * A combination of a text input and a dropdown that suggests options as the user types.
 * Supports both single and multiple selection modes, similar to Material-UI Autocomplete.
 *
 * @example
 * Basic usage (single selection):
 * ```tsx
 * const [value, setValue] = useState<Option | null>(null)
 *
 * <Autocomplete
 *   options={options}
 *   value={value}
 *   onChange={setValue}
 *   renderLabel={o => o.name}
 *   renderKey={o => o.id}
 * />
 * ```
 *
 * @example
 * Multiple selection with tags:
 * ```tsx
 * const [value, setValue] = useState<Option[]>([])
 *
 * <Autocomplete
 *   multiple
 *   options={options}
 *   value={value}
 *   onChange={setValue}
 *   renderLabel={o => o.name}
 *   renderKey={o => o.id}
 * />
 * ```
 *
 * @example
 * Free solo (allow custom values):
 * ```tsx
 * <Autocomplete
 *   freeSolo
 *   options={options}
 *   value={value}
 *   onChange={setValue}
 *   renderLabel={o => o.name}
 * />
 * ```
 */
export const Autocomplete = withRef(function Autocomplete({ options, value, onChange, multiple = false, freeSolo = false, creatable = false, onCreate, getOptionFromInput, inputValue: controlledInputValue, onInputChange, renderLabel = defaultRenderLabel, renderKey = defaultRenderKey, renderOption, renderSelected, customSelectedTags, filterOptions, loading = false, disabled = false, placeholder, maxHeight, autoHighlight = false, clearOnSelect = multiple, openOnFocus = true, noOptionsText, loadingText, onScrollEnd, scrollEndMargin = 200, colorScheme, id, style, className, ...props }, ref) {
    const t = useTranslate(dictionary);
    const _element = useRef(null);
    const inputRef = useRef(null);
    const dropdownRef = useRef(null);
    const isNavigatingWithKeyboard = useRef(false);
    const element = ref ?? _element;
    const [open, setOpen] = useState(false);
    const [focused, setFocused] = useState(false);
    const [internalInputValue, setInternalInputValue] = useState('');
    const [highlightedIndex, setHighlightedIndex] = useState(-1);
    useFocusEffect({ element, focused, setFocused, setOpen });
    useDisabledEffect({ disabled, setOpen, setFocused });
    useEffect(() => {
        if (!open)
            return;
        const handleClickOutside = (event) => {
            if (element.current && !element.current.contains(event.target)) {
                setOpen(false);
                setFocused(false);
            }
        };
        setTimeout(() => {
            document.addEventListener('click', handleClickOutside);
        }, 10);
        return () => {
            document.removeEventListener('click', handleClickOutside);
        };
    }, [open, element]);
    const inputValue = controlledInputValue ?? internalInputValue;
    const setInputValue = useCallback((newValue) => {
        if (onInputChange) {
            onInputChange(newValue);
        }
        else {
            setInternalInputValue(newValue);
        }
    }, [onInputChange]);
    const defaultFilter = useCallback((opts, input) => {
        if (!input)
            return opts;
        return opts.filter(option => renderLabel(option)?.toLowerCase()?.includes(input?.toLowerCase()));
    }, [renderLabel]);
    const filter = filterOptions ?? defaultFilter;
    const filteredOptions = useMemo(() => {
        if (!multiple && value && renderLabel(value) === inputValue) {
            return options;
        }
        return filter(options, inputValue);
    }, [options, inputValue, filter, multiple, value, renderLabel]);
    const showCreateOption = useMemo(() => {
        if (!creatable || !onCreate || !inputValue.trim())
            return false;
        const hasExactMatch = filteredOptions.some(option => renderLabel(option).toLowerCase() === inputValue.toLowerCase());
        return !hasExactMatch;
    }, [creatable, onCreate, inputValue, filteredOptions, renderLabel]);
    const handleCreate = useCallback(() => {
        if (!onCreate || !inputValue.trim())
            return;
        onCreate(inputValue.trim());
        setInputValue('');
        if (inputRef.current) {
            inputRef.current.focus();
        }
    }, [onCreate, inputValue, setInputValue]);
    const isSelected = useCallback((option) => {
        if (multiple) {
            return value.some(v => renderKey(v) === renderKey(option));
        }
        return value !== null && renderKey(value) === renderKey(option);
    }, [value, multiple, renderKey]);
    const handleSelect = useCallback((option) => {
        if (multiple) {
            const currentValue = value;
            const isAlreadySelected = currentValue.some(v => renderKey(v) === renderKey(option));
            if (isAlreadySelected) {
                const newValue = currentValue.filter(v => renderKey(v) !== renderKey(option));
                onChange(newValue);
            }
            else {
                onChange([...currentValue, option]);
            }
            if (clearOnSelect) {
                setInputValue('');
            }
        }
        else {
            onChange(option);
            setInputValue(renderLabel(option));
            setOpen(false);
        }
    }, [multiple, value, onChange, renderKey, clearOnSelect, setInputValue, renderLabel]);
    const handleRemoveTag = useCallback((optionToRemove) => {
        if (!multiple)
            return;
        const newValue = value.filter(v => renderKey(v) !== renderKey(optionToRemove));
        onChange(newValue);
    }, [multiple, value, onChange, renderKey]);
    const handleInputChange = (newValue) => {
        setInputValue(newValue);
        if (!open && newValue) {
            setOpen(true);
        }
        setHighlightedIndex(autoHighlight ? 0 : -1);
    };
    const handleFocus = () => {
        setFocused(true);
        if (openOnFocus) {
            setOpen(true);
            if (autoHighlight && filteredOptions.length > 0) {
                setHighlightedIndex(0);
            }
        }
    };
    const handleBlur = (e) => {
        if (element.current?.contains(e.relatedTarget)) {
            return;
        }
        setFocused(false);
        setOpen(false);
        if (freeSolo && inputValue && !multiple) {
            if (creatable && !onCreate) {
                if (getOptionFromInput) {
                    const newOption = getOptionFromInput(inputValue.trim());
                    onChange(newOption);
                }
                else {
                    onChange(inputValue);
                }
            }
            else {
                const exactMatch = options.find(o => renderLabel(o).toLowerCase() === inputValue.toLowerCase());
                if (exactMatch) {
                    handleSelect(exactMatch);
                }
            }
        }
        else if (!multiple && inputValue) {
            const exactMatch = options.find(o => renderLabel(o).toLowerCase() === inputValue.toLowerCase());
            if (exactMatch) {
                handleSelect(exactMatch);
            }
            else {
                if (value) {
                    setInputValue(renderLabel(value));
                }
                else {
                    setInputValue('');
                }
            }
        }
    };
    const handleCreateNewOption = useCallback(() => {
        if (!inputValue.trim())
            return false;
        if (onCreate) {
            handleCreate();
            return true;
        }
        if (freeSolo && getOptionFromInput) {
            const newOption = getOptionFromInput(inputValue.trim());
            if (multiple) {
                const currentValue = value;
                const isDuplicate = currentValue.some(v => renderKey(v) === renderKey(newOption));
                if (!isDuplicate) {
                    onChange([...currentValue, newOption]);
                }
                setInputValue('');
            }
            else {
                onChange(newOption);
                setInputValue(renderLabel(newOption));
                setOpen(false);
            }
            return true;
        }
        if (freeSolo) {
            if (multiple) {
                const currentValue = value;
                const inputAsOption = inputValue;
                const isDuplicate = currentValue.some(v => renderLabel(v).toLowerCase() === inputValue.toLowerCase());
                if (!isDuplicate) {
                    onChange([...currentValue, inputAsOption]);
                }
                setInputValue('');
            }
            else {
                onChange(inputValue);
                setOpen(false);
            }
            return true;
        }
        return false;
    }, [onCreate, handleCreate, freeSolo, getOptionFromInput, inputValue, multiple, value, renderKey, onChange, setInputValue, renderLabel]);
    const handleEnterKey = useCallback(() => {
        if (open && highlightedIndex >= 0 && filteredOptions[highlightedIndex]) {
            handleSelect(filteredOptions[highlightedIndex]);
            return;
        }
        if (!open && filteredOptions.length === 1) {
            handleSelect(filteredOptions[0]);
            return;
        }
        if (creatable && handleCreateNewOption()) {
            return;
        }
        if (freeSolo && inputValue && !multiple) {
            const exactMatch = options.find(o => renderLabel(o).toLowerCase() === inputValue.toLowerCase());
            if (exactMatch) {
                handleSelect(exactMatch);
            }
        }
    }, [
        open,
        highlightedIndex,
        filteredOptions,
        handleSelect,
        creatable,
        handleCreateNewOption,
        freeSolo,
        inputValue,
        multiple,
        options,
        renderLabel,
    ]);
    const handleKeyDown = (e) => {
        if (disabled)
            return;
        switch (e.key) {
            case 'ArrowDown':
                e.preventDefault();
                isNavigatingWithKeyboard.current = true;
                if (!open) {
                    setOpen(true);
                    setHighlightedIndex(0);
                }
                else {
                    setHighlightedIndex(prev => prev < filteredOptions.length - 1 ? prev + 1 : prev);
                }
                break;
            case 'ArrowUp':
                e.preventDefault();
                isNavigatingWithKeyboard.current = true;
                if (open) {
                    setHighlightedIndex(prev => prev > 0 ? prev - 1 : 0);
                }
                break;
            case 'Enter':
                e.preventDefault();
                handleEnterKey();
                break;
            case 'Escape':
                e.preventDefault();
                setOpen(false);
                if (inputRef.current) {
                    inputRef.current.blur();
                }
                break;
            case 'Backspace':
                if (multiple && !inputValue && value.length > 0) {
                    const lastTag = value[value.length - 1];
                    handleRemoveTag(lastTag);
                }
                else if (!multiple && !inputValue && value) {
                    onChange(null);
                }
                break;
            default:
                break;
        }
    };
    const handleClear = () => {
        if (multiple) {
            onChange([]);
        }
        else {
            onChange(null);
        }
        setInputValue('');
        if (inputRef.current) {
            inputRef.current.focus();
        }
    };
    const handleFocusAndOpen = () => {
        if (disabled)
            return;
        setFocused(true);
        inputRef.current?.focus();
        if (openOnFocus) {
            setOpen(true);
        }
    };
    useEffect(() => {
        if (highlightedIndex < 0 || !open)
            return;
        const optionsContainer = dropdownRef.current?.querySelector('.options');
        if (!optionsContainer)
            return;
        const highlightedOption = optionsContainer.children[highlightedIndex];
        if (!highlightedOption)
            return;
        const containerRect = optionsContainer.getBoundingClientRect();
        const optionRect = highlightedOption.getBoundingClientRect();
        if (optionRect.bottom > containerRect.bottom) {
            highlightedOption.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
        else if (optionRect.top < containerRect.top) {
            highlightedOption.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
    }, [highlightedIndex, open]);
    useEffect(() => {
        if (!onScrollEnd || !open)
            return;
        const optionsContainer = dropdownRef.current?.querySelector('.options');
        if (!optionsContainer)
            return;
        const handleScroll = () => {
            if (loading)
                return;
            const { scrollTop, scrollHeight, clientHeight } = optionsContainer;
            const scrollBottom = scrollHeight - scrollTop - clientHeight;
            if (scrollBottom <= scrollEndMargin) {
                onScrollEnd();
            }
        };
        optionsContainer.addEventListener('scroll', handleScroll);
        handleScroll();
        return () => {
            optionsContainer.removeEventListener('scroll', handleScroll);
        };
    }, [onScrollEnd, open, filteredOptions.length, loading, scrollEndMargin]);
    const renderTags = () => {
        if (!multiple || value.length === 0)
            return null;
        const tags = value;
        if (renderSelected) {
            return renderSelected(tags, handleRemoveTag);
        }
        const config = customSelectedTags || {};
        const maxItems = config.maxItems;
        const visibleTags = maxItems && tags.length > maxItems
            ? tags.slice(0, maxItems)
            : tags;
        const remainingCount = maxItems && tags.length > maxItems
            ? tags.length - maxItems
            : 0;
        return (_jsxs(_Fragment, { children: [visibleTags.map(tag => (_jsxs(Badge, { colorScheme: config.colorScheme, colorPalette: config.colorPalette, appearance: config.appearance || 'circle', children: [renderLabel(tag), !disabled && (_jsx(IconButton, { icon: "Times", type: "button", appearance: "none", size: "xs", style: { color: 'inherit' }, onClick: (e) => {
                                e.stopPropagation();
                                if (!disabled)
                                    handleRemoveTag(tag);
                            }, "aria-label": `${t.removeTag} ${renderLabel(tag)}`, disabled: disabled, tabIndex: 0 }))] }, renderKey(tag)))), remainingCount > 0 && (_jsxs(Badge, { colorScheme: config.colorScheme, colorPalette: config.colorPalette, appearance: config.appearance || 'circle', children: ["+", remainingCount] }))] }));
    };
    const showClearButton = !disabled && ((!multiple && value !== null) ||
        (multiple && value.length > 0));
    return (_jsxs(CitricComponent, { tag: "div", component: "autocomplete", colorScheme: colorScheme, style: maxHeight ? applyCSSVariable(style, 'max-height', `${maxHeight}px`) : style, className: listToClass([
            className,
            open && 'open',
            focused && 'focused',
            disabled && 'disabled',
            multiple && 'multiple',
        ]), ref: element, "aria-busy": loading, ...props, children: [_jsxs("header", { tabIndex: disabled ? undefined : 0, onClick: handleFocusAndOpen, onFocus: handleFocusAndOpen, onKeyDown: handleKeyDown, children: [_jsxs(Row, { gap: "4px", className: "input-container", children: [multiple && renderTags(), _jsx("input", { ref: inputRef, id: id, type: "text", value: inputValue, onChange: (e) => handleInputChange(e.target.value), onFocus: handleFocus, onBlur: handleBlur, disabled: disabled, placeholder: (multiple && value.length > 0) ? '' : placeholder, tabIndex: disabled ? undefined : 0, autoComplete: "off", "aria-autocomplete": "list", "aria-expanded": open, "aria-controls": "autocomplete-listbox" })] }), _jsxs("div", { className: "end-adornment", children: [loading && _jsx(ProgressCircular, { size: "xs", className: "loader" }), showClearButton && (_jsx(IconButton, { icon: "Times", appearance: "none", size: "sm", type: "button", onClick: (e) => {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    handleClear();
                                }, onMouseDown: (e) => {
                                    e.stopPropagation();
                                    e.preventDefault();
                                }, onFocus: (e) => {
                                    e.stopPropagation();
                                }, disabled: disabled, "aria-label": t.clear, tabIndex: 0, style: { width: '12px', height: '12px' } })), _jsx(IconButton, { icon: open ? 'ChevronUp' : 'ChevronDown', appearance: "none", size: "md", type: "button", onClick: (e) => {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    setOpen((prev) => !prev);
                                }, onMouseDown: (e) => {
                                    e.stopPropagation();
                                    e.preventDefault();
                                }, onFocus: (e) => {
                                    e.stopPropagation();
                                }, disabled: disabled, "aria-label": open ? t.collapse : t.expand, tabIndex: 0, style: { width: '12px', height: '12px' } })] })] }), _jsx("div", { className: "dropdown-panel", ref: dropdownRef, id: "autocomplete-listbox", role: "listbox", "aria-hidden": !open, onMouseMove: () => {
                    isNavigatingWithKeyboard.current = false;
                }, ...(open ? {} : { inert: 'true' }), children: loading && !filteredOptions.length ? (_jsx("div", { className: "message", children: loadingText || t.loading })) : filteredOptions.length === 0 && !showCreateOption && !freeSolo ? (_jsx("div", { className: "message", children: noOptionsText || t.noOptions })) : (_jsxs("div", { className: "options", children: [showCreateOption && (_jsxs("div", { role: "option", className: "option create-option", onMouseDown: (e) => {
                                e.preventDefault();
                            }, onClick: handleCreate, onMouseEnter: () => setHighlightedIndex(-1), children: [_jsx("i", { "data-citric": "icon", className: "citric-icon outline Plus" }), t.addOption.replace('{value}', inputValue)] }, "create-option")), filteredOptions.map((option, index) => (_jsxs("div", { role: "option", "aria-selected": isSelected(option), className: listToClass([
                                'option',
                                isSelected(option) && 'selected',
                                highlightedIndex === index && 'highlighted',
                            ]), onMouseDown: (e) => {
                                e.preventDefault();
                            }, onClick: () => handleSelect(option), onMouseEnter: () => {
                                if (!isNavigatingWithKeyboard.current) {
                                    setHighlightedIndex(index);
                                }
                            }, children: [multiple && _jsx(Checkbox, { value: isSelected(option), readOnly: true }), renderOption ? renderOption(option) : renderLabel(option)] }, renderKey(option))))] })) })] }));
});
const dictionary = {
    en: {
        removeTag: 'Remove',
        clear: 'Clear',
        loading: 'Loading...',
        noOptions: 'No options',
        collapse: 'Collapse',
        expand: 'Expand',
        addOption: 'Add "{value}"',
    },
    pt: {
        removeTag: 'Remover',
        clear: 'Limpar',
        loading: 'Carregando...',
        noOptions: 'Sem opções',
        collapse: 'Recolher',
        expand: 'Expandir',
        addOption: 'Adicionar "{value}"',
    },
};
//# sourceMappingURL=Autocomplete.js.map