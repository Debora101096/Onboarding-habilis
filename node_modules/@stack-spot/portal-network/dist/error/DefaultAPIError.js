import { every, isString } from 'lodash';
import { actionDetails } from './dictionary/action-details.js';
import { baseDictionary } from './dictionary/base.js';
import { cntFields } from './dictionary/cnt-fields.js';
import { workspaceDetails } from './dictionary/workspace-details.js';
import { workspaceFields } from './dictionary/workspace-fields.js';
import { ignoredTitleErrorCodes } from './IgnoredErrorCodes.js';
import { StackspotAPIError } from './StackspotAPIError.js';
// these details don't say anything the status already doesn't and we'd better use local translations for them.
const ignoredDescriptions = [
    'internal server error', 'not found', 'gateway timeout', 'temporally unavailable', 'forbidden', 'unauthorized', 'bad request',
];
const fieldDictionary = {
    cnt: cntFields,
    wks: workspaceFields,
};
const detailsDictionary = {
    wks: workspaceDetails,
    actionapi: actionDetails,
};
function getTitle(status, raw, dictionary, language) {
    if (ignoredTitleErrorCodes.includes(raw.code))
        return ' ';
    if (dictionary[language][raw.code])
        return dictionary[language][raw.code];
    if (raw.details && !ignoredDescriptions.includes(raw.details))
        return raw.details;
    return baseDictionary[language][status] || baseDictionary[language].defaultTitle;
}
function getValues(detail) {
    return detail.values && every(detail.values, isString) ? `\n${detail.values.join('\n')}` : '';
}
function getSuggestedMessages(suggestedMessage, language) {
    const parseLanguage = { pt: 'ptBr', en: 'enUs' };
    return suggestedMessage?.[parseLanguage?.[language || 'en']];
}
const UNIT_REGEX_TEMPLATE = /{\d}/g;
const RANGE_REGEX_TEMPLATE = /{1-n}/g;
function containsNumberInBraces(input) {
    return UNIT_REGEX_TEMPLATE.test(input) || RANGE_REGEX_TEMPLATE.test(input);
}
export function interpolateErrors(message, values, fieldValuesFileContent) {
    return message
        .replace(UNIT_REGEX_TEMPLATE, (value) => {
        const position = +value.replace(/{|}/g, '');
        const index = position - 1;
        const fieldValue = values[index];
        return fieldValuesFileContent[fieldValue] || fieldValue;
    })
        .replace(RANGE_REGEX_TEMPLATE, () => values.toString());
}
function createMessage(status, raw, dictionary, language) {
    const title = getTitle(status, raw, dictionary, language || 'en');
    const api = raw.code?.split(/[-_]/)[0];
    const dictDetails = (detailsDictionary[api?.toLowerCase()] ?? {})[language || 'en'];
    const dictionaryDetails = raw.code && dictDetails ? dictDetails[raw.code] : {};
    if (raw?.validationDetails?.length) {
        const suggestedMessages = raw.validationDetails.map((detail) => getSuggestedMessages(detail?.suggestedMessages, language)).filter((msg) => !!msg);
        if (suggestedMessages.length) {
            return { description: suggestedMessages.join('\n'), ...dictionaryDetails };
        }
        const details = raw.validationDetails?.map((detail) => {
            const dict = (fieldDictionary[api?.toLowerCase()] ?? {})[language || 'en'] ?? {};
            const codeTranslatedMessage = raw.code !== detail.code && dictionary[language || 'en'][detail.code];
            if (codeTranslatedMessage && containsNumberInBraces(codeTranslatedMessage) && (detail.values?.length || detail.field?.length)) {
                const value = detail.values?.length ? detail.values : (detail.field ? [detail.field] : []);
                return interpolateErrors(codeTranslatedMessage, value, dict);
            }
            const name = dict[detail.code] || detail.field || codeTranslatedMessage || detail.details || '';
            return `${name}${getValues(detail)}`;
        })?.filter(d => !!d);
        return { description: details ? `${title}\n${details?.join('\n')}` : title, ...dictionaryDetails };
    }
    if (raw?.suggestedMessages) {
        const suggestedMessages = getSuggestedMessages(raw?.suggestedMessages, language);
        if (suggestedMessages) {
            return { description: suggestedMessages, ...dictionaryDetails };
        }
    }
    return { description: title, ...dictionaryDetails };
}
/**
 * This represents the Error thrown by most Stackspot APIs.
 */
export class DefaultAPIError extends StackspotAPIError {
    constructor(
    /**
     * The response's data
     */
    rawResponse, 
    /**
     * The response's status
     */
    status, 
    /**
     * A dictionary for translating error codes and descriptions.
     */
    dictionary, 
    /**
     * The response's headers.
     */
    headers) {
        let parsedResponse;
        try {
            parsedResponse = JSON.parse(rawResponse);
        }
        catch (error) {
            parsedResponse = rawResponse;
        }
        super({
            status: status,
            code: parsedResponse.code,
            message: language => createMessage(status, parsedResponse, dictionary, language),
            headers,
        });
        /**
         * The error object as defined by the Stackspot API. If the response doesn't match the expected format this will be undefined.
         */
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The response data, if this matches the expected format expected by a Stackspot Error, it will be the same as `data`.
         */
        Object.defineProperty(this, "raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.raw = parsedResponse;
        if (this.raw?.code !== undefined && this.raw?.status !== undefined && this.raw?.details !== undefined)
            this.data = parsedResponse;
    }
}
//# sourceMappingURL=DefaultAPIError.js.map