import { findLast, isArray, last } from 'lodash';
import { getApiAddresses } from '../api-addresses.js';
import { addFavoriteV1AiStacksStackIdFavoritePost, addFavoriteV1QuickCommandsSlugFavoritePost, calculateNextStepV1QuickCommandsSlugStepsStepSlugCalculateNextStepPost, callbackV1QuickCommandsCallbackExecutionIdGet, conversationHistoryV1ConversationsConversationIdGet, createExecutionV1QuickCommandsCreateExecutionSlugPost, currentV1TokensUsageCurrentGet, defaults, deleteConversationV1ConversationsConversationIdDelete, deleteFavoriteV1AiStacksStackIdFavoriteDelete, deleteFavoriteV1QuickCommandsSlugFavoriteDelete, deleteKnowledgeObjectByCustomIdV1KnowledgeSourcesSlugObjectsCustomIdDelete, downloadConversationV1ConversationsConversationIdDownloadGet, findKnowledgeObjectByCustomIdV1KnowledgeSourcesSlugObjectsCustomIdGet, findKnowledgeSourceV1KnowledgeSourcesSlugGet, formatFetchStepV1QuickCommandsSlugStepsStepSlugFetchFormatPost, formatResultV1QuickCommandsSlugResultFormatPost, getContentDependenciesV1ContentContentTypeContentIdDependenciesGet, getFlagsV1FlagsGet, getQuickCommandV1QuickCommandsSlugGet, getScriptExecutionStatusV1QuickCommandsScriptExecutionsScriptExecutionIdGet, getUploadFormV1FileUploadFormPost, listAiStacksV1AiStacksGet, listAllV1QuickCommandsAllGet, listAllV2QuickCommandsAllGet, listAssociationV1WorkspaceWorkspaceIdGet, listConversationsV1ConversationsGet, listKnowledgeSourcesV1KnowledgeSourcesGet, postEventV1EventsPost, quickActionsV1QuickActionsPost, quickCommandsRunV2V2QuickCommandsSlugStepsStepSlugRunPost, resetKnowledgeObjectsV1KnowledgeSourcesSlugObjectsDelete, runFetchStepV1QuickCommandsSlugStepsStepSlugFetchRunPost, searchKnowledgeSourcesV1KnowledgeSourcesSearchPost, startScriptStepV1QuickCommandsSlugStepsStepSlugStartScriptPost, totalV1TokensUsageTotalGet, updateQuickCommandV1QuickCommandsSlugPatch, updateTitleV1ConversationsConversationIdPatch, vectorizeCustomKnowledgeSourceV1KnowledgeSourcesSlugCustomPost, } from '../api/ai.js';
import { StackspotAPIError } from '../error/StackspotAPIError.js';
import { ReactQueryNetworkClient } from '../network/ReactQueryNetworkClient.js';
import { removeAuthorizationParam } from '../utils/remove-authorization-param.js';
import { StreamedJson } from '../utils/StreamedJson.js';
import { formatJson } from '../utils/string.js';
import { agentToolsClient } from './agent-tools.js';
class AIClient extends ReactQueryNetworkClient {
    constructor() {
        super(getApiAddresses().ai.url, defaults);
        /**
         * Chat: runs a quick action.
         */
        Object.defineProperty(this, "runQuickAction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(quickActionsV1QuickActionsPost))
        });
        /**
         * Deletes a KO from a KS
         */
        Object.defineProperty(this, "deleteKnowledgeObjectFromKs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(deleteKnowledgeObjectByCustomIdV1KnowledgeSourcesSlugObjectsCustomIdDelete))
        });
        /**
         * Deletes a KO by standalone (reset Knowledge Objects)
         */
        Object.defineProperty(this, "deleteKnowledgeObjectsByStandalone", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(resetKnowledgeObjectsV1KnowledgeSourcesSlugObjectsDelete))
        });
        /**
         * Uploads a KO file
         */
        Object.defineProperty(this, "fileUploadFormKnowledgeObject", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(getUploadFormV1FileUploadFormPost))
        });
        /**
         *  Creates a custom KO (Vectorize)
         */
        Object.defineProperty(this, "vectorizeCustomKS", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(vectorizeCustomKnowledgeSourceV1KnowledgeSourcesSlugCustomPost))
        });
        /**
         * Lists the AI Stacks according to their visibilities.
         */
        Object.defineProperty(this, "aiStacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(listAiStacksV1AiStacksGet))
        });
        /**
         * Gets total tokens usage
         */
        Object.defineProperty(this, "totalTokensUsage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(totalV1TokensUsageTotalGet))
        });
        /**
         * Gets current tokens usage
         */
        Object.defineProperty(this, "currentTokensUsage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(currentV1TokensUsageCurrentGet))
        });
        /**
         * Gets a workspace by its id.
         */
        Object.defineProperty(this, "workspace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(listAssociationV1WorkspaceWorkspaceIdGet))
        });
        /**
         * @deprecated
         * Lists the quick commands according to filters passed as parameter (QC with secrets will not be returned).
         */
        Object.defineProperty(this, "quickCommands", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(listAllV1QuickCommandsAllGet))
        });
        /**
         * Lists all the quick commands according to filters passed as parameter (including QC with secrets).
         */
        Object.defineProperty(this, "allQuickCommands", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(listAllV2QuickCommandsAllGet))
        });
        /**
         * Gets a quick command by its slug.
         */
        Object.defineProperty(this, "quickCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(getQuickCommandV1QuickCommandsSlugGet))
        });
        /**
         * Creates a new execution for a quick command by its slug.
         */
        Object.defineProperty(this, "quickCommandCreateExecution", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(createExecutionV1QuickCommandsCreateExecutionSlugPost))
        });
        /**
         * Gets the execution status and result of a quick command by its execution ID.
         */
        Object.defineProperty(this, "quickCommandCallbackExecutionId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(callbackV1QuickCommandsCallbackExecutionIdGet))
        });
        /**
         * Lists the knowledge sources according to filters passed as parameter.
         */
        Object.defineProperty(this, "knowledgeSources", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(listKnowledgeSourcesV1KnowledgeSourcesGet))
        });
        /**
         * Gets a knowledge source by its slug.
         */
        Object.defineProperty(this, "knowledgeSource", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(findKnowledgeSourceV1KnowledgeSourcesSlugGet))
        });
        /**
         * Gets a knowledge source document by the slug of the parent knowledge source and the document id.
         */
        Object.defineProperty(this, "knowledgeSourceDocument", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(findKnowledgeObjectByCustomIdV1KnowledgeSourcesSlugObjectsCustomIdGet))
        });
        /**
         * Lists knowledge sources matching the provided IDs.
         */
        Object.defineProperty(this, "searchKnowledgeSources", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(searchKnowledgeSourcesV1KnowledgeSourcesSearchPost))
        });
        /**
         * Gets the chat history. This is a paginated resource.
         */
        Object.defineProperty(this, "chats", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.infiniteQuery(removeAuthorizationParam(listConversationsV1ConversationsGet))
        });
        /**
         * Gets a specific chat from the history according to its id.
         */
        Object.defineProperty(this, "chat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(conversationHistoryV1ConversationsConversationIdGet))
        });
        /**
         * Deletes a chat from the chat history.
         */
        Object.defineProperty(this, "deleteChat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(deleteConversationV1ConversationsConversationIdDelete))
        });
        /**
         * Gets a plain text version of the chat with id passed as parameter.
         */
        Object.defineProperty(this, "downloadChat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(downloadConversationV1ConversationsConversationIdDownloadGet))
        });
        /**
         * Renames a chat.
         */
        Object.defineProperty(this, "renameChat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(updateTitleV1ConversationsConversationIdPatch))
        });
        /**
         * Creates an event so it can be used as metric by the product designers (analytics).
         */
        Object.defineProperty(this, "createEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(postEventV1EventsPost))
        });
        /**
         * Runs a step of type "fetch" of a quick command.
         */
        Object.defineProperty(this, "fetchStepOfQuickCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(formatFetchStepV1QuickCommandsSlugStepsStepSlugFetchFormatPost))
        });
        /**
         * Remotely runs a step of type "fetch" of a quick command remotely (used when secrets are present).
         */
        Object.defineProperty(this, "fetchStepOfQuickCommandRemotely", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation({
                name: 'fetchStepOfQuickCommandRemotely',
                request: (signal, variables) => {
                    const { headers, ...props } = variables;
                    return runFetchStepV1QuickCommandsSlugStepsStepSlugFetchRunPost({ ...props, authorization: '' }, { signal, headers });
                },
                permission: this.createPermissionFunctionFor(runFetchStepV1QuickCommandsSlugStepsStepSlugFetchRunPost),
            })
        });
        /**
         * @deprecated This method does not use stream, only json. The json support has been removed
         * So this method might not work as expected.
         * Runs a step of type "llm" of a quick command.
         */
        Object.defineProperty(this, "llmStepOfQuickCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(quickCommandsRunV2V2QuickCommandsSlugStepsStepSlugRunPost))
        });
        /**
         * Calculates QC router next step.
        */
        Object.defineProperty(this, "calculateNextStep", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(calculateNextStepV1QuickCommandsSlugStepsStepSlugCalculateNextStepPost))
        });
        /**
         * Formats the result of a quick command into a human-readable text (markdown).
         */
        Object.defineProperty(this, "formatResultOfQuickCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(formatResultV1QuickCommandsSlugResultFormatPost))
        });
        /**
         * Adds the resource of type Stack AI to the list of favorites.
        */
        Object.defineProperty(this, "addFavoriteStackAi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(addFavoriteV1AiStacksStackIdFavoritePost))
        });
        /**
         * Removes the resource of type Stack AI from the list of favorites.
         */
        Object.defineProperty(this, "removeFavoriteStackAi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(deleteFavoriteV1AiStacksStackIdFavoriteDelete))
        });
        /**
         * Updates a Quick Command
         */
        Object.defineProperty(this, "updateQuickCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(updateQuickCommandV1QuickCommandsSlugPatch))
        });
        /**
         * Adds the resource of type Quick Command to the list of favorites.
         */
        Object.defineProperty(this, "addFavoriteQuickCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(addFavoriteV1QuickCommandsSlugFavoritePost))
        });
        /**
         * Removes the resource of type Quick Command from the list of favorites.
         */
        Object.defineProperty(this, "removeFavoriteQuickCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(deleteFavoriteV1QuickCommandsSlugFavoriteDelete))
        });
        /**
         * Lists all the feature flags for this user.
         */
        Object.defineProperty(this, "flags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(getFlagsV1FlagsGet)
        });
        /**
         * Starts the execution of a script step
         */
        Object.defineProperty(this, "startScriptStep", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(removeAuthorizationParam(startScriptStepV1QuickCommandsSlugStepsStepSlugStartScriptPost))
        });
        /**
         * Gets the status of the execution of a script step
         */
        Object.defineProperty(this, "getStatusScriptStep", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(getScriptExecutionStatusV1QuickCommandsScriptExecutionsScriptExecutionIdGet))
        });
        Object.defineProperty(this, "contentDependencies", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(removeAuthorizationParam(getContentDependenciesV1ContentContentTypeContentIdDependenciesGet))
        });
    }
    buildStackSpotError(error) {
        // @ts-ignore API documentation is wrong
        const details = error.data?.details;
        return new StackspotAPIError({
            status: error.status,
            headers: error.headers,
            stack: error.stack,
            message: isArray(details) ? details?.map(d => d.msg)?.join('\n') : details,
        });
    }
    /**
     * Runs a stream of a step of type "llm" of a quick command.
     */
    streamLlmStepOfQuickCommand(slug, stepSlug, quickCommandsExecutionRequest, minChangeIntervalMS) {
        const abortController = new AbortController();
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream',
        };
        const events = this.stream(this.resolveURL(`/v2/quick-commands/${slug}/steps/${stepSlug}/run`), { method: 'post', body: JSON.stringify(quickCommandsExecutionRequest), headers, signal: abortController.signal });
        return new StreamedJson({
            eventsPromise: events,
            abortController,
            minChangeIntervalMS,
        });
    }
    static async toolsOfAgent(agentId) {
        try {
            const agent = agentId ? await agentToolsClient.agent.query({ agentId }) : undefined;
            if (!agent)
                return [];
            const tools = [];
            agent.toolkits?.builtin_toolkits?.forEach(kit => kit.tools?.forEach(({ id, name, description }) => {
                if (id)
                    tools.push({ image: kit.image_url, id, name: name || id, description });
            }));
            agent.toolkits?.custom_toolkits?.forEach(kit => kit.tools?.forEach(({ id, name, description }) => {
                if (id)
                    tools.push({ image: kit.avatar ?? undefined, id, name: name || id, description });
            }));
            return tools;
        }
        catch {
            return [];
        }
    }
    sendChatMessage(request, minChangeIntervalMS) {
        const abortController = new AbortController();
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream',
        };
        const events = this.stream(this.resolveURL('v3/chat'), { method: 'post', body: JSON.stringify(request), headers, signal: abortController.signal });
        /**
         * This function treats events in the streaming that deals with the execution of tools. Since these events are not concatenated like
         * normal streamings of data, we need this separate function to deal with them. It transforms the internal data model of the
         * StreamedJson object whenever an event is triggered.
         */
        async function transform(event, data) {
            const info = event.agent_info;
            if (!info)
                return;
            const tools = await AIClient.toolsOfAgent(request.context?.agent_id);
            data.steps = data.steps ? [...data.steps] : [];
            if (info.type === 'planning' && info.action === 'end') {
                data.steps.push({
                    id: 'planning',
                    type: 'planning',
                    status: 'success',
                    duration: info.duration || 0,
                    steps: info.data?.steps?.map(s => s.goal) ?? [],
                    goal: info.data?.plan_goal ?? '',
                });
                info.data?.steps.forEach(s => data.steps?.push({
                    id: s.id,
                    type: 'step',
                    status: 'pending',
                    input: s.goal,
                    attempts: [{
                            tools: s.tools?.map(t => ({
                                ...(tools.find(({ id }) => id === t.tool_id) ?? { id: t.tool_id, name: t.tool_id }),
                                executionId: t.tool_execution_id,
                                goal: t.goal,
                            })),
                        }],
                }));
                data.steps.push({ id: 'answer', type: 'answer', status: 'pending' });
            }
            if (info.type === 'planning' && info.action === 'awaiting_approval') {
                data.steps.push({
                    id: 'planning',
                    type: 'planning',
                    status: 'awaiting_approval',
                    user_question: info.data?.user_question,
                    duration: info.duration || 0,
                    steps: info.data?.steps?.map(s => s.goal) ?? [],
                    goal: info.data?.plan_goal ?? '',
                });
                info.data?.steps.forEach(s => data.steps?.push({
                    id: s.id,
                    type: 'step',
                    status: 'pending',
                    input: s.goal,
                    attempts: [{
                            tools: s.tools?.map(t => ({
                                ...(tools.find(({ id }) => id === t.tool_id) ?? { id: t.tool_id, name: t.tool_id }),
                                executionId: t.tool_execution_id,
                                goal: t.goal,
                            })),
                        }],
                }));
                data.steps.push({ id: 'answer', type: 'answer', status: 'pending' });
            }
            if (info.type === 'step' && info.action === 'start') {
                const step = data.steps.find(s => s.id === info.id);
                if (step)
                    step.status = 'running';
            }
            if (info.type === 'step' && info.action === 'end') {
                const step = data.steps.find(s => s.id === info.id);
                if (step) {
                    step.status = 'success';
                    step.duration = info.duration;
                    const lastToolId = last(step.attempts[0].tools)?.id;
                    const lastAttemptOfLastTool = findLast(step.attempts.map(a => a.tools).flat(), t => t?.id === lastToolId);
                    step.output = lastAttemptOfLastTool?.output;
                }
            }
            if (info.type === 'tool' && info.action === 'awaiting_approval') {
                const tool = tools.find(({ id }) => id === info.data?.tool_id);
                data.steps.push({
                    id: info.id,
                    type: 'tool',
                    status: 'awaiting_approval',
                    duration: info.duration || 0,
                    input: info.data?.input,
                    user_question: info.data?.user_question,
                    attempts: [{
                            tools: [{
                                    executionId: info.id,
                                    id: info.data?.tool_id ?? '',
                                    name: tool?.name ?? '',
                                    goal: tool?.goal,
                                    ...tool,
                                }],
                        }],
                });
                data.steps.push({ id: 'answer', type: 'answer', status: 'pending' });
            }
            if (info.type === 'tool' && info.action === 'start') {
                const currentStep = data.steps.find(s => s.status === 'running');
                if (!info.data)
                    return;
                //There might be a tool with status awaiting_approval, so we want to inform tool has already started
                if (!currentStep || !currentStep.attempts[0].tools) {
                    const input = formatJson(info.data.input);
                    const tool = tools.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id };
                    data.steps.push({
                        id: info.id,
                        type: 'tool',
                        status: 'running',
                        duration: info.duration || 0,
                        input: info.data?.input,
                        user_question: info.data?.user_question,
                        attempts: [{
                                tools: [{ ...tool, executionId: info.id, input }],
                            }],
                    });
                }
                else {
                    const toolInFirstAttempt = currentStep.attempts[0].tools?.find(t => t.executionId === info.id);
                    //One step might have multiple tools. When in an approval mode, we might not have all the tools in the array yet.
                    //So we make sure to add any tools that are not in there.
                    if (!toolInFirstAttempt) {
                        const input = formatJson(info.data.input);
                        const tool = tools?.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id };
                        currentStep.attempts[info.data.attempt - 1].tools?.push({
                            ...tool,
                            executionId: info.id,
                            input,
                        });
                    }
                    else {
                        const input = formatJson(info.data.input);
                        if (info.data.attempt === 1) {
                            toolInFirstAttempt.input = input;
                        }
                        else {
                            const tool = tools.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id };
                            currentStep.attempts[info.data.attempt - 1] ??= { tools: [] };
                            currentStep.attempts[info.data.attempt - 1].tools?.push({
                                ...tool,
                                executionId: info.id,
                                input,
                            });
                        }
                    }
                }
            }
            if (info.type === 'tool' && info.action === 'end') {
                const currentStep = data.steps.find(s => s.status === 'running');
                if (!currentStep || !info.data)
                    return;
                const tool = currentStep.attempts[info.data.attempt - 1]?.tools?.find(t => t.executionId === info.id);
                if (tool) {
                    tool.output = formatJson(info.data.output);
                    tool.duration = info.duration;
                }
            }
            if (info.type === 'final_answer' && info.action === 'start') {
                const answerStep = last(data.steps);
                if (answerStep)
                    answerStep.status = 'running';
            }
            if (info.type === 'chat' && info.action === 'end') {
                const answerStep = last(data.steps);
                if (answerStep) {
                    answerStep.status = 'success';
                    answerStep.duration = info.duration;
                }
            }
        }
        return new StreamedJson({
            eventsPromise: events,
            abortController,
            minChangeIntervalMS,
            ignoreKeys: ['agent_info'],
            transform,
        });
    }
}
export const aiClient = new AIClient();
//# sourceMappingURL=ai.js.map