import { findLast, last } from 'lodash';
import { getApiAddresses } from '../api-addresses.js';
import { create, create1, create2, defaults, deleteById, deleteById1, deleteById2, fetchInsights, getAll, getAll1, getAll2, getAllByHypothesis, getById, getById1, getById2, getInsightById, refreshInsights } from '../api/discover.js';
import { DefaultAPIError } from '../error/DefaultAPIError.js';
import { StreamedJson } from '../utils/StreamedJson.js';
import { baseDictionary } from '../error/dictionary/base.js';
import { formatJson } from '../utils/string.js';
import { ReactQueryNetworkClient } from '../network/ReactQueryNetworkClient.js';
import { aiClient } from './ai.js';
import { agentToolsClient } from './agent-tools.js';
class DiscoverClient extends ReactQueryNetworkClient {
    constructor() {
        super(getApiAddresses().discover.url, defaults);
        Object.defineProperty(this, "opportunities", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(getAll)
        });
        Object.defineProperty(this, "opportunity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(getById)
        });
        Object.defineProperty(this, "hypotheses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(getAll1)
        });
        Object.defineProperty(this, "hypothesisById", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(getById1)
        });
        Object.defineProperty(this, "documents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(getAllByHypothesis)
        });
        Object.defineProperty(this, "document", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(getById2)
        });
        Object.defineProperty(this, "artifacts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(getAll2)
        });
        Object.defineProperty(this, "createOpportunity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(create)
        });
        Object.defineProperty(this, "createHypothesis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(create1)
        });
        Object.defineProperty(this, "createDocument", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(create2)
        });
        Object.defineProperty(this, "deleteOpportunity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(deleteById)
        });
        Object.defineProperty(this, "deleteHypothesis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(deleteById1)
        });
        Object.defineProperty(this, "deleteDocument", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(deleteById2)
        });
        /**
         * Fetch insights
         */
        Object.defineProperty(this, "insights", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(fetchInsights)
        });
        /**
         * Refresh insights
         */
        Object.defineProperty(this, "refreshInsights", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.mutation(refreshInsights)
        });
        /**
         * Get Insight by Id
         */
        Object.defineProperty(this, "insightById", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query(getInsightById)
        });
        Object.defineProperty(this, "chats", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.query({
                name: 'chats',
                request: async (_signal, variables) => {
                    const opportunities = await this.opportunities.query({});
                    const opportunitiesByChatId = opportunities.content.reduce((acc, opp) => {
                        if (opp.chatId) {
                            acc[opp.chatId] = opp;
                        }
                        return acc;
                    }, {});
                    const chatsHistory = await aiClient.chats.query({ ...variables, page: variables.page, size: variables.size ?? 40 });
                    const filteredItems = variables.filter
                        ? chatsHistory.filter((chat) => chat.title.toLowerCase().includes(variables.filter.toLowerCase()))
                        : chatsHistory;
                    const enrichedChats = filteredItems?.map(chat => {
                        const relatedOpportunity = opportunitiesByChatId[chat.id];
                        return {
                            ...chat,
                            opportunityName: relatedOpportunity?.title ?? null,
                            hypothesisCount: relatedOpportunity?.hypotheses?.length ?? 0,
                        };
                    });
                    return enrichedChats;
                },
            })
        });
    }
    buildStackSpotError(error) {
        return new DefaultAPIError(error.data, error.status, baseDictionary, error.headers);
    }
    static async toolsOfAgent(agentId) {
        try {
            const agent = agentId ? await agentToolsClient.agent.query({ agentId }) : undefined;
            if (!agent)
                return [];
            const tools = [];
            agent.toolkits?.builtin_toolkits?.forEach(kit => kit.tools?.forEach(({ id, name, description }) => {
                if (id)
                    tools.push({ image: kit.image_url, id, name: name || id, description });
            }));
            agent.toolkits?.custom_toolkits?.forEach(kit => kit.tools?.forEach(({ id, name, description }) => {
                if (id)
                    tools.push({ image: kit.avatar ?? undefined, id, name: name || id, description });
            }));
            return tools;
        }
        catch {
            return [];
        }
    }
    sendChatMessage(request, minChangeIntervalMS) {
        const abortController = new AbortController();
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream',
        };
        const events = this.stream(this.resolveURL('/v2/ai/chat'), { method: 'post', body: JSON.stringify(request), headers, signal: abortController.signal });
        /**
           * This function treats events in the streaming that deals with the execution of tools. Since these events are not concatenated like
           * normal streamings of data, we need this separate function to deal with them. It transforms the internal data model of the
           * StreamedJson object whenever an event is triggered.
           */
        async function transform(event, data) {
            const info = event.agent_info;
            if (!info)
                return;
            const tools = await DiscoverClient.toolsOfAgent(request.agentId);
            data.steps = data.steps ? [...data.steps] : [];
            if (info.type === 'planning' && info.action === 'end') {
                data.steps.push({
                    id: 'planning',
                    type: 'planning',
                    status: 'success',
                    duration: info.duration || 0,
                    steps: info.data?.steps?.map(s => s.goal) ?? [],
                    goal: info.data?.plan_goal ?? '',
                });
                info.data?.steps.forEach(s => data.steps?.push({
                    id: s.id,
                    type: 'step',
                    status: 'pending',
                    input: s.goal,
                    attempts: [{
                            tools: s.tools?.map(t => ({
                                ...(tools.find(({ id }) => id === t.tool_id) ?? { id: t.tool_id, name: t.tool_id }),
                                executionId: t.tool_execution_id,
                                goal: t.goal,
                            })),
                        }],
                }));
                data.steps.push({ id: 'answer', type: 'answer', status: 'pending' });
            }
            if (info.type === 'planning' && info.action === 'awaiting_approval') {
                data.steps.push({
                    id: 'planning',
                    type: 'planning',
                    status: 'awaiting_approval',
                    user_question: info.data?.user_question,
                    duration: info.duration || 0,
                    steps: info.data?.steps?.map(s => s.goal) ?? [],
                    goal: info.data?.plan_goal ?? '',
                });
                info.data?.steps.forEach(s => data.steps?.push({
                    id: s.id,
                    type: 'step',
                    status: 'pending',
                    input: s.goal,
                    attempts: [{
                            tools: s.tools?.map(t => ({
                                ...(tools.find(({ id }) => id === t.tool_id) ?? { id: t.tool_id, name: t.tool_id }),
                                executionId: t.tool_execution_id,
                                goal: t.goal,
                            })),
                        }],
                }));
                data.steps.push({ id: 'answer', type: 'answer', status: 'pending' });
            }
            if (info.type === 'step' && info.action === 'start') {
                const step = data.steps.find(s => s.id === info.id);
                if (step)
                    step.status = 'running';
            }
            if (info.type === 'step' && info.action === 'end') {
                const step = data.steps.find(s => s.id === info.id);
                if (step) {
                    step.status = 'success';
                    step.duration = info.duration;
                    const lastToolId = last(step.attempts[0].tools)?.id;
                    const lastAttemptOfLastTool = findLast(step.attempts.map(a => a.tools).flat(), t => t?.id === lastToolId);
                    step.output = lastAttemptOfLastTool?.output;
                }
            }
            if (info.type === 'tool' && info.action === 'awaiting_approval') {
                const tool = tools.find(({ id }) => id === info.data?.tool_id);
                data.steps.push({
                    id: info.id,
                    type: 'tool',
                    status: 'awaiting_approval',
                    duration: info.duration || 0,
                    input: info.data?.input,
                    user_question: info.data?.user_question,
                    attempts: [{
                            tools: [{
                                    executionId: info.id,
                                    id: info.data?.tool_id ?? '',
                                    name: tool?.name ?? '',
                                    goal: tool?.goal,
                                    ...tool,
                                }],
                        }],
                });
                data.steps.push({ id: 'answer', type: 'answer', status: 'pending' });
            }
            if (info.type === 'tool' && info.action === 'start') {
                const currentStep = data.steps.find(s => s.status === 'running');
                if (!info.data)
                    return;
                //There might be a tool with status awaiting_approval, so we want to inform tool has already started
                if (!currentStep || !currentStep.attempts[0].tools) {
                    const input = formatJson(info.data.input);
                    const tool = tools.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id };
                    data.steps.push({
                        id: info.id,
                        type: 'tool',
                        status: 'running',
                        duration: info.duration || 0,
                        input: info.data?.input,
                        user_question: info.data?.user_question,
                        attempts: [{
                                tools: [{ ...tool, executionId: info.id, input }],
                            }],
                    });
                }
                else {
                    const toolInFirstAttempt = currentStep.attempts[0].tools?.find(t => t.executionId === info.id);
                    //One step might have multiple tools. When in an approval mode, we might not have all the tools in the array yet.
                    //So we make sure to add any tools that are not in there.
                    if (!toolInFirstAttempt) {
                        const input = formatJson(info.data.input);
                        const tool = tools?.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id };
                        currentStep.attempts[info.data.attempt - 1].tools?.push({
                            ...tool,
                            executionId: info.id,
                            input,
                        });
                    }
                    else {
                        const input = formatJson(info.data.input);
                        if (info.data.attempt === 1) {
                            toolInFirstAttempt.input = input;
                        }
                        else {
                            const tool = tools.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id };
                            currentStep.attempts[info.data.attempt - 1] ??= { tools: [] };
                            currentStep.attempts[info.data.attempt - 1].tools?.push({
                                ...tool,
                                executionId: info.id,
                                input,
                            });
                        }
                    }
                }
            }
            if (info.type === 'tool' && info.action === 'end') {
                const currentStep = data.steps.find(s => s.status === 'running');
                if (!currentStep || !info.data)
                    return;
                const tool = currentStep.attempts[info.data.attempt - 1]?.tools?.find(t => t.executionId === info.id);
                if (tool) {
                    tool.output = formatJson(info.data.output);
                    tool.duration = info.duration;
                }
            }
            if (info.type === 'final_answer' && info.action === 'start') {
                const answerStep = last(data.steps);
                if (answerStep)
                    answerStep.status = 'running';
            }
            if (info.type === 'chat' && info.action === 'end') {
                const answerStep = last(data.steps);
                if (answerStep) {
                    answerStep.status = 'success';
                    answerStep.duration = info.duration;
                }
            }
        }
        return new StreamedJson({
            eventsPromise: events,
            abortController,
            minChangeIntervalMS,
            ignoreKeys: ['agent_info'],
            transform,
        });
    }
}
export const discoverClient = new DiscoverClient();
//# sourceMappingURL=discover.js.map