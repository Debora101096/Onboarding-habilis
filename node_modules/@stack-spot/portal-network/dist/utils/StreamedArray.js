import { CompletablePromise } from '@stack-spot/opa';
import { StreamCanceledError } from '../error/StreamCanceledError.js';
import { StreamError } from '../error/StreamError.js';
import { StreamJsonError } from '../error/StreamJsonError.js';
/**
 * An array represented by a stream where each event contains an item of the array as a JSON string. This can be watched as the stream runs.
 */
export class StreamedArray {
    /**
     * @param response the fetch response.
     * @param minChangeIntervalMS a stream can be too fast. This sets a minimum interval between running the listeners. The default is 50ms.
     */
    constructor({ eventsPromises, abortController, minChangeIntervalMS = 50, signal }) {
        Object.defineProperty(this, "onChangeListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "fullPromise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new CompletablePromise()
        });
        Object.defineProperty(this, "abortController", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abortController = abortController ?? new AbortController();
        eventsPromises.forEach(eventsPromise => this.run(eventsPromise, minChangeIntervalMS));
        if (signal) {
            signal.addEventListener('abort', () => this.cancel());
        }
    }
    async run(eventsPromise, minChangeIntervalMS) {
        let lastChangeCall = 0;
        try {
            const events = await eventsPromise;
            let flushed = true;
            for await (const event of events) {
                if (this.error)
                    return;
                if (event.data) {
                    this.data.push(JSON.parse(event.data));
                    if (new Date().getTime() - lastChangeCall >= minChangeIntervalMS) {
                        this.onChangeListeners.forEach(l => l(this.data));
                        lastChangeCall = new Date().getTime();
                        flushed = true;
                    }
                    else {
                        flushed = false;
                    }
                }
            }
            if (!flushed)
                this.onChangeListeners.forEach(l => l(this.data));
        }
        catch (error) {
            if (error instanceof DOMException && error.name === 'AbortError')
                this.fail(new StreamCanceledError());
            if (error instanceof SyntaxError)
                this.fail(new StreamJsonError());
            else if (error instanceof StreamError)
                this.fail(error);
            else
                this.fail(new StreamError(error?.message || `${error}`));
        }
        if (!this.error)
            this.complete();
    }
    clear() {
        this.onChangeListeners = [];
        this.abortController = undefined;
    }
    fail(error) {
        this.error = error;
        this.fullPromise.reject(this.error);
        this.clear();
    }
    complete() {
        this.fullPromise.resolve(this.data);
        this.clear();
    }
    /**
     * Returns the full value of the array once the stream finishes.
     */
    getValue() {
        return this.fullPromise.promise;
    }
    /**
     * Returns the streamed array with every item streamed until now. This will be the complete array if the stream has finished.
     */
    getPartialValue() {
        return this.data;
    }
    /**
     * Watches the array as it's streamed. This doesn't wait for the value to be complete.
     *
     * The listener is called whenever the value changes.
     *
     * @param listener the function to call with the new value.
     * @returns a function that, when called, removes the listener.
     */
    onChange(listener) {
        if (this.fullPromise.resolved) {
            listener(this.data);
            return () => { };
        }
        this.onChangeListeners.push(listener);
        return () => {
            const index = this.onChangeListeners?.findIndex(l => l === listener);
            if (index !== undefined && index >= 0)
                this.onChangeListeners?.splice(index, 1);
        };
    }
    getStatus() {
        if (this.error)
            return 'error';
        if (this.fullPromise.resolved)
            return 'success';
        return 'pending';
    }
    getError() {
        return this.error;
    }
    /**
     * If this is a stream and it's not yet finished, calling this function cancels the stream.
     */
    cancel() {
        this.abortController?.abort(new StreamCanceledError());
    }
}
//# sourceMappingURL=StreamedArray.js.map