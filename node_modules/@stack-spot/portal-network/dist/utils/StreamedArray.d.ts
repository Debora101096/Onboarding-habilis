import { StreamError } from '../error/StreamError.js';
import { FetchEventStream } from '../network/types.js';
import { StreamingStatus } from '../types.js';
interface ConstructorParams {
    /**
     * The promises that result in the EventStreams to build the final array.
     */
    eventsPromises: Promise<FetchEventStream>[];
    /**
     * A controller to abort the streaming.
     */
    abortController?: AbortController;
    /**
     * A minimum number of milliseconds to wait before calling onChange listeners.
     * @default 50
     */
    minChangeIntervalMS?: number;
    /***
     * Aborts this stream when the signal is aborted.
     */
    signal?: AbortSignal;
}
/**
 * An array represented by a stream where each event contains an item of the array as a JSON string. This can be watched as the stream runs.
 */
export declare class StreamedArray<T> {
    private onChangeListeners;
    private error;
    private data;
    private fullPromise;
    private abortController;
    /**
     * @param response the fetch response.
     * @param minChangeIntervalMS a stream can be too fast. This sets a minimum interval between running the listeners. The default is 50ms.
     */
    constructor({ eventsPromises, abortController, minChangeIntervalMS, signal }: ConstructorParams);
    private run;
    private clear;
    private fail;
    private complete;
    /**
     * Returns the full value of the array once the stream finishes.
     */
    getValue(): Promise<T[]>;
    /**
     * Returns the streamed array with every item streamed until now. This will be the complete array if the stream has finished.
     */
    getPartialValue(): T[];
    /**
     * Watches the array as it's streamed. This doesn't wait for the value to be complete.
     *
     * The listener is called whenever the value changes.
     *
     * @param listener the function to call with the new value.
     * @returns a function that, when called, removes the listener.
     */
    onChange(listener: (value: T[]) => void): () => void;
    getStatus(): StreamingStatus;
    getError(): StreamError | undefined;
    /**
     * If this is a stream and it's not yet finished, calling this function cancels the stream.
     */
    cancel(): void;
}
export {};
//# sourceMappingURL=StreamedArray.d.ts.map