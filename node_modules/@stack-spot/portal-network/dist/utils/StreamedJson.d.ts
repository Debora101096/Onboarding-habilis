import { StreamError } from '../error/StreamError.js';
import { FetchEventStream } from '../network/types.js';
import { StreamingStatus } from '../types.js';
interface ConstructorParams<T> {
    /**
     * The promise that results in the EventStream to build the final json.
     */
    eventsPromise: Promise<FetchEventStream>;
    /**
     * A controller to abort the streaming.
     */
    abortController: AbortController;
    /**
     * A minimum number of milliseconds to wait before calling onChange listeners.
     * @default 50
     */
    minChangeIntervalMS?: number;
    /**
     * Optional. If set, this function will be called with every streaming event and must transform the current data object according to the
     * message received.
     */
    transform?: (event: Partial<T>, data: Partial<T>) => void | Promise<void>;
    /**
     * Optional. Keys to ignore when merging the result with the current event. Ignored keys are always replaced by the newest value instead
     * of merged.
     */
    ignoreKeys?: (keyof T)[];
}
/**
 * An object represented by a JSON stream. This can be watched as the stream runs.
 */
export declare class StreamedJson<T> {
    private onChangeListeners;
    private error;
    private data;
    private fullPromise;
    private abortController;
    private transform?;
    private ignoreKeys?;
    /**
     * @param response the fetch response.
     * @param minChangeIntervalMS a stream can be too fast. This sets a minimum interval between running the listeners. The default is 50ms.
     */
    constructor({ eventsPromise, abortController, minChangeIntervalMS, transform, ignoreKeys }: ConstructorParams<T>);
    private run;
    private merge;
    private clear;
    private fail;
    private complete;
    /**
     * Returns the full value of the object once the stream finishes.
     */
    getValue(): Promise<T>;
    /**
     * Returns the streamed object with everything already streamed. This will be the complete object if the stream has finished.
     */
    getPartialValue(): Partial<T>;
    /**
     * Watches the object as it's streamed. This doesn't wait for the value to be complete.
     *
     * The listener is called whenever the value changes.
     *
     * @param listener the function to call with the new value.
     * @returns a function that, when called, removes the listener.
     */
    onChange(listener: (value: Partial<T>) => void): () => void;
    getStatus(): StreamingStatus;
    getError(): StreamError | undefined;
    /**
     * If this is a stream and it's not yet finished, calling this function cancels the stream.
     */
    cancel(): void;
}
export {};
//# sourceMappingURL=StreamedJson.d.ts.map