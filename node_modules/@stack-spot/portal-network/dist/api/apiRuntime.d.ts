/**
 * Runtime Manager API
 * v1.0.0
 * DO NOT MODIFY - This file has been generated using oazapfts.
 * See https://www.npmjs.com/package/oazapfts
 */
import * as Oazapfts from "@oazapfts/runtime";
export declare const defaults: Oazapfts.Defaults<Oazapfts.CustomHeaders>;
export declare const servers: {
    generatedServerUrl: string;
};
export type SetRunAsErrorRequest = {
    errorMessage: string;
};
export type FinishIntegratedWorkerSchema = {
    runId: string;
    status?: {
        [key: string]: "SUCCESS" | "FAILED" | "INTERNAL_ERROR";
    };
    migrated?: boolean;
    errorMessage?: {
        [key: string]: string;
    };
    metadata: {
        [key: string]: string;
    };
    outputs?: {
        [key: string]: {
            [key: string]: object;
        };
    };
    partialResources?: {
        [key: string]: string[];
    };
};
export type TaskDataS3BackendResponse = {
    bucket: string;
    region: string;
    key: string;
};
export type TaskIacDataResponsePlugin = {
    pluginAppliedAlias?: string;
    name?: string;
    inputs: {
        [key: string]: object;
    };
    fork: boolean;
};
export type TaskIacDataResponseConnector = {
    connector: string;
    alias: string;
    "type": string;
    pluginName?: string;
    attributes: {
        [key: string]: object;
    };
    writeToFile: boolean;
};
export type TaskIacDataResponse = {
    schemaVersion: string;
    runId: string;
    runTaskId: string;
    realm: string;
    iacBackend: TaskDataS3BackendResponse;
    workspaceName: string;
    plugin: TaskIacDataResponsePlugin;
    connectors: TaskIacDataResponseConnector[];
    metadata?: {
        [key: string]: object;
    };
    runEnvironment: string[];
    appId: string;
};
export type ValidationDetails = {
    code: string;
    field?: string;
    details?: string;
    values?: string[];
};
export type ErrorResponse = {
    code: "RTM_ACCESS_TOKEN_NOT_RECEIVED_FROM_IDM" | "RTM_EVENTS_NOT_SENT" | "RTM_BAD_REQUEST_ERROR" | "RTM_MANDATORY_PARAM_NOT_INFORMED" | "RTM_MANDATORY_ATTR_NOT_INFORMED" | "RTM_ATTR_INVALID" | "RTM_ATTR_INVALID_FORMAT" | "RTM_ATTR_INVALID_EVALUATED_FROM_VALIDATIONS_LENGTH" | "RTM_ATTR_INVALID_EVALUATED_FROM_VALIDATIONS_EMAIL" | "RTM_ATTR_INVALID_EVALUATED_FROM_VALIDATIONS_PATTERN" | "RTM_UNABLE_TO_PARSE_REQUEST" | "RTM_CANNOT_DESTROY" | "RTM_ALREADY_DESTROYED" | "RTM_CONNECTION_INTERFACE_IN_USE" | "RTM_CANNOT_IDENTIFY_USER" | "RTM_TASK_TYPE_NOT_CORRECT" | "RTM_GENERIC_BUSINESS_ERROR" | "RTM_TASK_NOT_READY_TO_RUN" | "RTM_TASK_WAS_PROCESSED_ALREADY" | "RTM_TASK_NOT_RUNNING" | "RTM_DEPLOYMENT_WITHOUT_INFRA_OR_APP_ID" | "RTM_CREATING_CONN_INTERFACE_ERROR" | "RTM_CREATING_CONN_INTERFACE_NO_OUTPUTS_ERROR" | "RTM_CREATING_CONN_INTERFACE_MISSING_ATTRIBUTES" | "RTM_IMPERSONATE_TOKEN_ERROR" | "RTM_UNEXPECTED_RUNTIME_ENVIRONMENT_CONFIG" | "RTM_RUN_WITH_NO_TASKS_ERROR" | "RTM_TASK_TYPE_NOT_SUPPORTED" | "RTM_SELF_HOSTED_BACKEND_NOT_CONFIGURED" | "RTM_DEPENDENCIES_HAS_CYCLE" | "RTM_UNAVAILABLE_DESTROY_PROCESS" | "RTM_DEPLOYMENT_WITH_INFRA_AND_APP" | "RTM_DEPLOYMENT_JUST_ONE_RUN_NOT_FINISHED" | "RTM_GENERIC_CONFLICT_ERROR" | "RTM_DEPLOYMENT_APP_ALREADY_RUNNING_CONFLICT_ERROR" | "RTM_DEPLOYMENT_INFRA_ALREADY_RUNNING_CONFLICT_ERROR" | "RTM_DEPLOYMENT_TAG_ALREADY_EXISTS" | "RTM_NOT_FOUND" | "RTM_PROVIDER_NOT_FOUND" | "RTM_STATE_NOT_FOUND" | "RTM_ENVIRONMENT_NOT_FOUND_ERROR" | "RTM_DEPLOYMENT_NOT_FOUND_ERROR" | "RTM_PLUGIN_DEPLOYMENT_NOT_FOUND_ERROR" | "RTM_WORKSPACE_NOT_FOUND" | "RTM_APPLICATION_NOT_FOUND" | "RTM_INFRA_LINK_NOT_FOUND" | "RTM_RUN_NOT_FOUND" | "RTM_RUN_TASK_NOT_FOUND" | "RTM_CONNECTION_INTERFACE_NOT_FOUND" | "RTM_PLUGIN_MANIFESTO_NOT_FOUND" | "RTM_PLUGIN_DATA_NOT_FOUND" | "RTM_DEPLOYMENT_TAG_NOT_FOUND" | "RTM_RUN_WITH_TOO_MANY_PLUGINS" | "RTM_TOO_MANY_RUNS" | "RTM_FORBIDDEN" | "RTM_MISSING_ACCOUNT" | "RTM_MISSING_AUTHENTICATION" | "RTM_WORKSPACE_API_FORBIDDEN" | "RTM_WORKSPACE_API_INTEGRATION_ERROR" | "RTM_WORKSPACE_API_UNHANDLED_ERROR" | "RTM_WORKSPACE_API_UNPROCESSABLE_ENTITY" | "RTM_WORKSPACE_API_GATEWAY_TIMEOUT" | "RTM_WORKSPACE_API_INTERNAL_ERROR" | "RTM_WORKSPACE_API_BAD_GATEWAY" | "RTM_CONTENT_API_FORBIDDEN" | "RTM_CONTENT_API_INTEGRATION_ERROR" | "RTM_CONTENT_API_NOT_FOUND_VALIDATION_SCHEMA" | "RTM_CONTENT_API_UNHANDLED_ERROR" | "RTM_CONTENT_API_INTERNAL_ERROR" | "RTM_ACCOUNT_CONNECTIONS_API_FORBIDDEN" | "RTM_ACCOUNT_CONNECTIONS_API_UNHANDLED_ERROR" | "RTM_ACCOUNT_CONNECTIONS_FAILED_TO_RETRIEVE_EXTERNAL_ID" | "RTM_ACCOUNT_CONNECTIONS_API_INTERNAL_ERROR" | "RTM_GENERIC_INTEGRATION_ERROR" | "RTM_ACCOUNT_API_PAT_NOT_FOUND_ERROR" | "RTM_ACCOUNT_API_FORBIDDEN" | "RTM_ACCOUNT_API_UNHANDLED_ERROR" | "RTM_ACCOUNT_API_INTERNAL_ERROR" | "RTM_S3_UNHANDLED_ERROR" | "RTM_INTERNAL_SERVER_ERROR" | "RTM_CREATING_CONN_INTERFACE_WORKER_ERROR" | "RTM_SECURITY_KEY_ALREADY_REGISTERED_IN_BLOCK_LIST" | "RTM_SECURITY_BLOCK_LIST_ERROR" | "RTM_RUN_TYPE_NOT_CORRECT" | "RTM_IAC_PATH_NOT_PRESENT" | "RTM_PLUGIN_INPUT_HAS_NO_CONN_INTERFACE_TYPE_DECLARED" | "RTM_PLUGIN_INPUT_HAS_NO_NAME_OR_ALIAS_DECLARED" | "RTM_PLUGIN_INPUT_HAS_NO_OUTPUTS_DECLARED" | "RTM_NO_TASK_READY_TO_RUN" | "RTM_CANT_PERFORM_SELF_HOSTED_APP_OR_INFRA_IN_SAAS" | "RUN_IS_ALREADY_RUNNING_CANT_ADD_INPUTS" | "RTM_RUN_IS_NOT_V2_WRONG_WORKFLOW";
    status: number;
    details: string;
    validationDetails?: ValidationDetails[];
};
export type RunSelfHostedTaskIacCompletedRequest = {
    /** The schema version */
    schemaVersion: string;
    /** The Task ULID */
    runTaskId: string;
    /** Whether this task completed successfully or not */
    status: "SUCCESS" | "INTERNAL_ERROR";
    /** The error message, if it exists */
    messageError?: string;
    /** Metadata */
    metadata?: {
        [key: string]: object;
    };
};
export type TaskDestroyDataResponse = {
    schemaVersion: string;
    runId: string;
    runTaskId: string;
    iacBackend: TaskDataS3BackendResponse;
    tfBackend: TaskDataS3BackendResponse;
    metadata?: {
        [key: string]: object;
    };
    runEnvironment: string[];
};
export type RunSelfHostedTaskDestroyCompletedRequest = {
    /** The schema version */
    schemaVersion: string;
    /** The Task ULID */
    runTaskId: string;
    /** Whether this task completed successfully or not */
    status: "SUCCESS" | "INTERNAL_ERROR" | "FAILED";
    /** The error message, if it exists */
    messageError?: string;
    /** The deploy output, to be used to generate the connection interfaces */
    output?: {
        [key: string]: object;
    };
    /** Metadata */
    metadata?: {
        [key: string]: object;
    };
    /** partialResources */
    partialResources?: string[];
};
export type TaskDeployDataResponse = {
    schemaVersion: string;
    runId: string;
    runTaskId: string;
    iacBackend: TaskDataS3BackendResponse;
    tfBackend: TaskDataS3BackendResponse;
    fork: boolean;
    allowedResources?: string[];
    metadata?: {
        [key: string]: object;
    };
    runEnvironment: string[];
};
export type RunSelfHostedTaskDeployCompletedRequest = {
    /** The schema version */
    schemaVersion: string;
    /** The Task ULID */
    runTaskId: string;
    /** Whether this task completed successfully or not */
    status: "SUCCESS" | "INTERNAL_ERROR" | "FAILED";
    /** The error message, if it exists */
    messageError?: string;
    /** The deploy output, to be used to generate the connection interfaces */
    output?: {
        [key: string]: object;
    };
    /** Metadata */
    metadata?: {
        [key: string]: object;
    };
    partialResources?: string[];
};
export type CreateFeatureFlagRequest = {
    appId?: string;
    infraId?: string;
    workspaceId?: string;
    realm: string;
    description: string;
};
export type RunDestroyRequest = {
    /** Application Id */
    appId?: string;
    /** Shared Infra Id */
    infraId?: string;
    /** Workspace Id */
    workspaceId: string;
    /** Environment Id */
    envId: string;
};
export type RunCreatedResponse = {
    runId: string;
};
export type WorkerResponse = {
    allowed: boolean;
    reason?: string;
};
export type ConfigTerraform = {
    /** name of the bucket to save state files */
    bucket: string;
    /** name of the region of the bucket */
    region: string;
};
export type Config = {
    /** The terraform backend configuration */
    tfstate: ConfigTerraform;
    /** The terraform backend configuration */
    iac: ConfigTerraform;
};
export type RunSelfHostedRollbackRequest = {
    /** Application Id */
    appId?: string;
    /** Shared Infra Id */
    infraId?: string;
    /** Environment Id */
    envId: string;
    /** Current version tag to rollback */
    tag: string;
    /** Backend configuration */
    config: Config;
    /** Url of pipeline currently running */
    pipelineUrl: string;
    /** Stackspot Workflow Execution Identifier */
    workflowExecutionId?: string;
};
export type RunSelfHostedTaskResponse = {
    order: number;
    runTaskId: string;
    taskType: string;
    pluginAppliedAlias?: string;
};
export type RunSelfHostedResponse = {
    runId: string;
    runType: string;
    tasks: RunSelfHostedTaskResponse[];
};
export type RunSelfHostedDestroyRequest = {
    /** Application Id */
    appId?: string;
    /** Shared Infra Id */
    infraId?: string;
    /** Workspace Id */
    workspaceId: string;
    /** Environment Id */
    envId: string;
    /** Backend configuration */
    config: Config;
    /** Url of pipeline currently running */
    pipelineUrl: string;
    /** Stackspot Workflow Execution Identifier */
    workflowExecutionId?: string;
};
export type ManifestoMetadata = {
    /** Name */
    name: string;
    isTest?: string;
};
export type Connection = {
    /** Required connector name */
    selected: string;
    /** Required connector type */
    "type": string;
    /** Required connector label reference */
    alias: string;
};
export type ManifestoConnection = {
    requires?: Connection[];
    generates?: Connection[];
};
export type Link = {
    /** Required link name */
    name: string;
    /** Required link url */
    url: string;
    /** Required link type */
    "type": string;
    /** Link picture path */
    picture: string;
};
export type ManifestoLink = {
    generates?: Link[];
};
export type AppliedPlugin = {
    /** Plugin Alias */
    alias: string;
    /** Plugin Name */
    name: string;
    /** Plugin Version Id */
    pluginVersionId: string;
    /** Stack Version Id */
    stackVersionId: string;
    /** Plugin Type */
    "type": string;
    inputs: {
        [key: string]: object;
    };
    connections: ManifestoConnection;
    links?: ManifestoLink;
    fork?: boolean;
};
export type ManifestoSpec = {
    /** Application Or Infra Id ( */
    id: string;
    /** Repository */
    repository?: string;
    appliedPlugins: AppliedPlugin[];
};
export type Manifesto = {
    /** Schema Version */
    schemaVersion: string;
    /** Manifesto Kind */
    kind: string;
    /** Manifesto Kind */
    metadata: ManifestoMetadata;
    /** Manifesto Spec */
    spec: ManifestoSpec;
};
export type RunSelfHostedDeployRequest = {
    /** Environment Id */
    envId: string;
    /** Workspace Id */
    workspaceId: string;
    /** Version tag that will be generated by the deploy run if successful */
    versionTag: string;
    /** Run Configuration */
    runConfig?: {
        [key: string]: object;
    };
    /** Manifesto Data */
    manifesto: Manifesto;
    /** Whether this application exposes an API or not */
    isApi?: boolean;
    /** Path (in the repository) of the API contract file in open api format */
    apiContractPath?: string;
    /** Backend configuration */
    config: Config;
    /** Url of pipeline currently running */
    pipelineUrl: string;
    /** Stackspot Workflow Execution Identifier */
    workflowExecutionId?: string;
};
export type RunRollbackRequest = {
    /** Application Id */
    appId?: string;
    /** Shared Infra Id */
    infraId?: string;
    /** Environment Id */
    envId: string;
    /** Current version tag to rollback */
    tag: string;
};
export type RunDeployRequest = {
    /** Environment Id */
    envId: string;
    /** Workspace Id */
    workspaceId: string;
    /** Version tag that will be generated by the deploy run if successful */
    versionTag: string;
    /** Run Configuration */
    runConfig?: {
        [key: string]: object;
    };
    /** Manifesto Data */
    manifesto: Manifesto;
    /** Whether this application exposes an API or not */
    isApi?: boolean;
    /** Path (in the repository) of the API contract file in open api format */
    apiContractPath?: string;
};
export type Pageable = {
    page?: number;
    size?: number;
    sort?: string[];
};
export type RunV2FlagResponse = {
    ulid: string;
    appId?: string;
    infraId?: string;
    workspaceId?: string;
    realm: string;
    description: string;
};
export type PageMetadata = {
    size?: number;
    "number"?: number;
    totalElements?: number;
    totalPages?: number;
};
export type PagedModelRunV2FlagResponse = {
    content?: RunV2FlagResponse[];
    page?: PageMetadata;
};
export type FinishWorkerIacSchema = {
    schemaVersion: string;
    runTaskId: string;
    runId?: string;
    status: "SUCCESS" | "INTERNAL_ERROR";
    messageError: string;
    metadata?: {
        [key: string]: object;
    };
};
export type FinishWorkerDestroySchema = {
    schemaVersion: string;
    runTaskId: string;
    runId?: string;
    status: "SUCCESS" | "INTERNAL_ERROR" | "FAILED";
    messageError: string;
    tfstatePath?: string;
    metadata?: {
        [key: string]: object;
    };
    partialResources?: string[];
};
export type FinishWorkerDeploySchema = {
    schemaVersion: string;
    runTaskId: string;
    runId?: string;
    status: "SUCCESS" | "INTERNAL_ERROR" | "FAILED";
    messageError: string;
    metadata?: {
        [key: string]: object;
    };
    output?: {
        [key: string]: object;
    };
    partialResources?: string[];
};
export type StartWorkerIacSchemaConnectorV2 = {
    connector: string;
    alias: string;
    "type": string;
    pluginName: string;
    attributes: {
        [key: string]: object;
    };
    writeToFile: boolean;
    appliedPluginAlias?: string;
};
export type PluginsApplied = {
    schemaVersion: string;
    pluginAppliedAlias: string;
    name: string;
    logPath: string;
    inputs?: {
        [key: string]: object;
    };
    runEnvironment: string[];
    oldTfStatePath?: string;
    fork: boolean;
    allowedResources?: string[];
    removed: boolean;
    connectors: StartWorkerIacSchemaConnectorV2[];
};
export type BucketBackend = {
    bucket: string;
    region: string;
    key: string;
};
export type AccountConnectionsResponseV2 = {
    id: string;
    workspaceId: string;
    environmentId: string;
    provider: string;
    "type": string;
    status: string;
    credentialSecretIdentifier?: string;
    externalId?: string;
};
export type RunTaskResponseV2 = {
    appId: string;
    runId: string;
    runTaskId: string;
    "type": "IAC" | "DEPLOY" | "DESTROY" | "IAC_SELF_HOSTED" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "UNIFIED_IAC" | "UNIFIED_DEPLOY" | "UNIFIED_DESTROY" | "PLAN";
    workspaceName: string;
    needsMigration?: boolean;
    realm: string;
    email?: string;
    iacPath: string;
    logPath: string;
    hclPath: string;
    tfstatePath: string;
    metadata: {
        [key: string]: object;
    };
    pluginsApplied: PluginsApplied[];
    iacBackend?: BucketBackend;
    tfBackend?: BucketBackend;
    cloudAccount?: AccountConnectionsResponseV2;
};
export type TagResponse = {
    name: string;
    createdAt: string;
    head: boolean;
};
export type EnvironmentResponse = {
    name?: string;
};
export type RunTaskResponse = {
    id?: string;
    "type": "IAC" | "DEPLOY" | "DESTROY" | "IAC_SELF_HOSTED" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "UNIFIED_IAC" | "UNIFIED_DEPLOY" | "UNIFIED_DESTROY" | "PLAN";
    status: "PENDING" | "READY_TO_RUN" | "RUNNING" | "SUCCEEDED" | "FAILED" | "INTERNAL_ERROR" | "EXTERNAL_ERROR" | "ABORTED";
    errorDetails?: string;
    logs?: string;
};
export type RunPluginResponse = {
    pluginAppliedAlias?: string;
    tasks: RunTaskResponse[];
};
export type RunResponse = {
    runId: string;
    appId?: string;
    infraId?: string;
    envId: string;
    deploymentId?: string;
    "type": "DEPLOY" | "DESTROY" | "ROLLBACK" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "ROLLBACK_SELF_HOSTED";
    status: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
    createdAt: string;
    updatedAt?: string;
    appliedPlugins?: RunPluginResponse[];
    workspaceId: string;
    accountId: string;
    version: "V1" | "V2";
};
export type RunLightResponse = {
    runId: string;
    appId?: string;
    infraId?: string;
    envId: string;
    deploymentId?: string;
    author?: string;
    "type": "DEPLOY" | "DESTROY" | "ROLLBACK" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "ROLLBACK_SELF_HOSTED";
    status: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
    createdAt: string;
    updatedAt?: string;
};
export type ConnectionInterfaceResponse = {
    name: string;
    "type": string;
    outputs: {
        [key: string]: object;
    };
};
export type PluginDeploymentResponse = {
    pluginAppliedAlias: string;
    pluginVersionId: string;
    stackVersionId: string;
    inputs: {
        [key: string]: object;
    };
    connectors: ConnectionInterfaceResponse[];
};
export type DeploymentResponse = {
    deploymentId: string;
    appId?: string;
    infraId?: string;
    envId: string;
    head: boolean;
    tag?: string;
    createdAt?: string;
    plugins: PluginDeploymentResponse[];
};
export type DeploymentStatusModel = {
    status: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
};
export type DiffPluginResponse = {
    appManifesto: {
        [key: string]: object;
    };
};
export type RunProjection = {
    createdAt: string;
    updatedAt: string;
    requester: string;
    deploymentUlid: string;
    manifesto?: string;
    isSelfHosted: boolean;
    tagId?: number;
    selfHostedConfig?: string;
    runUlid: string;
    status: string;
    head?: string;
    runVersion: string;
    runId: number;
    appId: string;
    envId: string;
    deploymentId: number;
    "type": string;
    tag?: string;
};
export type PagedModelRunProjection = {
    content?: RunProjection[];
    page?: PageMetadata;
};
export type SortObject = {
    sorted?: boolean;
    unsorted?: boolean;
    empty?: boolean;
};
export type PageableObject = {
    pageNumber?: number;
    paged?: boolean;
    pageSize?: number;
    unpaged?: boolean;
    offset?: number;
    sort?: SortObject;
};
export type AdminRunTaskResponse = {
    id?: string;
    "type": "IAC" | "DEPLOY" | "DESTROY" | "IAC_SELF_HOSTED" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "UNIFIED_IAC" | "UNIFIED_DEPLOY" | "UNIFIED_DESTROY" | "PLAN";
    status: "PENDING" | "READY_TO_RUN" | "RUNNING" | "SUCCEEDED" | "FAILED" | "INTERNAL_ERROR" | "EXTERNAL_ERROR" | "ABORTED";
    errorDetails?: string;
    logs?: string;
    iac?: string;
};
export type AdminRunPluginResponse = {
    pluginAppliedAlias: string;
    tasks: AdminRunTaskResponse[];
};
export type AdminRunResponse = {
    runId: string;
    appId?: string;
    infraId?: string;
    envId: string;
    deploymentId?: string;
    manifesto: {
        [key: string]: object;
    };
    "type": "DEPLOY" | "DESTROY" | "ROLLBACK" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "ROLLBACK_SELF_HOSTED";
    status: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
    createdAt: string;
    updatedAt?: string;
    appliedPlugins?: AdminRunPluginResponse[];
};
export type PageAdminRunResponse = {
    totalPages?: number;
    totalElements?: number;
    pageable?: PageableObject;
    numberOfElements?: number;
    first?: boolean;
    last?: boolean;
    size?: number;
    content?: AdminRunResponse[];
    "number"?: number;
    sort?: SortObject;
    empty?: boolean;
};
export type RunTaskProjection = {
    appliedPlugin?: string;
    pluginName: string;
    rtulid: string;
    partialResources?: string;
    worker?: string;
    createdAt: string;
    updatedAt: string;
    manifesto?: string;
    isPostProcessingError: boolean;
    status: string;
    error?: string;
    requiredRunTasks?: string;
    iacPath?: string;
    id: number;
    "type": string;
    alias?: string;
};
export type RunTaskPluginProjection = {
    appliedPlugin?: string;
    pluginName: string;
    partialResources?: string;
    createdAt: string;
    updatedAt: string;
    manifesto?: string;
    ulid: string;
    status: string;
    error?: string;
    alias?: string;
};
export type PluginDeploymentProjection = {
    pluginUlid: string;
    pluginId: number;
    tfstate: string;
    reqconns: string;
    manifesto: string;
    pluginVersionId: string;
    stackVersionId: string;
    alias: string;
};
export type SelfHostedConfigModel = {
    terraformBucket: string;
    terraformRegion: string;
    iacBucket: string;
    iacRegion: string;
};
export type AdminRunTaskDetailResponse = {
    runTaskId: string;
    runId: string;
    deploymentId: string;
    userRef?: string;
    workspaceId: string;
    workspaceName: string;
    accountId: string;
    envId: string;
    appId?: string;
    infraId?: string;
    realm: string;
    pluginAppliedAlias?: string;
    pluginManifesto: {
        [key: string]: object;
    };
    pluginFQDN?: string;
    runTaskType: "IAC" | "DEPLOY" | "DESTROY" | "IAC_SELF_HOSTED" | "DEPLOY_SELF_HOSTED" | "DESTROY_SELF_HOSTED" | "UNIFIED_IAC" | "UNIFIED_DEPLOY" | "UNIFIED_DESTROY" | "PLAN";
    runTasksStatus: "PENDING" | "READY_TO_RUN" | "RUNNING" | "SUCCEEDED" | "FAILED" | "INTERNAL_ERROR" | "EXTERNAL_ERROR" | "ABORTED";
    errorDetails?: string;
    iacPath?: string;
    workerUrl?: string;
    runTaskData: {
        [key: string]: object;
    };
    requiredRunTasks: string[];
    order: number;
    selfHostedConfig?: SelfHostedConfigModel;
    exception?: string;
    iacDownloadUrl?: string;
    logsDownloadUrl?: string;
};
export type AppsInRealmProjection = {
    appid: string;
    lastDeploymentDate: string;
    appName?: string;
    workspaceId: string;
    workspaceName: string;
};
export type PagedModelAppsInRealmProjection = {
    content?: AppsInRealmProjection[];
    page?: PageMetadata;
};
export type AppInfoProjection = {
    isApp: boolean;
    envIds: string[];
    appId: string;
    workspaceId: string;
    workspaceName: string;
    realm: string;
};
export declare function setAsError({ runId, setRunAsErrorRequest }: {
    runId: string;
    setRunAsErrorRequest: SetRunAsErrorRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
export declare function finishV2Task({ runId, finishIntegratedWorkerSchema }: {
    runId: string;
    finishIntegratedWorkerSchema: FinishIntegratedWorkerSchema;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to get the necessary data to perform an IAC Task
 */
export declare function getIacTask({ taskId }: {
    taskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TaskIacDataResponse>;
/**
 * Endpoint to inform the completion of an IAC Task
 */
export declare function putIacTaskResponse({ taskId, runSelfHostedTaskIacCompletedRequest }: {
    taskId: string;
    runSelfHostedTaskIacCompletedRequest: RunSelfHostedTaskIacCompletedRequest;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to get the necessary data to perform an Destroy Task
 */
export declare function getDestroyTask({ taskId }: {
    taskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TaskDestroyDataResponse>;
/**
 * Endpoint to inform the completion of a Destroy Task
 */
export declare function putDestroyTaskResponse({ taskId, runSelfHostedTaskDestroyCompletedRequest }: {
    taskId: string;
    runSelfHostedTaskDestroyCompletedRequest: RunSelfHostedTaskDestroyCompletedRequest;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to get the necessary data to perform a Deploy Task
 */
export declare function getDeployTask({ taskId }: {
    taskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TaskDeployDataResponse>;
/**
 * Endpoint to inform the completion of a Deploy Task
 */
export declare function putDeployTaskResponse({ taskId, runSelfHostedTaskDeployCompletedRequest }: {
    taskId: string;
    runSelfHostedTaskDeployCompletedRequest: RunSelfHostedTaskDeployCompletedRequest;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
export declare function updateFeatureFlag({ ulid, createFeatureFlagRequest }: {
    ulid: string;
    createFeatureFlagRequest: CreateFeatureFlagRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
export declare function deleteFeatureFlag({ ulid }: {
    ulid: string;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Infra Deploy
 */
export declare function runDestroyInfra({ runDestroyRequest }: {
    runDestroyRequest: RunDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to run App Deploy
 */
export declare function runDestroyApp({ runDestroyRequest }: {
    runDestroyRequest: RunDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to identify the worker that got this tasks to process
 */
export declare function getRunTaskById({ taskId, workerUrl }: {
    taskId: string;
    workerUrl: string;
}, opts?: Oazapfts.RequestOpts): Promise<WorkerResponse>;
/**
 * Endpoint to run Infra Rollback
 */
export declare function runRollbackInfra({ runSelfHostedRollbackRequest }: {
    runSelfHostedRollbackRequest: RunSelfHostedRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run App Rollback
 */
export declare function runRollbackApp({ runSelfHostedRollbackRequest }: {
    runSelfHostedRollbackRequest: RunSelfHostedRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run Destroy SelfHosted
 */
export declare function runDestroyInfra1({ runSelfHostedDestroyRequest }: {
    runSelfHostedDestroyRequest: RunSelfHostedDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Destroy SelfHosted
 */
export declare function runDestroyApp1({ runSelfHostedDestroyRequest }: {
    runSelfHostedDestroyRequest: RunSelfHostedDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Infra Deploy
 */
export declare function runDeployInfra({ runSelfHostedDeployRequest }: {
    runSelfHostedDeployRequest: RunSelfHostedDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to run App Deploy
 */
export declare function runDeployApp({ runSelfHostedDeployRequest }: {
    runSelfHostedDeployRequest: RunSelfHostedDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunSelfHostedResponse>;
/**
 * Endpoint to force status RUNTIME_ERROR to a run by runId
 */
export declare function setRunAsFailed({ runId }: {
    runId: string;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Endpoint to run Infra Rollback
 */
export declare function runRollbackInfra1({ runRollbackRequest }: {
    runRollbackRequest: RunRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to run App Rollback
 */
export declare function runRollbackApp1({ runRollbackRequest }: {
    runRollbackRequest: RunRollbackRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to run Destroy
 */
export declare function runDestroyInfra2({ runDestroyRequest }: {
    runDestroyRequest: RunDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Destroy
 */
export declare function runDestroyApp2({ runDestroyRequest }: {
    runDestroyRequest: RunDestroyRequest;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
/**
 * Endpoint to run Infra Deploy
 */
export declare function runDeployInfra1({ runDeployRequest }: {
    runDeployRequest: RunDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to run App Deploy
 */
export declare function runDeployApp1({ runDeployRequest }: {
    runDeployRequest: RunDeployRequest;
}, opts?: Oazapfts.RequestOpts): Promise<RunCreatedResponse>;
/**
 * Endpoint to cancel a run that's currently running
 */
export declare function cancelAppRunByRunId({ runId, force }: {
    runId: string;
    force?: boolean;
}, opts?: Oazapfts.RequestOpts): Promise<string>;
export declare function listAllFeatureFlags({ pageable }: {
    pageable: Pageable;
}, opts?: Oazapfts.RequestOpts): Promise<PagedModelRunV2FlagResponse>;
export declare function createFeatureFlag({ createFeatureFlagRequest }: {
    createFeatureFlagRequest: CreateFeatureFlagRequest;
}, opts?: Oazapfts.RequestOpts): Promise<string>;
/**
 * Simulate a response from deploy worker
 */
export declare function simulateIacWorkerResponse({ finishWorkerIacSchema }: {
    finishWorkerIacSchema: FinishWorkerIacSchema;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Endpoint to cancel a run that's currently running
 */
export declare function simulateIacWorkerResponseForAllTasks({ runId }: {
    runId: string;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Simulate a response from deploy worker
 */
export declare function simulateDestroyWorkerResponse({ finishWorkerDestroySchema }: {
    finishWorkerDestroySchema: FinishWorkerDestroySchema;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Simulate a response from deploy worker
 */
export declare function simulateDeployWorkerResponse({ finishWorkerDeploySchema }: {
    finishWorkerDeploySchema: FinishWorkerDeploySchema;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Endpoint to force to resend all "ready to run" tasks by runId
 */
export declare function resendTasks({ runId }: {
    runId: string;
}, opts?: Oazapfts.RequestOpts): Promise<boolean>;
/**
 * Endpoint to block a StackSpot Workspace to perform Runtime operations
 */
export declare function blockWorkspace({ workspaceId }: {
    workspaceId: string;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Endpoint to block a StackSpot Account to perform Runtime operations
 */
export declare function blockAccount({ accountId }: {
    accountId: string;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
export declare function addInputs({ runId, body }: {
    runId: string;
    body: {
        [key: string]: object;
    };
}, opts?: Oazapfts.RequestOpts): Promise<never>;
export declare function getNextTaskData({ runId }: {
    runId: string;
}, opts?: Oazapfts.RequestOpts): Promise<RunTaskResponseV2>;
/**
 * Endpoint to get tag data
 */
export declare function getTagsByInfraIdAndEnvId({ infraId, envId }: {
    infraId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TagResponse[]>;
/**
 * Endpoint to get tag data
 */
export declare function getTagsByAppIdAndEnvId({ appId, envId }: {
    appId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<TagResponse[]>;
/**
 * Endpoint to get environment
 */
export declare function getAllEnvironmentConfiguration(opts?: Oazapfts.RequestOpts): Promise<EnvironmentResponse[]>;
/**
 * Endpoint to get run data by runId
 */
export declare function getRunById({ runId }: {
    runId: string;
}, opts?: Oazapfts.RequestOpts): Promise<RunResponse>;
/**
 * Endpoint to get runs data by infraId and envId, sorted by createdAt descending
 */
export declare function getRunsByInfraIdAndEnvId({ size, page, infraId, envId, status }: {
    size?: number;
    page?: number;
    infraId: string;
    envId: string;
    status?: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
}, opts?: Oazapfts.RequestOpts): Promise<RunLightResponse[]>;
/**
 * Endpoint to get runs data by appId and envId, sorted by createdAt descending
 */
export declare function getRunsByAppIdAndEnvId({ size, page, appId, envId, status }: {
    size?: number;
    page?: number;
    appId: string;
    envId: string;
    status?: "RUNNING" | "SUCCEEDED" | "USER_ERROR" | "RUNTIME_ERROR" | "EXTERNAL_ERROR" | "ABORTING" | "ABORTED";
}, opts?: Oazapfts.RequestOpts): Promise<RunLightResponse[]>;
/**
 * Endpoint to get deployment data by deploymentId
 */
export declare function getDeploymentById({ deploymentId }: {
    deploymentId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse>;
/**
 * Endpoint to get deployment data by infraId and envId, sorted by creation date descending
 */
export declare function getDeploymentByInfraIdAndEnvId({ size, page, infraId, envId }: {
    size?: number;
    page?: number;
    infraId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse[]>;
/**
 * Endpoint to get deployment head data by appId and envId
 */
export declare function getDeploymentHeadByInfraIdAndEnvId({ infraId, envId }: {
    infraId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse>;
/**
 * Endpoint to get last deployment status
 */
export declare function getDeploymentStatus({ appId, envId }: {
    appId?: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentStatusModel>;
/**
 * Endpoint to get last deployment status
 */
export declare function getDeploymentStatus1({ infraId, envId }: {
    infraId?: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentStatusModel>;
export declare function getDiffByInfra({ infraId, envId }: {
    infraId?: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DiffPluginResponse>;
export declare function getDiffByApp({ appId, envId }: {
    appId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DiffPluginResponse>;
/**
 * Endpoint to get deployment data by appId and envId, sorted by creation date descending
 */
export declare function getDeploymentByAppIdAndEnvId({ size, page, appId, envId }: {
    size?: number;
    page?: number;
    appId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse[]>;
/**
 * Endpoint to get deployment head data by appId and envId
 */
export declare function getDeploymentHeadByAppIdAndEnvId({ appId, envId }: {
    appId: string;
    envId: string;
}, opts?: Oazapfts.RequestOpts): Promise<DeploymentResponse>;
export declare function getRunsRunning({ page, size }: {
    page?: number;
    size?: number;
}, opts?: Oazapfts.RequestOpts): Promise<PagedModelRunProjection>;
export declare function getRunsOnEnv({ appId, envId, page, size }: {
    appId: string;
    envId: string;
    page?: number;
    size?: number;
}, opts?: Oazapfts.RequestOpts): Promise<PagedModelRunProjection>;
export declare function getRunsOnAllEnvs({ appId, page, size }: {
    appId: string;
    page?: number;
    size?: number;
}, opts?: Oazapfts.RequestOpts): Promise<PagedModelRunProjection>;
export declare function getRunByUlid({ runUlid }: {
    runUlid: string;
}, opts?: Oazapfts.RequestOpts): Promise<RunProjection>;
/**
 * Get task with workspaceName, appId or InfraId that have status RUNNING
 */
export declare function getAdminRunStatusRunningDetails({ workspaceName, pageable }: {
    workspaceName: string;
    pageable: Pageable;
}, opts?: Oazapfts.RequestOpts): Promise<PageAdminRunResponse>;
/**
 * Get task with workspaceName, appId or InfraId that have status RUNNING
 */
export declare function getAdminRunStatusRunningDetails1({ infraId, pageable }: {
    infraId?: string;
    pageable: Pageable;
}, opts?: Oazapfts.RequestOpts): Promise<PageAdminRunResponse>;
/**
 * Get task with workspaceName, appId or InfraId that have status RUNNING
 */
export declare function getAdminRunStatusRunningDetails2({ appId, pageable }: {
    appId?: string;
    pageable: Pageable;
}, opts?: Oazapfts.RequestOpts): Promise<PageAdminRunResponse>;
export declare function getRunTasks({ runUlid }: {
    runUlid: string;
}, opts?: Oazapfts.RequestOpts): Promise<RunTaskProjection[]>;
export declare function getRunTaskPlugins({ runUlid }: {
    runUlid: string;
}, opts?: Oazapfts.RequestOpts): Promise<RunTaskPluginProjection[]>;
export declare function getPluginDeployments({ runUlid }: {
    runUlid: string;
}, opts?: Oazapfts.RequestOpts): Promise<PluginDeploymentProjection[]>;
/**
 * Get task details from run task id
 */
export declare function getAdminRunTaskDetails({ runTaskId }: {
    runTaskId: string;
}, opts?: Oazapfts.RequestOpts): Promise<AdminRunTaskDetailResponse>;
/**
 * Get a run from run or run task id
 */
export declare function getAdminRun({ runId, runTaskId }: {
    runId?: string;
    runTaskId?: string;
}, opts?: Oazapfts.RequestOpts): Promise<AdminRunResponse>;
export declare function getAppsInRealm({ realm, page, size }: {
    realm: string;
    page?: number;
    size?: number;
}, opts?: Oazapfts.RequestOpts): Promise<PagedModelAppsInRealmProjection>;
export declare function getAppInfo({ appId }: {
    appId: string;
}, opts?: Oazapfts.RequestOpts): Promise<AppInfoProjection>;
//# sourceMappingURL=apiRuntime.d.ts.map