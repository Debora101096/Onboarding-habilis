/**
 * Notification Engine
 * 1.0.0
 * DO NOT MODIFY - This file has been generated using oazapfts.
 * See https://www.npmjs.com/package/oazapfts
 */
import * as Oazapfts from "@oazapfts/runtime";
export declare const defaults: Oazapfts.Defaults<Oazapfts.CustomHeaders>;
export declare const servers: {
    generatedServerUrl: string;
};
export type NotificationContentRequest = {
    /** User friendly title for the notification */
    title: string;
    /** User friendly description for the notification (allows the use of markdown) */
    description: string;
};
export type NotificationTargetBase = {
    "type": string;
};
export type AccountValue = {
    "type": "AccountValue";
} & NotificationTargetBase & {
    value?: string;
};
export type Attribute = {
    key: string;
    value: string;
};
export type Value = {
    attribute?: Attribute;
    resourceType: string;
    resourceSlug: string;
    action: string;
};
export type ResourceValue = {
    "type": "ResourceValue";
} & NotificationTargetBase & {
    value?: Value;
};
export type UsersValue = {
    "type": "UsersValue";
} & NotificationTargetBase & {
    value?: string[];
};
export type CreateTenantNotificationRequest = {
    /** Map of language codes to notification content. Each entry represents the content of the notification in a specific language. */
    content: {
        [key: string]: NotificationContentRequest;
    };
    /** Level of broadcasting to the notification. */
    broadcast_level: "ACCOUNT" | "INDIVIDUAL" | "PLATFORM" | "RESOURCE" | "ACCOUNT" | "INDIVIDUAL" | "RESOURCE";
    target: AccountValue | ResourceValue | UsersValue;
    /** Criticality of the notification. */
    criticality?: "LOW" | "MEDIUM" | "HIGH" | "LOW" | "MEDIUM" | "HIGH";
    /** Which context to publish the notification */
    context: "ACCOUNT" | "STUDIO" | "WORKSPACE" | "AI" | "Account" | "Studio" | "Workspace";
    /** Possible redirect link for the notification button. */
    call_to_action: string;
    /** If the notification should be re-consumed until 'last_until' is reached. */
    persistent?: boolean;
    /** UTC formatted timestamp to when the notification should finally end, if the persistent is set to true. */
    last_until?: string;
    /** UTC formatted timestamp for when to triggers the notification. */
    trigger_at: string;
    /** Notification channel audience. Determines which platform will receive the notification. */
    audience?: "AI" | "EDP" | "ACCOUNT" | "ACCOUNT" | "AI" | "EDP";
};
export type ErrorDetails = {
    code: "INTEGRATION_EXCEPTION" | "INVALID_TENANT" | "VALIDATION_ERROR" | "MANDATORY_FIELD_NOT_INFORMED" | "INVALID_REQUEST" | "NOTIFICATION_NOT_FOUND" | "INVALID_FIELD" | "MISSING_TOKEN";
    field?: string;
    details?: string;
    values?: string[];
};
export type ApiErrorResponse = {
    code?: "INTEGRATION_EXCEPTION" | "INVALID_TENANT" | "VALIDATION_ERROR" | "MANDATORY_FIELD_NOT_INFORMED" | "INVALID_REQUEST" | "NOTIFICATION_NOT_FOUND" | "INVALID_FIELD" | "MISSING_TOKEN";
    status: number;
    message: string;
    details?: ErrorDetails[];
};
export type CreatePlatformNotificationRequest = {
    /** Map of language codes to notification content. Each entry represents the content of the notification in a specific language. */
    content: {
        [key: string]: NotificationContentRequest;
    };
    target?: ResourceValue;
    /** Criticality of the notification. */
    criticality?: "LOW" | "MEDIUM" | "HIGH" | "LOW" | "MEDIUM" | "HIGH";
    /** Which context to publish the notification */
    context: "ACCOUNT" | "STUDIO" | "WORKSPACE" | "AI" | "Account" | "Studio" | "Workspace";
    /** Possible redirect link for the notification button. */
    call_to_action: string;
    /** If the notification should be re-consumed until last_until is reached. */
    persistent?: boolean;
    /** UTC formatted timestamp to when the notification should finally ended if the persistent is set to true. */
    last_until?: string;
    /** UTC formatted timestamp for when to triggers the notification. */
    trigger_at: string;
    /** If the notification should be shown as banner. */
    is_banner?: boolean;
    /** Notification channel audience. Determines which platform will receive the notification. */
    audience?: "AI" | "EDP" | "ACCOUNT" | "ACCOUNT" | "AI" | "EDP";
};
export type CreatePlatformNotificationResponse = {
    intentId: string;
};
export type NotificationContentResponse = {
    title: string;
    description: string;
};
export type GetTenantNotificationsResponse = {
    id: string;
    content: {
        [key: string]: NotificationContentResponse;
    };
    broadcast_level: "ACCOUNT" | "INDIVIDUAL" | "PLATFORM" | "RESOURCE";
    context: "ACCOUNT" | "STUDIO" | "WORKSPACE" | "AI";
    criticality: "LOW" | "MEDIUM" | "HIGH";
    call_to_action: string;
    persistent: boolean;
    committed: boolean;
    last_until?: string;
    trigger_at: string;
    created_at?: string;
    is_banner: boolean;
    audience?: "AI" | "EDP" | "ACCOUNT";
};
export type PagingResponseModelGetTenantNotificationsResponse = {
    items: GetTenantNotificationsResponse[];
    size: number;
    total_elements: number;
};
export type GetCommittedNotificationsResponse = {
    /** If there are uncommitted notifications for the user */
    uncommitted_messages: boolean;
};
/**
 * Generate a new notification intent to the specified tenant
 */
export declare function create({ dryRun, tenantId, createTenantNotificationRequest }: {
    dryRun?: boolean;
    tenantId: string;
    createTenantNotificationRequest: CreateTenantNotificationRequest;
}, opts?: Oazapfts.RequestOpts): Promise<object>;
/**
 * Allows to mark a notification as committed
 */
export declare function commit({ notificationId, tenantId }: {
    notificationId: string;
    tenantId: string;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Generate a new notification intent to the specified tenant
 */
export declare function create1({ createPlatformNotificationRequest }: {
    createPlatformNotificationRequest: CreatePlatformNotificationRequest;
}, opts?: Oazapfts.RequestOpts): Promise<CreatePlatformNotificationResponse>;
/**
 * Get notifications for tenant
 */
export declare function findAll({ size, page, createdSince, context, criticality, content, committed, isBanner, audience, tenantId }: {
    size?: number;
    page?: number;
    createdSince?: number;
    context?: "ACCOUNT" | "STUDIO" | "WORKSPACE" | "AI";
    criticality?: "LOW" | "MEDIUM" | "HIGH";
    content?: string;
    committed?: boolean;
    isBanner?: boolean;
    audience?: "AI" | "EDP" | "ACCOUNT";
    tenantId: string;
}, opts?: Oazapfts.RequestOpts): Promise<PagingResponseModelGetTenantNotificationsResponse>;
/**
 * Allows to check if there are any uncommitted notifications for the user
 */
export declare function committedNotifications({ audience, tenantId }: {
    audience?: "AI" | "EDP" | "ACCOUNT";
    tenantId: string;
}, opts?: Oazapfts.RequestOpts): Promise<GetCommittedNotificationsResponse>;
/**
 * Actuator web endpoint 'health'
 */
export declare function health(opts?: Oazapfts.RequestOpts): Promise<object>;
/**
 * Actuator web endpoint 'health-path'
 */
export declare function getHealthz(opts?: Oazapfts.RequestOpts): Promise<object>;
/**
 * Delete notification by intent id
 */
export declare function deleteV1TenantsByTenantIdNotificationsAndNotificationIntentId({ notificationIntentId, tenantId }: {
    notificationIntentId: string;
    tenantId: string;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Allows to unmark a notification as committed
 */
export declare function uncommit({ notificationId, tenantId }: {
    notificationId: string;
    tenantId: string;
}, opts?: Oazapfts.RequestOpts): Promise<unknown>;
/**
 * Batches deletes the notification in all tenants
 */
export declare function delete1({ notificationIntentId }: {
    notificationIntentId: string;
}, opts?: Oazapfts.RequestOpts): Promise<never>;
//# sourceMappingURL=notification.d.ts.map