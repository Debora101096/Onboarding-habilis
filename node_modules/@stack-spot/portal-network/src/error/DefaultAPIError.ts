import { Dictionary } from '@stack-spot/portal-translate'
import { every, isString } from 'lodash'
import { actionDetails } from './dictionary/action-details'
import { baseDictionary } from './dictionary/base'
import { cntFields } from './dictionary/cnt-fields'
import { workspaceDetails } from './dictionary/workspace-details'
import { workspaceFields } from './dictionary/workspace-fields'
import { ignoredTitleErrorCodes } from './IgnoredErrorCodes'
import { ErrorDetailsProperties, StackspotAPIError } from './StackspotAPIError'
import { ErrorResponse, LanguageSuggestedMessageKeys, ValidationDetails } from './types'

// these details don't say anything the status already doesn't and we'd better use local translations for them.
const ignoredDescriptions = [
  'internal server error', 'not found', 'gateway timeout', 'temporally unavailable', 'forbidden', 'unauthorized', 'bad request',
]

const fieldDictionary = {
  cnt: cntFields,
  wks: workspaceFields,
}

const detailsDictionary = {
  wks: workspaceDetails,
  actionapi: actionDetails,
}

function getTitle(status: number, raw: ErrorResponse, dictionary: Dictionary, language: 'pt' | 'en') {
  if (ignoredTitleErrorCodes.includes(raw.code)) return ' '
  if (dictionary[language][raw.code]) return dictionary[language][raw.code]
  if (raw.details && !ignoredDescriptions.includes(raw.details)) return raw.details
  return (baseDictionary as Dictionary)[language][status] || baseDictionary[language].defaultTitle
}

function getValues(detail: ValidationDetails) {
  return detail.values && every(detail.values, isString) ? `\n${detail.values.join('\n')}` : ''
}

function getSuggestedMessages(suggestedMessage: ErrorResponse['suggestedMessages'] | null | undefined, language?: 'pt' | 'en') {
  const parseLanguage: Record<'pt' | 'en', LanguageSuggestedMessageKeys> = { pt: 'ptBr', en: 'enUs' }
  return suggestedMessage?.[parseLanguage?.[language || 'en']]
}

const UNIT_REGEX_TEMPLATE = /{\d}/g
const RANGE_REGEX_TEMPLATE = /{1-n}/g

function containsNumberInBraces(input: string) {
  return UNIT_REGEX_TEMPLATE.test(input) || RANGE_REGEX_TEMPLATE.test(input)
}

export function interpolateErrors(message: string, values: string[], fieldValuesFileContent: Record<string, string>) {
  return message
    .replace(UNIT_REGEX_TEMPLATE, (value) => {
      const position = +value.replace(/{|}/g, '')
      const index = position - 1

      const fieldValue = values[index]
      return fieldValuesFileContent[fieldValue] || fieldValue
    })
    .replace(RANGE_REGEX_TEMPLATE, () => values.toString())
}


function createMessage(status: number, raw: ErrorResponse, dictionary: Dictionary, language?: 'pt' | 'en'): ErrorDetailsProperties {
  const title = getTitle(status, raw, dictionary, language || 'en')
  const api = raw.code?.split(/[-_]/)[0]
  const dictDetails = (detailsDictionary[api?.toLowerCase() as keyof typeof detailsDictionary] ?? {})[language || 'en']
  const dictionaryDetails = raw.code && dictDetails ? dictDetails[raw.code] : {}

  if (raw?.validationDetails?.length) {

    const suggestedMessages = raw.validationDetails.map((detail) =>
      getSuggestedMessages(detail?.suggestedMessages, language)).filter((msg) => !!msg)

    if (suggestedMessages.length) {
      return { description: suggestedMessages.join('\n'), ...dictionaryDetails }
    }

    const details = raw.validationDetails?.map((detail) => {
      const dict: Record<string, string> =
        (fieldDictionary[api?.toLowerCase() as keyof typeof fieldDictionary] ?? {})[language || 'en'] ?? {}
      const codeTranslatedMessage = raw.code !== detail.code && dictionary[language || 'en'][detail.code]

      if (codeTranslatedMessage && containsNumberInBraces(codeTranslatedMessage) && (detail.values?.length || detail.field?.length)) {
        const value = detail.values?.length ? detail.values : (detail.field ? [detail.field] : [])
        return interpolateErrors(codeTranslatedMessage, value, dict)
      }

      const name = dict[detail.code] || detail.field || codeTranslatedMessage || detail.details || ''
      return `${name}${getValues(detail)}`
    })?.filter(d => !!d)
    return { description: details ? `${title}\n${details?.join('\n')}` : title, ...dictionaryDetails }
  }

  if (raw?.suggestedMessages) {
    const suggestedMessages = getSuggestedMessages(raw?.suggestedMessages, language)
    if (suggestedMessages) {
      return { description: suggestedMessages, ...dictionaryDetails }
    }
  }

  return { description: title, ...dictionaryDetails }
}

/**
 * This represents the Error thrown by most Stackspot APIs.
 */
export class DefaultAPIError extends StackspotAPIError {
  /**
   * The error object as defined by the Stackspot API. If the response doesn't match the expected format this will be undefined.
   */
  data?: ErrorResponse
  /**
   * The response data, if this matches the expected format expected by a Stackspot Error, it will be the same as `data`.
   */
  raw?: any

  constructor(
    /**
     * The response's data
     */
    rawResponse: any,
    /**
     * The response's status
     */
    status: number,
    /**
     * A dictionary for translating error codes and descriptions.
     */
    dictionary: Dictionary,
    /**
     * The response's headers.
     */
    headers?: Headers,
  ) {
    let parsedResponse
    try {
      parsedResponse = JSON.parse(rawResponse)
    } catch (error) {
      parsedResponse = rawResponse
    }

    super({
      status: status,
      code: parsedResponse.code,
      message: language => createMessage(status, parsedResponse, dictionary, language),
      headers,
    })
    this.raw = parsedResponse
    if (this.raw?.code !== undefined && this.raw?.status !== undefined && this.raw?.details !== undefined) this.data = parsedResponse
  }
}
