import { CompletablePromise } from '@stack-spot/opa'
import { StreamCanceledError } from '../error/StreamCanceledError'
import { StreamError } from '../error/StreamError'
import { StreamJsonError } from '../error/StreamJsonError'
import { FetchEventStream } from '../network/types'
import { StreamingStatus } from '../types'

type OnChangeListener<T> = (value: T[]) => void

interface ConstructorParams {
  /**
   * The promises that result in the EventStreams to build the final array.
   */
  eventsPromises: Promise<FetchEventStream>[],
  /**
   * A controller to abort the streaming.
   */
  abortController?: AbortController,
  /**
   * A minimum number of milliseconds to wait before calling onChange listeners.
   * @default 50
   */
  minChangeIntervalMS?: number,
  /***
   * Aborts this stream when the signal is aborted.
   */
  signal?: AbortSignal,
}

/**
 * An array represented by a stream where each event contains an item of the array as a JSON string. This can be watched as the stream runs.
 */
export class StreamedArray<T> {
  private onChangeListeners: OnChangeListener<T>[] = []
  private error: StreamError | undefined
  private data: T[] = []
  private fullPromise = new CompletablePromise<T[]>()
  private abortController: AbortController | undefined

  /**
   * @param response the fetch response.
   * @param minChangeIntervalMS a stream can be too fast. This sets a minimum interval between running the listeners. The default is 50ms.
   */
  constructor({ eventsPromises, abortController, minChangeIntervalMS = 50, signal }: ConstructorParams) {
    this.abortController = abortController ?? new AbortController()
    eventsPromises.forEach(eventsPromise => this.run(eventsPromise, minChangeIntervalMS))
    if (signal) {
      signal.addEventListener('abort', () => this.cancel())
    }
  }

  private async run(eventsPromise: Promise<FetchEventStream>, minChangeIntervalMS: number) {
    let lastChangeCall = 0
    try {
      const events = await eventsPromise
      let flushed = true
      for await (const event of events) {
        if (this.error) return
        if (event.data) {
          this.data.push(JSON.parse(event.data))
          if (new Date().getTime() - lastChangeCall >= minChangeIntervalMS) {
            this.onChangeListeners.forEach(l => l(this.data))
            lastChangeCall = new Date().getTime()
            flushed = true
          } else {
            flushed = false
          }
        }
      }
      if (!flushed) this.onChangeListeners.forEach(l => l(this.data))
    } catch (error: any) {
      if (error instanceof DOMException && error.name === 'AbortError') this.fail(new StreamCanceledError())
      if (error instanceof SyntaxError) this.fail(new StreamJsonError())
      else if (error instanceof StreamError) this.fail(error)
      else this.fail(new StreamError(error?.message || `${error}`))
    }
    if (!this.error) this.complete()
  }

  private clear() {
    this.onChangeListeners = []
    this.abortController = undefined
  }

  private fail(error: any) {
    this.error = error
    this.fullPromise.reject(this.error)
    this.clear()
  }

  private complete() {
    this.fullPromise.resolve(this.data)
    this.clear()
  }

  /**
   * Returns the full value of the array once the stream finishes.
   */
  getValue(): Promise<T[]> {
    return this.fullPromise.promise
  }

  /**
   * Returns the streamed array with every item streamed until now. This will be the complete array if the stream has finished.
   */
  getPartialValue(): T[] {
    return this.data
  }

  /**
   * Watches the array as it's streamed. This doesn't wait for the value to be complete.
   * 
   * The listener is called whenever the value changes.
   * 
   * @param listener the function to call with the new value.
   * @returns a function that, when called, removes the listener.
   */
  onChange(listener: (value: T[]) => void) {
    if (this.fullPromise.resolved) {
      listener(this.data)
      return () => {}
    }
    this.onChangeListeners.push(listener)
    return () => {
      const index = this.onChangeListeners?.findIndex(l => l === listener)
      if (index !== undefined && index >= 0) this.onChangeListeners?.splice(index, 1)
    }
  }

  getStatus(): StreamingStatus {
    if (this.error) return 'error'
    if (this.fullPromise.resolved) return 'success'
    return 'pending'
  }

  getError() {
    return this.error
  }

  /**
   * If this is a stream and it's not yet finished, calling this function cancels the stream.
   */
  cancel() {
    this.abortController?.abort(new StreamCanceledError())
  }
}
