import { CompletablePromise } from '@stack-spot/opa'
import { StreamCanceledError } from '../error/StreamCanceledError'
import { StreamError } from '../error/StreamError'
import { StreamJsonError } from '../error/StreamJsonError'
import { FetchEventStream } from '../network/types'
import { StreamingStatus } from '../types'

type OnChangeListener<T> = (value: Partial<T>) => void

interface ConstructorParams<T> {
  /**
   * The promise that results in the EventStream to build the final json.
   */
  eventsPromise: Promise<FetchEventStream>,
  /**
   * A controller to abort the streaming.
   */
  abortController: AbortController,
  /**
   * A minimum number of milliseconds to wait before calling onChange listeners.
   * @default 50
   */
  minChangeIntervalMS?: number,
  /**
   * Optional. If set, this function will be called with every streaming event and must transform the current data object according to the
   * message received.
   */
  transform?: (event: Partial<T>, data: Partial<T>) => void | Promise<void>,
  /**
   * Optional. Keys to ignore when merging the result with the current event. Ignored keys are always replaced by the newest value instead
   * of merged.
   */
  ignoreKeys?: (keyof T)[],
}

/**
 * An object represented by a JSON stream. This can be watched as the stream runs.
 */
export class StreamedJson<T> {
  private onChangeListeners: OnChangeListener<T>[] = []
  private error: StreamError | undefined
  private data: Partial<T> = {}
  private fullPromise = new CompletablePromise<T>()
  private abortController: AbortController | undefined
  private transform?: (event: Partial<T>, data: Partial<T>) => void | Promise<void>
  private ignoreKeys?: (keyof T)[]

  /**
   * @param response the fetch response.
   * @param minChangeIntervalMS a stream can be too fast. This sets a minimum interval between running the listeners. The default is 50ms.
   */
  constructor({ eventsPromise, abortController, minChangeIntervalMS = 50, transform, ignoreKeys }: ConstructorParams<T>) {
    this.abortController = abortController
    this.transform = transform
    this.ignoreKeys = ignoreKeys
    this.run(eventsPromise, minChangeIntervalMS)
  }

  private async run(eventsPromise: Promise<FetchEventStream>, minChangeIntervalMS: number) {
    let lastChangeCall = 0
    try {
      const events = await eventsPromise
      let flushed = true
      for await (const event of events) {
        if (this.error) return
        if (event.data) {
          let json
          try {
            json = JSON.parse(event.data)
          } catch (e) {
            // eslint-disable-next-line no-console
            console.warn('Mal formed JSON in streaming:', event.data)
            continue
          }
          await this.transform?.(json, this.data)
          this.merge(json, this.data)
          if (new Date().getTime() - lastChangeCall >= minChangeIntervalMS) {
            this.onChangeListeners.forEach(l => l(this.data))
            lastChangeCall = new Date().getTime()
            flushed = true
          } else {
            flushed = false
          }
        }
      }
      if (!flushed) this.onChangeListeners.forEach(l => l(this.data))
    } catch (error: any) {
      if (error instanceof DOMException && error.name === 'AbortError') this.fail(new StreamCanceledError())
      if (error instanceof SyntaxError) this.fail(new StreamJsonError())
      else if (error instanceof StreamError) this.fail(error)
      else this.fail(new StreamError(error?.message || `${error}`))
    }
    if (!this.error) this.complete()
  }

  private merge(source: Record<string, any>, target: Record<string, any>) {
    Object.keys(source).forEach((k) => {
      if (this.ignoreKeys?.includes(k as keyof T) || typeof source[k] !== typeof target[k]) target[k] = source[k]
      else if (typeof source[k] === 'string') target[k] += source[k]
      else if (Array.isArray(source[k])) target[k].push(...source[k])
      else if (typeof source[k] === 'number') parseFloat(target[k] + source[k])
      else if (source[k] && typeof source[k] === 'object') this.merge(source[k], target[k])
      else if (source[k]) target[k] = source[k]
    })
  }

  private clear() {
    this.onChangeListeners = []
    this.abortController = undefined
  }

  private fail(error: any) {
    this.error = error
    this.fullPromise.reject(this.error)
    this.clear()
  }

  private complete() {
    this.fullPromise.resolve(this.data as T)
    this.clear()
  }

  /**
   * Returns the full value of the object once the stream finishes.
   */
  getValue(): Promise<T> {
    return this.fullPromise.promise
  }

  /**
   * Returns the streamed object with everything already streamed. This will be the complete object if the stream has finished.
   */
  getPartialValue(): Partial<T> {
    return this.data
  }

  /**
   * Watches the object as it's streamed. This doesn't wait for the value to be complete.
   * 
   * The listener is called whenever the value changes.
   * 
   * @param listener the function to call with the new value.
   * @returns a function that, when called, removes the listener.
   */
  onChange(listener: (value: Partial<T>) => void) {
    if (this.fullPromise.resolved) {
      listener(this.data)
      return () => { }
    }
    this.onChangeListeners.push(listener)
    return () => {
      const index = this.onChangeListeners?.findIndex(l => l === listener)
      if (index !== undefined && index >= 0) this.onChangeListeners?.splice(index, 1)
    }
  }

  getStatus(): StreamingStatus {
    if (this.error) return 'error'
    if (this.fullPromise.resolved) return 'success'
    return 'pending'
  }

  getError() {
    return this.error
  }

  /**
   * If this is a stream and it's not yet finished, calling this function cancels the stream.
   */
  cancel() {
    this.abortController?.abort(new StreamCanceledError())
  }
}
