/**
 * FastAPI
 * 0.1.0
 * DO NOT MODIFY - This file has been generated using oazapfts.
 * See https://www.npmjs.com/package/oazapfts
 */
import * as Oazapfts from "@oazapfts/runtime";
import * as QS from "@oazapfts/runtime/query";
export const defaults: Oazapfts.Defaults<Oazapfts.CustomHeaders> = {
    headers: {},
    baseUrl: "/",
};
const oazapfts = Oazapfts.runtime(defaults);
export const servers = {};
export type LlmRoles = "system" | "user" | "assistant" | "function" | "tool";
export type SendMessage = {
    role: LlmRoles;
    content: string;
};
export type SendConversation = {
    model_name: string;
    messages: SendMessage[];
    temperature?: number | null;
    json_schema?: {
        [key: string]: any;
    } | null;
    is_azure?: boolean | null;
    max_tokens?: number | null;
};
export type MessageRepresentation = {
    /** The role of the sender of the message (e.g., 'user', 'assistant', 'system', 'tool'). */
    role: string;
    /** The content of the message. */
    content: string;
    /** The name of the sender, if applicable. */
    name?: string | null;
    /** A dictionary representing a function call, if applicable. */
    function_call?: {
        [key: string]: any;
    } | null;
};
export type ChoiceRepresentation = {
    message: MessageRepresentation;
    finish_reason: string;
    index: number;
};
export type UsageRepresentation = {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
};
export type MetricsRepresentation = {
    latency_ms: number;
};
export type ConversationRepresentation = {
    id: string;
    choices: ChoiceRepresentation[];
    created: string;
    model: string;
    "object"?: string;
    usage: UsageRepresentation;
    metrics?: MetricsRepresentation | null;
};
export type ValidationError = {
    loc: (string | number)[];
    msg: string;
    "type": string;
};
export type HttpValidationError = {
    detail?: ValidationError[];
};
export type ResourceName = "agents" | "deep_ks" | "autocomplete";
export type LlmModelResourceRequest = {
    name: ResourceName;
    is_default?: boolean;
};
export type CreateLlmModelRequest = {
    display_name: string;
    provider_name: string;
    model_name: string;
    connection_params: {
        [key: string]: any;
    };
    resources: LlmModelResourceRequest[];
};
export type LlmProviderResponse = {
    name: string;
    provider_type: string;
    configuration_params?: {
        [key: string]: any;
    } | null;
    accepts_self_hosted?: boolean | null;
};
export type LlmModelConfigurationResponse = {
    provider: LlmProviderResponse;
    model_name: string;
    connection_params: {
        [key: string]: any;
    } | null;
    usage_params: {
        [key: string]: any;
    } | null;
};
export type LlmModelResourcesResponse = {
    id: string;
    name: string;
    is_default: boolean;
};
export type LlmModelsResponse = {
    id: string;
    active: boolean;
    display_name: string;
    self_hosted: boolean;
    model_configuration: LlmModelConfigurationResponse;
    resources: LlmModelResourcesResponse[];
    created_at: string;
    updated_at: string;
    updated_by: string;
};
export type OrderBy = "default" | "display_name" | "model_name" | "type" | "status";
export type OrderDir = "asc" | "desc" | "stackspot_hosted" | "self_hosted" | "active" | "inactive";
export type PaginatedResponseLlmModelsResponse = {
    total_pages: number;
    items: LlmModelsResponse[];
};
export type ToggleModelStatusRequest = {
    active: boolean;
};
export type UpdateLlmModelRequest = {
    display_name: string;
    model_name: string;
    connection_params: {
        [key: string]: any;
    };
    resources: LlmModelResourceRequest[];
};
export type GetModelByIdsRequest = {
    model_ids: string[];
};
export type UpdateLlmModelResourceRequest = {
    name: string;
    is_default?: boolean;
};
export type LlmSimpleProviderResponse = {
    name: string;
    provider_type: string;
    configuration_params: {
        [key: string]: any;
    };
    accepts_self_hosted: boolean;
    model_names: string[];
};
export type TextParam = {
    text: string;
    "type"?: "text";
};
export type UrlParam = {
    url: string;
};
export type ImageParam = {
    image_url: UrlParam;
    "type"?: "image_url";
};
export type FunctionCall = {
    /** The name of the function to call */
    name: string;
    /** A JSON string representing the function arguments */
    arguments: string;
};
export type Message = {
    /** The role of the message (system, user, assistant, or function) */
    role: LlmRoles;
    /** The content of the message, can be a string or a list of content blocks */
    content?: string | (TextParam | ImageParam)[];
    /** The name of the sender (optional) */
    name?: string | null;
    /** Details of a function call (optional) */
    function_call?: FunctionCall | null;
    /** Details of a function call (optional) */
    tool_calls?: {
        [key: string]: any;
    }[] | null;
    /** Tool id */
    tool_call_id?: string | null;
};
export type FunctionParameter = {
    /** The type of the parameter */
    "type": string;
    /** A description of the parameter (optional) */
    description?: string | null;
    /** A list of possible values for the parameter (optional) */
    "enum"?: string[] | null;
    /** A dictionary of properties for the parameter (optional) */
    properties?: {
        [key: string]: any;
    } | null;
    /** A list of required parameters (optional) */
    required?: string[] | null;
    /** Allow arbitrary data of specific typed */
    additionalProperties?: boolean;
};
export type Function = {
    /** The name of the function */
    name: string;
    /** A description of what the function does */
    description: string;
    /** The parameters required by the function */
    parameters: FunctionParameter;
    /** Strict specific schema response. Only `strict` function tools can be auto-parsed */
    strict: boolean;
};
export type ChatCompletion = {
    /** The model to be used for the chat completion */
    model: string;
    /** A list of messages that make up the conversation */
    messages: Message[];
    /** Sampling temperature; higher values make output more random */
    temperature?: number;
    /** Nucleus sampling probability; controls diversity */
    top_p?: number;
    /** Number of completions to generate */
    n?: number;
    /** Whether to stream the response */
    stream?: boolean;
    /** Stop sequences that will halt the generation */
    stop?: string | string[] | null;
    /** Maximum number of tokens to generate */
    max_tokens?: number | null;
    /** Penalty based on new tokens' presence in the text */
    presence_penalty?: number;
    /** Penalty based on new tokens' frequency in the text */
    frequency_penalty?: number;
    /** A dictionary to adjust the likelihood of specific tokens */
    logit_bias?: {
        [key: string]: number;
    } | null;
    /** An identifier for the user */
    user?: string | null;
    /** A list of functions that can be called during the chat */
    functions?: Function[] | null;
    /** Specifies function call behavior or parameters (for example, 'auto' or {'name': 'function_name'}) */
    function_call?: string | {
        [key: string]: string;
    } | null;
    /** ID of an alternative model for chat completion. It should be present on available_model_ids agent attr. */
    selected_model_id?: string | null;
};
export type ChatRequest = {
    streaming: boolean;
    user_prompt: string;
    stackspot_knowledge?: boolean;
    return_ks_in_response?: boolean;
    upload_ids?: string[];
    execution_id?: string | null;
    selected_model?: string | null;
};
/**
 * Health Check
 */
export function healthCheckHealthzGet(opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: any;
    } | {
        status: 404;
    }>("/healthz", {
        ...opts
    }));
}
/**
 * Readiness Check
 */
export function readinessCheckReadyzGet(opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: any;
    } | {
        status: 404;
    }>("/readyz", {
        ...opts
    }));
}
/**
 * Handle conversation requests
 */
export function converseV0ConversationPost({ xAccountId, authorization, sendConversation }: {
    xAccountId?: string | null;
    authorization: string;
    sendConversation: SendConversation;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ConversationRepresentation;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>("/v0/conversation", oazapfts.json({
        ...opts,
        method: "POST",
        body: sendConversation,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    })));
}
/**
 * Add Self Hosted Model
 */
export function addSelfHostedModelV1LlmModelsPost({ xAccountId, authorization, createLlmModelRequest }: {
    xAccountId?: string | null;
    authorization: string;
    createLlmModelRequest: CreateLlmModelRequest;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: LlmModelsResponse;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>("/v1/llm/models", oazapfts.json({
        ...opts,
        method: "POST",
        body: createLlmModelRequest,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    })));
}
/**
 * List Models
 */
export function listModelsV1LlmModelsGet({ active, resource, $default, displayName, selfHosted, orderBy, orderDir, page, pageSize, xAccountId, authorization }: {
    active?: boolean | null;
    resource?: string | null;
    $default?: boolean | null;
    displayName?: string | null;
    selfHosted?: boolean | null;
    orderBy?: OrderBy;
    orderDir?: OrderDir;
    page?: number;
    pageSize?: number;
    xAccountId?: string | null;
    authorization: string;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: PaginatedResponseLlmModelsResponse;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>(`/v1/llm/models${QS.query(QS.explode({
        active,
        resource,
        "default": $default,
        display_name: displayName,
        self_hosted: selfHosted,
        order_by: orderBy,
        order_dir: orderDir,
        page,
        page_size: pageSize
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    }));
}
/**
 * Get Model
 */
export function getModelV1LlmModelsModelIdGet({ modelId, xAccountId, authorization }: {
    modelId: string;
    xAccountId?: string | null;
    authorization: string;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: LlmModelsResponse;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>(`/v1/llm/models/${encodeURIComponent(modelId)}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    }));
}
/**
 * Toggle Model Status
 */
export function toggleModelStatusV1LlmModelsModelIdPatch({ modelId, xAccountId, authorization, toggleModelStatusRequest }: {
    modelId: string;
    xAccountId?: string | null;
    authorization: string;
    toggleModelStatusRequest: ToggleModelStatusRequest;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: LlmModelsResponse;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>(`/v1/llm/models/${encodeURIComponent(modelId)}`, oazapfts.json({
        ...opts,
        method: "PATCH",
        body: toggleModelStatusRequest,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    })));
}
/**
 * Update
 */
export function updateV1LlmModelsModelIdPut({ modelId, xAccountId, authorization, updateLlmModelRequest }: {
    modelId: string;
    xAccountId?: string | null;
    authorization: string;
    updateLlmModelRequest: UpdateLlmModelRequest;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: LlmModelsResponse;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>(`/v1/llm/models/${encodeURIComponent(modelId)}`, oazapfts.json({
        ...opts,
        method: "PUT",
        body: updateLlmModelRequest,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    })));
}
/**
 * Delete
 */
export function deleteV1LlmModelsModelIdDelete({ modelId, xAccountId, authorization }: {
    modelId: string;
    xAccountId?: string | null;
    authorization: string;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 204;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>(`/v1/llm/models/${encodeURIComponent(modelId)}`, {
        ...opts,
        method: "DELETE",
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    }));
}
/**
 * Get Models List
 */
export function getModelsListV1LlmModelsListPost({ xAccountId, authorization, getModelByIdsRequest }: {
    xAccountId?: string | null;
    authorization: string;
    getModelByIdsRequest: GetModelByIdsRequest;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: LlmModelsResponse[];
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>("/v1/llm/models-list", oazapfts.json({
        ...opts,
        method: "POST",
        body: getModelByIdsRequest,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    })));
}
/**
 * Save Or Update Model Resources
 */
export function saveOrUpdateModelResourcesV1LlmModelsModelIdResourcesPut({ modelId, xAccountId, authorization, body }: {
    modelId: string;
    xAccountId?: string | null;
    authorization: string;
    body: UpdateLlmModelResourceRequest[];
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: any;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>(`/v1/llm/models/${encodeURIComponent(modelId)}/resources`, oazapfts.json({
        ...opts,
        method: "PUT",
        body,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    })));
}
/**
 * Delete Model Resources
 */
export function deleteModelResourcesV1LlmResourcesResourceIdDelete({ resourceId, xAccountId, authorization }: {
    resourceId: string;
    xAccountId?: string | null;
    authorization: string;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 204;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>(`/v1/llm/resources/${encodeURIComponent(resourceId)}`, {
        ...opts,
        method: "DELETE",
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    }));
}
/**
 * List Llm Providers
 */
export function listLlmProvidersV1LlmProvidersGet({ acceptsSelfHosted, xAccountId, authorization }: {
    acceptsSelfHosted?: boolean;
    xAccountId?: string | null;
    authorization: string;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: LlmSimpleProviderResponse[];
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>(`/v1/llm/providers${QS.query(QS.explode({
        accepts_self_hosted: acceptsSelfHosted
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    }));
}
/**
 * Handle completions requests
 */
export function createCompletionsV1ChatCompletionsPost({ xAccountId, authorization, xRequestOrigin, xConversationId, xMessageId, xQcExecutionId, xQcSlug, xPlatformVersion, chatCompletion }: {
    xAccountId?: string | null;
    authorization: string;
    xRequestOrigin?: string | null;
    xConversationId?: string | null;
    xMessageId?: string | null;
    xQcExecutionId?: string | null;
    xQcSlug?: string | null;
    xPlatformVersion?: string | null;
    chatCompletion: ChatCompletion;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: any;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>("/v1/chat/completions", oazapfts.json({
        ...opts,
        method: "POST",
        body: chatCompletion,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization,
            "x-request-origin": xRequestOrigin,
            "x-conversation-id": xConversationId,
            "x-message-id": xMessageId,
            "x-qc-execution-id": xQcExecutionId,
            "x-qc-slug": xQcSlug,
            "x-platform-version": xPlatformVersion
        })
    })));
}
/**
 * Agent Chat
 */
export function agentChatV1AgentAgentIdChatPost({ agentId, xAccountId, authorization, chatRequest }: {
    agentId: string;
    xAccountId?: string | null;
    authorization: string;
    chatRequest: ChatRequest;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: any;
    } | {
        status: 404;
    } | {
        status: 422;
        data: HttpValidationError;
    }>(`/v1/agent/${encodeURIComponent(agentId)}/chat`, oazapfts.json({
        ...opts,
        method: "POST",
        body: chatRequest,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            "x-account-id": xAccountId,
            authorization
        })
    })));
}
