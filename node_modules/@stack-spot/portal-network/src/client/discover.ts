import { HttpError } from '@oazapfts/runtime'
import { findLast, last } from 'lodash'
import { getApiAddresses } from '../api-addresses'
import { ConversationResponse } from '../api/ai'
import { create, create1, create2, defaults, deleteById, deleteById1, deleteById2, fetchInsights, getAll, getAll1, getAll2, getAllByHypothesis, getById, getById1, getById2, getInsightById, GetOpportunityResponse, MessageRequest, refreshInsights } from '../api/discover'
import { DefaultAPIError } from '../error/DefaultAPIError'
import { StackspotAPIError } from '../error/StackspotAPIError'
import { StreamedJson } from '../utils/StreamedJson'
import { baseDictionary } from '../error/dictionary/base'
import { formatJson } from '../utils/string'
import { ReactQueryNetworkClient } from '../network/ReactQueryNetworkClient'
import { aiClient } from './ai'
import { ChatAgentTool, ChatResponseWithSteps, FixedChatResponse, StepChatStep } from './types'
import { agentToolsClient } from './agent-tools'

export interface ChatConversionDetails extends ConversationResponse {
  opportunityName?: string,
  hypothesisCount?: number,
}

class DiscoverClient extends ReactQueryNetworkClient {
  constructor() {
    super(getApiAddresses().discover.url, defaults)
  }

  protected buildStackSpotError(error: HttpError): StackspotAPIError {
    return new DefaultAPIError(error.data, error.status, baseDictionary, error.headers)
  }

  opportunities = this.query(getAll)

  opportunity = this.query(getById)

  hypotheses = this.query(getAll1)

  hypothesisById = this.query(getById1)

  documents = this.query(getAllByHypothesis)

  document = this.query(getById2)

  artifacts = this.query(getAll2)

  createOpportunity = this.mutation(create)

  createHypothesis = this.mutation(create1)

  createDocument = this.mutation(create2)

  deleteOpportunity = this.mutation(deleteById)

  deleteHypothesis = this.mutation(deleteById1)

  deleteDocument = this.mutation(deleteById2)

  /**
   * Fetch insights
   */
  insights = this.query(fetchInsights)
  /**
   * Refresh insights
   */
  refreshInsights = this.mutation(refreshInsights)
  /**
   * Get Insight by Id
   */
  insightById = this.query(getInsightById)

  chats = this.query({
    name: 'chats',
    request: async (_signal, variables: { filter?: string, page?: number, size?: number }) => {
      const opportunities = await this.opportunities.query({})

      const opportunitiesByChatId: Record<string, any> = opportunities.content.reduce(
        (acc, opp: GetOpportunityResponse) => {
          if (opp.chatId) {
            acc[opp.chatId] = opp
          }
          return acc
        },
        {} as Record<string, any>,
      )

      const chatsHistory = await aiClient.chats.query(
        { ...variables, page: variables.page, size: variables.size ?? 40 },
      )

      const filteredItems = variables.filter
        ? chatsHistory.filter((chat) => chat.title.toLowerCase().includes(variables.filter!.toLowerCase()))
        : chatsHistory

      const enrichedChats = filteredItems?.map(chat => {
        const relatedOpportunity = opportunitiesByChatId[chat.id]

        return {
          ...chat,
          opportunityName: relatedOpportunity?.title ?? null,
          hypothesisCount: relatedOpportunity?.hypotheses?.length ?? 0,
        }
      })

      return enrichedChats as ChatConversionDetails[]
    },
  })

  private static async toolsOfAgent(agentId?: string) {
    try {
      const agent = agentId ? await agentToolsClient.agent.query({ agentId }) : undefined
      if (!agent) return []
      const tools: (Omit<ChatAgentTool, 'duration' | 'prompt' | 'output'>)[] = []
      agent.toolkits?.builtin_toolkits?.forEach(kit => kit.tools?.forEach(({ id, name, description }) => {
        if (id) tools.push({ image: kit.image_url, id, name: name || id, description })
      }))
      agent.toolkits?.custom_toolkits?.forEach(kit => kit.tools?.forEach(({ id, name, description }) => {
        if (id) tools.push({ image: kit.avatar ?? undefined, id, name: name || id, description })
      }))
      return tools
    } catch {
      return []
    }
  }


  sendChatMessage(request: MessageRequest & { agentId: string }, minChangeIntervalMS?: number): StreamedJson<ChatResponseWithSteps> {
    const abortController = new AbortController()
    const headers = {
      'Content-Type': 'application/json',
      'Accept': 'text/event-stream',
    }
    const events = this.stream(
      this.resolveURL('/v2/ai/chat'),
      { method: 'post', body: JSON.stringify(request), headers, signal: abortController.signal },
    )
    /**
       * This function treats events in the streaming that deals with the execution of tools. Since these events are not concatenated like
       * normal streamings of data, we need this separate function to deal with them. It transforms the internal data model of the
       * StreamedJson object whenever an event is triggered.
       */
    async function transform(event: Partial<FixedChatResponse>, data: Partial<ChatResponseWithSteps>) {
      const info = event.agent_info

      if (!info) return

      const tools = await DiscoverClient.toolsOfAgent(request.agentId)
      data.steps = data.steps ? [...data.steps] : []

      if (info.type === 'planning' && info.action === 'end') {
        data.steps.push({
          id: 'planning',
          type: 'planning',
          status: 'success',
          duration: info.duration || 0,
          steps: info.data?.steps?.map(s => s.goal) ?? [],
          goal: info.data?.plan_goal ?? '',
        })

        info.data?.steps.forEach(s => data.steps?.push({
          id: s.id,
          type: 'step',
          status: 'pending',
          input: s.goal,
          attempts: [{
            tools: s.tools?.map(t => ({
              ...(tools.find(({ id }) => id === t.tool_id) ?? { id: t.tool_id, name: t.tool_id }),
              executionId: t.tool_execution_id,
              goal: t.goal,
            })),
          }],
        }))
        data.steps.push({ id: 'answer', type: 'answer', status: 'pending' })
      }

      if (info.type === 'planning' && info.action === 'awaiting_approval') {
        data.steps.push({
          id: 'planning',
          type: 'planning',
          status: 'awaiting_approval',
          user_question: info.data?.user_question,
          duration: info.duration || 0,
          steps: info.data?.steps?.map(s => s.goal) ?? [],
          goal: info.data?.plan_goal ?? '',
        })
        info.data?.steps.forEach(s => data.steps?.push({
          id: s.id,
          type: 'step',
          status: 'pending',
          input: s.goal,
          attempts: [{
            tools: s.tools?.map(t => ({
              ...(tools.find(({ id }) => id === t.tool_id) ?? { id: t.tool_id, name: t.tool_id }),
              executionId: t.tool_execution_id,
              goal: t.goal,
            })),
          }],
        }))
        data.steps.push({ id: 'answer', type: 'answer', status: 'pending' })
      }

      if (info.type === 'step' && info.action === 'start') {
        const step = data.steps.find(s => s.id === info.id)
        if (step) step.status = 'running'
      }

      if (info.type === 'step' && info.action === 'end') {
        const step = data.steps.find(s => s.id === info.id) as StepChatStep
        if (step) {
          step.status = 'success'
          step.duration = info.duration
          const lastToolId = last(step.attempts[0].tools)?.id
          const lastAttemptOfLastTool = findLast(step.attempts.map(a => a.tools).flat(), t => t?.id === lastToolId)
          step.output = lastAttemptOfLastTool?.output
        }
      }

      if (info.type === 'tool' && info.action === 'awaiting_approval') {
        const tool = tools.find(({ id }) => id === info.data?.tool_id)
        data.steps.push({
          id: info.id,
          type: 'tool',
          status: 'awaiting_approval',
          duration: info.duration || 0,
          input: info.data?.input,
          user_question: info.data?.user_question,
          attempts: [{
            tools: [{
              executionId: info.id,
              id: info.data?.tool_id ?? '',
              name: tool?.name ?? '',
              goal: tool?.goal,
              ...tool,
            }],
          }],
        })
        data.steps.push({ id: 'answer', type: 'answer', status: 'pending' })
      }

      if (info.type === 'tool' && info.action === 'start') {
        const currentStep = data.steps.find(s => s.status === 'running') as StepChatStep
        if (!info.data) return

        //There might be a tool with status awaiting_approval, so we want to inform tool has already started
        if (!currentStep || !currentStep.attempts[0].tools) {
          const input = formatJson(info.data.input)
          const tool = tools.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id }
          data.steps.push({
            id: info.id,
            type: 'tool',
            status: 'running',
            duration: info.duration || 0,
            input: info.data?.input,
            user_question: info.data?.user_question,
            attempts: [{
              tools: [{ ...tool, executionId: info.id, input }],
            }],
          })
        } else {
          const toolInFirstAttempt = currentStep.attempts[0].tools?.find(t => t.executionId === info.id)
          //One step might have multiple tools. When in an approval mode, we might not have all the tools in the array yet.
          //So we make sure to add any tools that are not in there.
          if (!toolInFirstAttempt) {
            const input = formatJson(info.data.input)
            const tool = tools?.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id }
            currentStep.attempts[info.data.attempt - 1].tools?.push({
              ...tool,
              executionId: info.id,
              input,
            })
          } else {
            const input = formatJson(info.data.input)
            if (info.data.attempt === 1) {
              toolInFirstAttempt.input = input
            } else {
              const tool = tools.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id }
              currentStep.attempts[info.data.attempt - 1] ??= { tools: [] }
              currentStep.attempts[info.data.attempt - 1].tools?.push({
                ...tool,
                executionId: info.id,
                input,
              })
            }
          }
        }
      }

      if (info.type === 'tool' && info.action === 'end') {
        const currentStep = data.steps.find(s => s.status === 'running') as StepChatStep
        if (!currentStep || !info.data) return
        const tool = currentStep.attempts[info.data.attempt - 1]?.tools?.find(t => t.executionId === info.id)
        if (tool) {
          tool.output = formatJson(info.data.output)
          tool.duration = info.duration
        }
      }

      if (info.type === 'final_answer' && info.action === 'start') {
        const answerStep = last(data.steps)
        if (answerStep) answerStep.status = 'running'
      }

      if (info.type === 'chat' && info.action === 'end') {
        const answerStep = last(data.steps)
        if (answerStep) {
          answerStep.status = 'success'
          answerStep.duration = info.duration
        }
      }
    }

    return new StreamedJson({
      eventsPromise: events,
      abortController,
      minChangeIntervalMS,
      ignoreKeys: ['agent_info'],
      transform,
    })
  }
}

export const discoverClient = new DiscoverClient()
