import { HttpError, RequestOpts } from '@oazapfts/runtime'
import { getApiAddresses } from '../api-addresses'
import {
  addAccountMemberFavorite,
  addNewEmailDomain,
  addResourcesToGroup,
  addRoleToMember,
  associateGroupToServiceCredential,
  bindGroupMembers,
  bindRoleGroups,
  bindRoles,
  bindToGroups,
  bindToRoles,
  cancelSecretDelete,
  create,
  create1,
  createAccountRole, createExtension, createExtensionLink,
  createExtensionVersion, createFidoMagicLink, createGroupMapping,
  createPartner,
  createPersonalAccessToken,
  createSecret,
  createServiceCredential,
  createServiceCredential1,
  createTrialAccount,
  createUser,
  deactivateFidoCredentials,
  defaults,
  delete1,
  deleteAccountRole,
  deleteExtension,
  deleteExtensionLink,
  deleteExtensionVersion,
  deleteFidoKey,
  deleteGroupMapping,
  deleteMember,
  deleteMemberFavorite,
  deletePartner, deleteProfileImage,
  deleteResourceFromGroup, deleteRole, deleteSecret, deleteSso,
  disablePersonalAccessTokenGeneration,
  disableSecret,
  disassociateGroupToServiceCredential, enableFidoCredentials,
  enableSecret,
  enterpriseContact,
  findAssociations,
  findSecrets,
  getAccess,
  getAccount1,
  getAccountMembers,
  getAccountMembers1,
  getAccountRateLimit,
  getAccounts,
  getAccountSso,
  getActiveExtensionVersion,
  getAllAccountSso,
  getAllGroupMapping,
  getAllMemberFidoCredentials,
  getAllServiceCredentialRateLimit,
  getById,
  getEnabledFeatureFlagsForAccount,
  getExtensionVersion,
  getExternalLinksByType,
  getFeatureFlag,
  getFeatures,
  getFeatures3,
  getGroupById,
  getGroupResources,
  getGroupResources1,
  getGroups,
  getGroups1,
  getMemberById,
  getMemberGroups,
  getMemberGroups1,
  getMemberPreferences,
  getMembers,
  getMembers1,
  getPartnerAccount, getPartnersSharingAllowed,
  getPersonalAccountDetails,
  getPersonalAccountExpirationData,
  getPersonalClientCredentials,
  getResources,
  getResources2,
  getResourcesAndActionsWithStatus,
  getResourceTypes1,
  getRoleGroups,
  getRoleGroups1,
  getRoleMembers,
  getRoleMembers1,
  getRoles,
  getRoles1,
  getRoles2,
  getRoles3,
  getRoles4,
  getRoles5,
  getScmProvider,
  getServiceCredential,
  getServiceCredentialByIdRateLimit,
  getServiceCredentialGroups,
  getServiceCredentialPermissions,
  getServiceCredentials,
  getServiceCredentials1,
  isCreatedScmCredentials,
  isCreatedScmCredentials1,
  listAccountMemberFavorites,
  listExtensionLinks,
  listExtensions,
  listExtensionVersions,
  listMemberFavoritesByResource,
  listScmCredentials1,
  listScmCredentials2, partialUpdateSso, personalAccessTokenAuthorization,
  personalContact,
  reactivateTrialAccount,
  removeRoleFromMember,
  removeTrialAccount,
  resetOtp,
  resetPassword,
  revokeServiceCredential,
  revokeServiceCredential1,
  rotateServiceCredentialSecret,
  save,
  scmCredentialSave, scmCredentialSave1, scmCredentialUpdate, scmCredentialUpdate1, scmDelete, sendDownloadEmail, ssoAddAttributes,
  ssoConfigure, ssoGetAttributesConfig, ssoParseConfigurationFile, update1,
  updateAccountRole,
  updateExtension,
  updateExtensionLink,
  updateFeatureFlag,
  updateGroupMapping,
  updateMemberPreferences,
  updatePartnerAccountAdminData,
  updatePartnerAccountData,
  updatePersonalAccountDetails,
  updateRateLimit,
  updateResourceActions,
  updateRoleWithNewActions,
  updateSalesRepresentatives,
  updateSecret,
  updateServiceCredentialRateLimit,
  updateServiceCredentialScopes,
  updateSso,
  updateUser,
  validateCampaignCode,
  validateNewPartnerData,
  validatePartnerAssociationLimit,
} from '../api/account'
import { DefaultAPIError } from '../error/DefaultAPIError'
import { accountDictionary } from '../error/dictionary/account'
import { StackspotAPIError } from '../error/StackspotAPIError'
import { ReactQueryNetworkClient } from '../network/ReactQueryNetworkClient'
import { CreateSCMRequest, SCMStatus, UpdateSCMRequest } from './types'

class AccountClient extends ReactQueryNetworkClient {
  constructor() {
    super(getApiAddresses().account.url, defaults)
  }

  protected buildStackSpotError(error: HttpError): StackspotAPIError {
    return new DefaultAPIError(error.data, error.status, accountDictionary, error.headers)
  }

  /**
   * Gets credentials from personal service client (create if not exists one to the logged user).
   */
  generatePersonalClientCredentials = this.mutation(getPersonalClientCredentials)
  /**
   * Creates a Feature Flag
   */
  createFeatureFlag = this.mutation(create)
  /**
   * Lists all Feature Flags in an Account
   */
  featureFlags = this.query(getFeatures3)
  /**
   * Lists all Feature Flags in an Account With Pagination
   */
  featureFlagsWithPagination = this.query(getFeatures)
  /**
   * Gets Partners with whom it is allowed to share content.
   */
  partners = this.query(getPartnersSharingAllowed)
  /**
   * Gets Partner by account Id
   */
  partner = this.query(getPartnerAccount)
  /**
   * Creates an Account Order for Partner
   */
  createPartner = this.mutation(createPartner)
  /**
   * Updates Partner Account data.
   */
  updatePartner = this.mutation(updatePartnerAccountData)
  /**
   * Updates Partner Account Admin data.
   */
  updatePartnerAdmin = this.mutation(updatePartnerAccountAdminData)
  /**
   * Deletes Partner
   */
  deactivatePartner = this.mutation(deletePartner)
  /**
   * Validates new Partner account data
   */
  validateNewPartnerData = this.mutation(validateNewPartnerData)
  /**
   * Validates the association limit for the partner. Yields `{ isValid: true }` if valid or `{ isValid: false, message: string }`
   * otherwise.
   */
  validatePartnerAssociationLimit = this.query({
    name: 'validatePartnerAssociationLimit',
    request: async (signal) => {
      try {
        await validatePartnerAssociationLimit({ signal })
        return { isValid: true, message: '' }
      } catch (error) {
        if (error instanceof HttpError) {
          const stkError = this.buildStackSpotError(error)
          if (stkError.status === 422 || stkError.code === 'BAD_USER_INPUT') return { isValid: false, message: stkError.translate() }
        }
        throw error
      }
    },
  })
  /**
   * Gets member by id.
   */
  member = this.query(getMemberById)
  /**
   * Gets all members (paginated).
   */
  allMembers = this.infiniteQuery(getAccountMembers)
  /**
   * Gets member Groups (paginated).
   */
  memberGroups = this.infiniteQuery(getMemberGroups)
  /**
   * Gets member roles (paginated).
   */
  memberRoles = this.infiniteQuery(getRoles1)
  /**
   * Gets member resources.
   */
  memberResources = this.query(getResources2)
  /**
   * Gets All Fido credentials for the given member (paginated).
   */
  fidoCredentials = this.infiniteQuery(getAllMemberFidoCredentials, { accumulator: 'items' })
  /**
   * Creates member on current tenant.
   */
  createMember = this.mutation(createUser)
  /**
   * Updates member on current tenant.
   */
  updateMember = this.mutation(updateUser)
  /**
   * Adds a member to several groups.
   */
  addMemberToGroups = this.mutation(bindToGroups)
  /**
   * Attributes several roles to a member.
   */
  addRolesToMember = this.mutation(bindToRoles)
  /**
   * Removes a role from a member.
   */
  removeRoleFromMember = this.mutation(removeRoleFromMember)
  /**
   * Sends an e-mail to reset the password of the member with the provided e-mail address.
   */
  resetMemberPassword = this.mutation(resetPassword)
  /**
   * Reset member OTP
   */
  resetOtp = this.mutation(resetOtp)
  /**
   * Enables Fido credentials for the given member.
   */
  enableFidoCredentials = this.mutation(enableFidoCredentials)
  /**
   * Disables Fido credentials for the given member.
   */
  disableFidoCredentials = this.mutation(deactivateFidoCredentials)
  /**
   * Gets group by id.
   */
  group = this.query(getGroupById)
  /**
   * Get all groups (paginated).
   */
  allGroups = this.infiniteQuery(getGroups)
  /**
   * Creates a group.
   */
  createGroup = this.mutation(save)
  /**
   * Updates a group.
   */
  updateGroup = this.mutation(update1)
  /**
   * Deletes a group.
   */
  deleteGroup = this.mutation(delete1)
  /**
   * Gets all members in a group (paginated).
   */
  groupMembers = this.infiniteQuery(getMembers)
  /**
   * Adds several members to a group
   */
  addMembersToGroup = this.mutation(bindGroupMembers)
  /**
   * Removes a member from a group
   */
  removeMemberFromGroup = this.mutation(deleteMember)
  /**
   * Gets all roles of a group.
   */
  groupRoles = this.infiniteQuery(getRoles2)
  /**
   * Adds several roles to a group.
   */
  addRolesToGroup = this.mutation(bindRoles)
  /**
   * Removes a role from a group.
   */
  removeRoleFromGroup = this.mutation(deleteRole)
  /**
   * Gets all resources of a group (paginated).
   */
  groupResources = this.infiniteQuery(getGroupResources)
  /**
   * Adds several resources to a group.
   */
  addResourcesToGroup = this.mutation(addResourcesToGroup)
  /**
   * Removes a resource from a group.
   */
  removeResourceFromGroup = this.mutation(deleteResourceFromGroup)
  /**
   * Gets all roles in the account (paginated)
   */
  allRoles = this.infiniteQuery(getRoles)
  /**
   * Get a role by id
   */
  role = this.query({
    name: 'account.role',
    request: async (signal, { id }: { id: string }) => {
      const roles = await getRoles({ filterBy: 'id', filterValue: id }, { signal })
      if (!roles.length) throw new StackspotAPIError({ status: 404 })
      return roles[0]
    },
  })
  /**
   * Gets all members with the provided role (paginated)
   */
  roleMembers = this.infiniteQuery(getRoleMembers)
  /**
   * Creates a role
   */
  createRole = this.mutation(createAccountRole)
  /**
   * Updates a role
   */
  updateRole = this.mutation(updateAccountRole)
  /**
   * Deletes a role
   */
  deleteRole = this.mutation(deleteAccountRole)
  /**
   * Adds a role to several members 
   */
  addRoleToMembers = this.mutation(addRoleToMember)
  /**
   * Gets all groups with the provided role (paginated)
   */
  roleGroups = this.infiniteQuery(getRoleGroups)
  /**
   * Adds a role to several groups
   */
  addRoleToGroups = this.mutation(bindRoleGroups)
  /**
   * Get the actions a role is allowed to perform
   */
  rolePermissions = this.infiniteQuery(getResourcesAndActionsWithStatus)
  /**
   * Updates a role with new list of permissions
   */
  updateRolePermissions = this.mutation(updateRoleWithNewActions)
  /**
   * Updates a specific role permission
   */
  updateRolePermission = this.mutation(updateResourceActions)
  /**
   * Gets all resources (paginated)
   */
  allResources = this.infiniteQuery(getResources)
  /**
   * Gets all resource types (paginated)
   */
  allResourceTypes = this.infiniteQuery(getResourceTypes1)
  /**
   * Sends an email for downloading the CLI
   */
  sendDownloadCLIEmail = this.mutation(sendDownloadEmail)
  /**
   * Creates an SCM credential (account level).
   */
  createSCMCredential = this.mutation(scmCredentialSave1 as (variables: CreateSCMRequest, opts?: RequestOpts) => Promise<unknown>)
  /**
   * Updates an SCM credential (account level).
   */
  updateSCMCredential = this.mutation(scmCredentialUpdate1 as (variables: UpdateSCMRequest, opts?: RequestOpts) => Promise<unknown>)
  /**
   * Gets all SCM credentials (account level).
   */
  allSCMCredentials = this.query(listScmCredentials1)
  /**
   * Gets the status for the SCM credential.
   * 
   * - If the SCM status is invalid because there's no configuration at the account level, it returns `{ status: 'missing-account' }`.
   * - If the SCM status is invalid because, although the SCM integration is configured, the SCM access is not, it returns
   * `{ status: 'missing-user' }`.
   * - If the SCM status is valid, it returns `{ status: 'valid', mandate: boolean, hasUserConfiguration: boolean }`. `mandate` indicates
   * if the SCM credential is mandatory at the account level for every user. `hasUserConfiguration` indicates if the user currently logged
   * in has an SCM credential configured or not.
   */
  scmCredentialStatus = this.query({
    name: 'account.scmStatus',
    request: async (signal): Promise<SCMStatus> => {
      try {
        const data = await isCreatedScmCredentials1({ signal })
        return { status: 'valid', ...data }
      } catch (error) {
        if (error instanceof HttpError) {
          // 404 means that the scm integration was not configured
          if (error.status === 404) return { status: 'missing-account' }
          // 422 means that the scm integration is configured, but the scm access is not
          if (error.status === 422) return { status: 'missing-user' }
        }
        throw error
      }
    },
  })
  /**
   * Enables Personal Access Token (PAT) generation.
   */
  enablePATGeneration = this.mutation(createPersonalAccessToken)
  /**
   * Disables Personal Access Token (PAT) generation.
   */
  disablePATGeneration = this.mutation(disablePersonalAccessTokenGeneration)
  /**
   * Verifies if Personal Access Token (PAT) generation is enabled.
   */
  patGenerationEnabled = this.query({
    name: 'account.patEnabled',
    request: async (signal) => {
      try {
        await personalAccessTokenAuthorization({ signal })
        return true
      } catch (error) {
        if (error instanceof HttpError && error.status === 404) return false
        throw error
      }
    },
  })
  /**
   * Verifies if the current user has an SCM credential configured.
   */
  userHasSCMCredential = this.query({
    name: 'account.userHasSCMCredential',
    request: async (signal) => {
      try {
        await isCreatedScmCredentials({ signal })
        return true
      } catch {
        return false
      }
    },
  })
  /**
   * Creates an SCM credential for the user currently logged in.
   */
  createUserSCMCredential = this.mutation(scmCredentialSave)
  /**
   * Updates an SCM credential for the user currently logged in.
   */
  updateUserSCMCredential = this.mutation(scmCredentialUpdate)
  /**
   * Gets all SCM credentials for the user currently logged in.
   */
  allUserSCMCredentials = this.query(listScmCredentials2)
  /**
   * Gets the SCM provider.
   */
  scmProvider = this.query(getScmProvider)
  /**
   * Deletes the SCM credentials for the user currently logged in.
   */
  deleteSCMCredentials = this.mutation(scmDelete)
  /**
   * Gets all service credentials (paginated).
   */
  allServiceCredentials = this.infiniteQuery(getServiceCredentials1)
  /**
   * Gets a service credential by id.
   */
  serviceCredential = this.query(getServiceCredential)
  /**
   * Gets all the permissions linked to a service credential.
   */
  serviceCredentialPermissions = this.query(getServiceCredentialPermissions)
  /**
   * Gets all groups linked to a service credential.
   */
  serviceCredentialGroups = this.query(getServiceCredentialGroups)
  /**
   * Creates a service credential.
   */
  createServiceCredential = this.mutation(createServiceCredential1)
  /**
   * Adds a service credential to several groups.
   */
  addServiceCredentialToGroups = this.mutation(associateGroupToServiceCredential)
  /**
   * Removes a service credential from a group.
   */
  removeServiceCredentialFromGroup = this.mutation(disassociateGroupToServiceCredential)
  /**
   * Revokes a service credential.
   */
  revokeServiceCredential = this.mutation(revokeServiceCredential1)
  /**
   * Creates a group mapping within an SSO.
   */
  createSSOGroupMapping = this.mutation(createGroupMapping)
  /**
   * Deletes a group mapping from an SSO.
   */
  deleteSSOGroupMapping = this.mutation(deleteGroupMapping)
  /**
   * Updates a group mapping within an SSO.
   */
  updateSSOGroupMapping = this.mutation(updateGroupMapping)
  /**
   * Get All SSO Group Mappings (paginated).
   */
  allSSOGroupMappings = this.infiniteQuery(getAllGroupMapping, { accumulator: 'items' })
  /**
   * Parses a file with a configuration for an SSO. The protocol can be either SAML or OPENID.
   */
  parseSSOConfig = this.mutation(ssoParseConfigurationFile)
  /**
   * Creates an SSO. The protocol can be either SAML or OPENID.
   */
  setupSSO = this.mutation(ssoConfigure)
  /**
   * Gets all SSOs.
   */
  allSSO = this.query(getAllAccountSso)
  /**
   * Updates an SSO. The payload will replace everything in the current configuration (won't be merged). Use `patchSSO` for merging.
   */
  updateSSO = this.mutation(updateSso)
  /**
   * Patches an SSO with a partial configuration change.
   */
  patchSSO = this.mutation(partialUpdateSso)
  /**
   * Gets an SSO by id.
   */
  sso = this.query(getAccountSso)
  /**
   * Deletes an SSO.
   */
  deleteSSO = this.mutation(deleteSso)
  /**
   * Gets the attributes of an SSO.
   */
  ssoAttributes = this.query(ssoGetAttributesConfig)
  /**
   * Updates the attributes in a SSO.
   */
  updateSSOAttributes = this.mutation(ssoAddAttributes)

  /**
   * Gets the preferences of a member.
   */
  preferences = this.query(getMemberPreferences)

  /**
   * Updates the preferences of a member.
   */
  updatePreferences = this.mutation(updateMemberPreferences)

  /**
   * Get account member favorite resources
 */
  getAccountMemberFavoriteResources = this.query(listAccountMemberFavorites)
  /**
   * Add account member favorite resource
 */
  addAccountMemberFavoriteResource = this.mutation(addAccountMemberFavorite)
  /**
   * Get member favorite resources by type
 */
  getMemberFavoriteResourcesByType = this.query(listMemberFavoritesByResource)
  /**
   * Remove resource from member favorites
 */
  removeResourceFromMemberFavorites = this.mutation(deleteMemberFavorite)
  /**
   * Validate permission access
   */
  validatePermissionAccess = this.query({
    name: 'account.getAccess',
    request: async (signal, variables: Parameters<typeof getAccess>[0]) => {
      try {
        await getAccess(variables, { signal })
        return true
      } catch {
        return false
      }
    },
    permission: this.createPermissionFunctionFor(getAccess),
  })
  /**
   * Get all account members with pagination
   */
  allMembersWithPagination = this.query(getAccountMembers1)
  /**
   * Get Members Groups By Profile
   */
  allMembersGroupsByProfileWithPagination = this.query(getMemberGroups1)
  /**
   * Get Members Roles By Profile
   */
  allMembersRolesByProfileWithPagination = this.query(getRoles4)
  /**
   * Get all account groups with pagination
   */
  allGroupsWithPagination = this.query(getGroups1)
  /**
   * Get all members by group with pagination
   */
  allMembersByGroupWithPagination = this.query(getMembers1)
  /**
   * Get all roles by groups with pagination
   */
  allRolesByGroupWithPagination = this.query(getRoles5)
  /**
   * Get all resources by groups with pagination
   */
  allResourcesByGroupWithPagination = this.query(getGroupResources1)
  /**
   * Get all roles account with pagination
   */
  allRolesWithPagination = this.query(getRoles3)
  /**
   * Get all members by role with pagination
   */
  allMembersByRoleWithPagination = this.query(getRoleMembers1)
  /**
   * Get all groups by roles with pagination
   */
  allGroupsByRoleWithPagination = this.query(getRoleGroups1)
  /**
   * Get Service Credentials
   */
  allServiceCredentialsWithPagination = this.query(getServiceCredentials)

  /**
   * Creates an extension.
   */
  createExtension = this.mutation(createExtension)

  /**
   * Deletes an extension.
   */
  deleteExtension = this.mutation(deleteExtension)

  /**
   * Updates an extension with a patch operation.
   */
  patchExtension = this.mutation(updateExtension)

  /**
   * Lists all extensions.
   */
  extensions = this.query(listExtensions)

  /**
   * Lists all versions of an extension.
   */
  extensionVersions = this.query(listExtensionVersions)

  /**
   * Gets a specific version of an extension.
   */
  getExtensionVersion = this.query(getExtensionVersion)

  /**
   * Gets the active version of an extension.
   */
  getActiveExtensionVersion = this.query(getActiveExtensionVersion)

  /**
   * Creates a new version of an extension.
   */
  createExtensionVersion = this.mutation(createExtensionVersion)

  /**
   * Deletes a specific version of an extension.
   */
  deleteExtensionVersion = this.mutation(deleteExtensionVersion)

  /**
   * Lists all extension links.
   */
  extensionLinks = this.query(listExtensionLinks)

  /**
   * Updates an extension link with a patch operation.
   */
  patchExtensionLink = this.mutation(updateExtensionLink)

  /**
   * Creates a new extension link.
   */
  createExtensionLink = this.mutation(createExtensionLink)

  /**
   * Deletes an extension link.
   */
  deleteExtensionLink = this.mutation(deleteExtensionLink)

  /*
   * Delete profile image
   */
  deleteProfileImage = this.mutation(deleteProfileImage)

  /**
   * Get secrets
   */
  getSecrets = this.query(findSecrets)
  /**
 * Get workspace and spot secrets
 */
  getWorkspaceAndSpotSecrets = this.query({
    name: 'account.getWorkspaceAndSpotSecrets',
    request: async (signal) => {
      const workspaceSecrets = await findSecrets({ filterByScope: 'SCOPED', filterByScopedBy: 'WORKSPACE', size: 1500 }, { signal })
      const spotSecrets = await findSecrets({ filterByScope: 'SCOPED', filterByScopedBy: 'SPOT', size: 1500 }, { signal })
      return { workspaces: workspaceSecrets?.items, spots: spotSecrets?.items }
    },
  })
  /**
   * Get secret by id
   */
  getSecret = this.query(getById)
  /**
   * Get secrets by ids
   */
  getSecretsByIds = this.query({
    name: 'getSecretsByIds',
    request: (signal, variables: { ids: string[] }) => {
      const requests = variables?.ids?.map((secretId) => getById({ secretId }, { signal }))
      return Promise.all(requests)
    },
  })

  /**
   * Create secret
   */
  createSecret = this.mutation(createSecret)
  /**
   * Delete secret
   */
  deleteSecret = this.mutation(deleteSecret)
  /**
   * Update secret
   */
  updateSecret = this.mutation(updateSecret)
  /**
   * Enable secret
   */
  enableSecret = this.mutation(enableSecret)
  /**
   * Disable secret
   */
  disableSecret = this.mutation(disableSecret)
  /**
   * Cancel Secret delete
   */
  cancelSecretDelete = this.mutation(cancelSecretDelete)

  // TRIAL
  /**
   * Create trial account
   */
  createTrialAccount = this.mutation(createTrialAccount)
  /**
   * Deletes trial account
   */
  deleteTrialAccount = this.mutation(removeTrialAccount)
  /**
   * Update trial account info
   */
  updateTrialAccount = this.mutation(updatePersonalAccountDetails)
  /**
   * Creates a personal contact lead
   */
  personalContact = this.mutation(personalContact)
  /**
   * Creates an enterprise contact lead
   */
  enterpriseContact = this.mutation(enterpriseContact)
  /**
   * Get trial expiration info
   */
  trialAccountDetails = this.query(getPersonalAccountDetails)
  /**
   * Get account rate limit
   */
  getAccountRateLimit = this.query(getAccountRateLimit)
  /**
   * Update Account rate limit
   */
  updateRateLimit = this.mutation(updateRateLimit)
  /**
   * Get all service credential rate limit
   */
  getAllServiceCredentialRateLimit = this.query(getAllServiceCredentialRateLimit)
  /**
   * Update service credential rate limit
   */
  updateServiceCredentialRateLimit = this.mutation(updateServiceCredentialRateLimit)
  /**
   * Get service credential rate limit by id
   */
  getServiceCredentialByIdRateLimit = this.query(getServiceCredentialByIdRateLimit)
  /**
   * Create a new service credential V2
   */
  createServiceCredentialV2 = this.mutation(createServiceCredential)

  /**
    * Rotate the secret of a service credential
    */
  rotateServiceCredentialSecret = this.mutation(rotateServiceCredentialSecret)

  /**
    * Update the scopes of a service credential
    */
  updateServiceCredentialScopes = this.mutation(updateServiceCredentialScopes)

  /**
    * Revoke a service credential V2
    */
  revokeServiceCredentialV2 = this.mutation(revokeServiceCredential)

  /**
   * Validates a campaign code.
   */
  validateCampaignCode = this.query(validateCampaignCode)

  /**
   * Get feature flag by id
   */
  featureFlagById = this.query(getFeatureFlag)
  /**
   * Update feature flag by id
   */
  updateFeatureFlagById = this.mutation(updateFeatureFlag)
  /**
   * Get enabled feature flags for an account
   */
  getEnabledFeatureFlagsForAccount = this.query(getEnabledFeatureFlagsForAccount)

  /**
   * Retries a external link by type.
   */
  getExternalLinksByType = this.query(getExternalLinksByType)

  /** Account admin flow - for backoffice use */

  /**
   * Create an enterprise account
   */
  createEnterpriseAccount = this.mutation(create1)
  /**
   * Lists enterprise accounts
   */
  getEnterpriseAccounts = this.query(getAccounts)
  /**
   * Get an enterprise account
   */
  getEnterpriseAccount = this.query(getAccount1)
  /**
   * Adds a new email domain to an existing account
   */
  addEmailDomain = this.mutation(addNewEmailDomain)
  /**
   * Updates the sales representatives
   */
  updateSalesRepresentatives = this.mutation(updateSalesRepresentatives)
  /**
   * Create FIDO magic link
   */
  createFidoMagicLink = this.mutation(createFidoMagicLink)
  /**
   * Delete FIDO key
   */
  deleteFidoKey = this.mutation(deleteFidoKey)
  /**
   * Find Secret Associations
   */
  findSecretAssociations = this.infiniteQuery(findAssociations, { accumulator: 'items' })
  /**
   * Get expiration data
   */
  getExpirationData = this.query(getPersonalAccountExpirationData)
  /**
   * Reactive trial account
   */
  reactivateTrialAccount = this.mutation(reactivateTrialAccount)
}

export const accountClient = new AccountClient()
