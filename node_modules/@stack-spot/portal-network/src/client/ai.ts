import { HttpError } from '@oazapfts/runtime'
import { findLast, isArray, last } from 'lodash'
import { getApiAddresses } from '../api-addresses'
import {
  addFavoriteV1AiStacksStackIdFavoritePost,
  addFavoriteV1QuickCommandsSlugFavoritePost,
  calculateNextStepV1QuickCommandsSlugStepsStepSlugCalculateNextStepPost,
  callbackV1QuickCommandsCallbackExecutionIdGet,
  conversationHistoryV1ConversationsConversationIdGet,
  createExecutionV1QuickCommandsCreateExecutionSlugPost,
  currentV1TokensUsageCurrentGet,
  defaults,
  deleteConversationV1ConversationsConversationIdDelete,
  deleteFavoriteV1AiStacksStackIdFavoriteDelete,
  deleteFavoriteV1QuickCommandsSlugFavoriteDelete,
  deleteKnowledgeObjectByCustomIdV1KnowledgeSourcesSlugObjectsCustomIdDelete,
  downloadConversationV1ConversationsConversationIdDownloadGet,
  findKnowledgeObjectByCustomIdV1KnowledgeSourcesSlugObjectsCustomIdGet,
  findKnowledgeSourceV1KnowledgeSourcesSlugGet,
  formatFetchStepV1QuickCommandsSlugStepsStepSlugFetchFormatPost,
  formatResultV1QuickCommandsSlugResultFormatPost,
  getContentDependenciesV1ContentContentTypeContentIdDependenciesGet,
  getFlagsV1FlagsGet,
  getQuickCommandV1QuickCommandsSlugGet,
  getScriptExecutionStatusV1QuickCommandsScriptExecutionsScriptExecutionIdGet,
  getUploadFormV1FileUploadFormPost,
  HttpValidationError,
  listAiStacksV1AiStacksGet,
  listAllV1QuickCommandsAllGet,
  listAllV2QuickCommandsAllGet,
  listAssociationV1WorkspaceWorkspaceIdGet,
  listConversationsV1ConversationsGet,
  listKnowledgeSourcesV1KnowledgeSourcesGet,
  postEventV1EventsPost,
  quickActionsV1QuickActionsPost,
  QuickCommandPromptResponse2,
  QuickCommandsExecutionRequest,
  quickCommandsRunV2V2QuickCommandsSlugStepsStepSlugRunPost,
  resetKnowledgeObjectsV1KnowledgeSourcesSlugObjectsDelete,
  runFetchStepV1QuickCommandsSlugStepsStepSlugFetchRunPost,
  searchKnowledgeSourcesV1KnowledgeSourcesSearchPost,
  startScriptStepV1QuickCommandsSlugStepsStepSlugStartScriptPost,
  totalV1TokensUsageTotalGet,
  updateQuickCommandV1QuickCommandsSlugPatch,
  updateTitleV1ConversationsConversationIdPatch,
  vectorizeCustomKnowledgeSourceV1KnowledgeSourcesSlugCustomPost,
} from '../api/ai'
import { StackspotAPIError } from '../error/StackspotAPIError'
import { ReactQueryNetworkClient } from '../network/ReactQueryNetworkClient'
import { removeAuthorizationParam } from '../utils/remove-authorization-param'
import { StreamedJson } from '../utils/StreamedJson'
import { formatJson } from '../utils/string'
import { agentToolsClient } from './agent-tools'
import {
  ChatAgentTool,
  ChatResponseWithSteps,
  FixedChatRequest,
  FixedChatResponse,
  FixedConversationResponse,
  FixedDependencyResponse,
  ReplaceResult,
  StepChatStep,
} from './types'

class AIClient extends ReactQueryNetworkClient {
  constructor() {
    super(getApiAddresses().ai.url, defaults)
  }

  protected buildStackSpotError(error: HttpError): StackspotAPIError {
    // @ts-ignore API documentation is wrong
    const details = (error.data as HttpValidationError | undefined)?.details
    return new StackspotAPIError({
      status: error.status,
      headers: error.headers,
      stack: error.stack,
      message: isArray(details) ? details?.map(d => d.msg)?.join('\n') : details,
    })
  }

  /**
   * Chat: runs a quick action.
   */
  runQuickAction = this.mutation(removeAuthorizationParam(quickActionsV1QuickActionsPost))
  /**
   * Deletes a KO from a KS
   */
  deleteKnowledgeObjectFromKs = this.mutation(
    removeAuthorizationParam(deleteKnowledgeObjectByCustomIdV1KnowledgeSourcesSlugObjectsCustomIdDelete))
  /**
   * Deletes a KO by standalone (reset Knowledge Objects)
   */
  deleteKnowledgeObjectsByStandalone = this.mutation(
    removeAuthorizationParam(resetKnowledgeObjectsV1KnowledgeSourcesSlugObjectsDelete))
  /**
   * Uploads a KO file
   */
  fileUploadFormKnowledgeObject = this.mutation(
    removeAuthorizationParam(getUploadFormV1FileUploadFormPost))
  /**
   *  Creates a custom KO (Vectorize)
   */
  vectorizeCustomKS = this.mutation(
    removeAuthorizationParam(vectorizeCustomKnowledgeSourceV1KnowledgeSourcesSlugCustomPost))
  /**
   * Lists the AI Stacks according to their visibilities.
   */
  aiStacks = this.query(removeAuthorizationParam(listAiStacksV1AiStacksGet))
  /**
   * Gets total tokens usage
   */
  totalTokensUsage = this.query(removeAuthorizationParam(totalV1TokensUsageTotalGet))
  /**
   * Gets current tokens usage
   */
  currentTokensUsage = this.query(removeAuthorizationParam(currentV1TokensUsageCurrentGet))
  /**
   * Gets a workspace by its id.
   */
  workspace = this.query(removeAuthorizationParam(listAssociationV1WorkspaceWorkspaceIdGet))
  /**
   * @deprecated
   * Lists the quick commands according to filters passed as parameter (QC with secrets will not be returned).
   */
  quickCommands = this.query(removeAuthorizationParam(listAllV1QuickCommandsAllGet))
  /**
   * Lists all the quick commands according to filters passed as parameter (including QC with secrets).
   */
  allQuickCommands = this.query(removeAuthorizationParam(listAllV2QuickCommandsAllGet))
  /**
   * Gets a quick command by its slug.
   */
  quickCommand = this.query(removeAuthorizationParam(getQuickCommandV1QuickCommandsSlugGet))
  /**
   * Creates a new execution for a quick command by its slug.
   */
  quickCommandCreateExecution = this.mutation(removeAuthorizationParam(createExecutionV1QuickCommandsCreateExecutionSlugPost))
  /**
   * Gets the execution status and result of a quick command by its execution ID.
   */
  quickCommandCallbackExecutionId = this.query(removeAuthorizationParam(callbackV1QuickCommandsCallbackExecutionIdGet))
  /**
   * Lists the knowledge sources according to filters passed as parameter.
   */
  knowledgeSources = this.query(removeAuthorizationParam(listKnowledgeSourcesV1KnowledgeSourcesGet))
  /**
   * Gets a knowledge source by its slug.
   */
  knowledgeSource = this.query(removeAuthorizationParam(findKnowledgeSourceV1KnowledgeSourcesSlugGet))
  /**
   * Gets a knowledge source document by the slug of the parent knowledge source and the document id.
   */
  knowledgeSourceDocument = this.query(removeAuthorizationParam(findKnowledgeObjectByCustomIdV1KnowledgeSourcesSlugObjectsCustomIdGet))
  /**
   * Lists knowledge sources matching the provided IDs.
   */
  searchKnowledgeSources = this.query(removeAuthorizationParam(searchKnowledgeSourcesV1KnowledgeSourcesSearchPost))
  /**
   * Gets the chat history. This is a paginated resource.
   */
  chats = this.infiniteQuery(removeAuthorizationParam(listConversationsV1ConversationsGet))
  /**
   * Gets a specific chat from the history according to its id.
   */
  chat = this.query(removeAuthorizationParam(
    conversationHistoryV1ConversationsConversationIdGet as ReplaceResult<
      typeof conversationHistoryV1ConversationsConversationIdGet,
      FixedConversationResponse
    >,
  ))
  /**
   * Deletes a chat from the chat history.
   */
  deleteChat = this.mutation(removeAuthorizationParam(deleteConversationV1ConversationsConversationIdDelete))
  /**
   * Gets a plain text version of the chat with id passed as parameter.
   */
  downloadChat = this.mutation(removeAuthorizationParam(downloadConversationV1ConversationsConversationIdDownloadGet))
  /**
   * Renames a chat.
   */
  renameChat = this.mutation(removeAuthorizationParam(updateTitleV1ConversationsConversationIdPatch))
  /**
   * Creates an event so it can be used as metric by the product designers (analytics).
   */
  createEvent = this.mutation(removeAuthorizationParam(postEventV1EventsPost))
  /**
   * Runs a step of type "fetch" of a quick command.
   */
  fetchStepOfQuickCommand = this.mutation(removeAuthorizationParam(formatFetchStepV1QuickCommandsSlugStepsStepSlugFetchFormatPost))
  /**
   * Remotely runs a step of type "fetch" of a quick command remotely (used when secrets are present).
   */
  fetchStepOfQuickCommandRemotely = this.mutation({
    name: 'fetchStepOfQuickCommandRemotely',
    request: (
      signal,
      variables: Omit<Parameters<typeof runFetchStepV1QuickCommandsSlugStepsStepSlugFetchRunPost>[0], 'authorization'> &
      { headers?: Record<string, any> },
    ) => {
      const { headers, ...props } = variables
      return runFetchStepV1QuickCommandsSlugStepsStepSlugFetchRunPost({ ...props, authorization: '' }, { signal, headers })
    },
    permission: this.createPermissionFunctionFor(runFetchStepV1QuickCommandsSlugStepsStepSlugFetchRunPost),
  })

  /**
   * @deprecated This method does not use stream, only json. The json support has been removed
   * So this method might not work as expected.
   * Runs a step of type "llm" of a quick command.
   */
  llmStepOfQuickCommand = this.mutation(removeAuthorizationParam(quickCommandsRunV2V2QuickCommandsSlugStepsStepSlugRunPost))
  /**
   * Calculates QC router next step.
  */
  calculateNextStep = this.mutation(removeAuthorizationParam(calculateNextStepV1QuickCommandsSlugStepsStepSlugCalculateNextStepPost))
  /**
   * Runs a stream of a step of type "llm" of a quick command.
   */
  streamLlmStepOfQuickCommand(slug: string, stepSlug: string, quickCommandsExecutionRequest: QuickCommandsExecutionRequest,
    minChangeIntervalMS?: number):
    StreamedJson<QuickCommandPromptResponse2> {
    const abortController = new AbortController()
    const headers = {
      'Content-Type': 'application/json',
      'Accept': 'text/event-stream',
    }
    const events = this.stream(
      this.resolveURL(`/v2/quick-commands/${slug}/steps/${stepSlug}/run`),
      { method: 'post', body: JSON.stringify(quickCommandsExecutionRequest), headers, signal: abortController.signal },
    )

    return new StreamedJson({
      eventsPromise: events,
      abortController,
      minChangeIntervalMS,
    })
  }
  /**
   * Formats the result of a quick command into a human-readable text (markdown).
   */
  formatResultOfQuickCommand = this.mutation(removeAuthorizationParam(formatResultV1QuickCommandsSlugResultFormatPost))
  /**
   * Adds the resource of type Stack AI to the list of favorites.
  */
  addFavoriteStackAi = this.mutation(removeAuthorizationParam(addFavoriteV1AiStacksStackIdFavoritePost))
  /**
   * Removes the resource of type Stack AI from the list of favorites.
   */
  removeFavoriteStackAi = this.mutation(removeAuthorizationParam(deleteFavoriteV1AiStacksStackIdFavoriteDelete))
  /**
   * Updates a Quick Command
   */
  updateQuickCommand = this.mutation(removeAuthorizationParam(updateQuickCommandV1QuickCommandsSlugPatch))
  /**
   * Adds the resource of type Quick Command to the list of favorites.
   */
  addFavoriteQuickCommand = this.mutation(removeAuthorizationParam(addFavoriteV1QuickCommandsSlugFavoritePost))
  /**
   * Removes the resource of type Quick Command from the list of favorites.
   */
  removeFavoriteQuickCommand = this.mutation(removeAuthorizationParam(deleteFavoriteV1QuickCommandsSlugFavoriteDelete))
  /**
   * Lists all the feature flags for this user.
   */
  flags = this.query(getFlagsV1FlagsGet)
  /**
   * Starts the execution of a script step
   */
  startScriptStep = this.mutation(removeAuthorizationParam(startScriptStepV1QuickCommandsSlugStepsStepSlugStartScriptPost))
  /**
   * Gets the status of the execution of a script step
   */
  getStatusScriptStep = this.query(removeAuthorizationParam(getScriptExecutionStatusV1QuickCommandsScriptExecutionsScriptExecutionIdGet))

  private static async toolsOfAgent(agentId?: string) {
    try {
      const agent = agentId ? await agentToolsClient.agent.query({ agentId }) : undefined
      if (!agent) return []
      const tools: (Omit<ChatAgentTool, 'duration' | 'prompt' | 'output'>)[] = []
      agent.toolkits?.builtin_toolkits?.forEach(kit => kit.tools?.forEach(({ id, name, description }) => {
        if (id) tools.push({ image: kit.image_url, id, name: name || id, description })
      }))
      agent.toolkits?.custom_toolkits?.forEach(kit => kit.tools?.forEach(({ id, name, description }) => {
        if (id) tools.push({ image: kit.avatar ?? undefined, id, name: name || id, description })
      }))
      return tools
    } catch {
      return []
    }
  }

  sendChatMessage(request: FixedChatRequest, minChangeIntervalMS?: number): StreamedJson<ChatResponseWithSteps> {
    const abortController = new AbortController()
    const headers = {
      'Content-Type': 'application/json',
      'Accept': 'text/event-stream',
    }
    const events = this.stream(
      this.resolveURL('v3/chat'),
      { method: 'post', body: JSON.stringify(request), headers, signal: abortController.signal },
    )

    /**
     * This function treats events in the streaming that deals with the execution of tools. Since these events are not concatenated like
     * normal streamings of data, we need this separate function to deal with them. It transforms the internal data model of the
     * StreamedJson object whenever an event is triggered.
     */
    async function transform(event: Partial<FixedChatResponse>, data: Partial<ChatResponseWithSteps>) {
      const info = event.agent_info

      if (!info) return

      const tools = await AIClient.toolsOfAgent(request.context?.agent_id)
      data.steps = data.steps ? [...data.steps] : []

      if (info.type === 'planning' && info.action === 'end') {
        data.steps.push({
          id: 'planning',
          type: 'planning',
          status: 'success',
          duration: info.duration || 0,
          steps: info.data?.steps?.map(s => s.goal) ?? [],
          goal: info.data?.plan_goal ?? '',
        })

        info.data?.steps.forEach(s => data.steps?.push({
          id: s.id,
          type: 'step',
          status: 'pending',
          input: s.goal,
          attempts: [{
            tools: s.tools?.map(t => ({
              ...(tools.find(({ id }) => id === t.tool_id) ?? { id: t.tool_id, name: t.tool_id }),
              executionId: t.tool_execution_id,
              goal: t.goal,
            })),
          }],
        }))
        data.steps.push({ id: 'answer', type: 'answer', status: 'pending' })
      }

      if (info.type === 'planning' && info.action === 'awaiting_approval') {
        data.steps.push({
          id: 'planning',
          type: 'planning',
          status: 'awaiting_approval',
          user_question: info.data?.user_question,
          duration: info.duration || 0,
          steps: info.data?.steps?.map(s => s.goal) ?? [],
          goal: info.data?.plan_goal ?? '',
        })
        info.data?.steps.forEach(s => data.steps?.push({
          id: s.id,
          type: 'step',
          status: 'pending',
          input: s.goal,
          attempts: [{
            tools: s.tools?.map(t => ({
              ...(tools.find(({ id }) => id === t.tool_id) ?? { id: t.tool_id, name: t.tool_id }),
              executionId: t.tool_execution_id,
              goal: t.goal,
            })),
          }],
        }))
        data.steps.push({ id: 'answer', type: 'answer', status: 'pending' })
      }

      if (info.type === 'step' && info.action === 'start') {
        const step = data.steps.find(s => s.id === info.id)
        if (step) step.status = 'running'
      }

      if (info.type === 'step' && info.action === 'end') {
        const step = data.steps.find(s => s.id === info.id) as StepChatStep
        if (step) {
          step.status = 'success'
          step.duration = info.duration
          const lastToolId = last(step.attempts[0].tools)?.id
          const lastAttemptOfLastTool = findLast(step.attempts.map(a => a.tools).flat(), t => t?.id === lastToolId)
          step.output = lastAttemptOfLastTool?.output
        }
      }

      if (info.type === 'tool' && info.action === 'awaiting_approval') {
        const tool = tools.find(({ id }) => id === info.data?.tool_id)
        data.steps.push({
          id: info.id,
          type: 'tool',
          status: 'awaiting_approval',
          duration: info.duration || 0,
          input: info.data?.input,
          user_question: info.data?.user_question,
          attempts: [{
            tools: [{
              executionId: info.id,
              id: info.data?.tool_id ?? '',
              name: tool?.name ?? '',
              goal: tool?.goal,
              ...tool,
            }],
          }],
        })
        data.steps.push({ id: 'answer', type: 'answer', status: 'pending' })
      }

      if (info.type === 'tool' && info.action === 'start') {
        const currentStep = data.steps.find(s => s.status === 'running') as StepChatStep
        if (!info.data) return

        //There might be a tool with status awaiting_approval, so we want to inform tool has already started
        if (!currentStep || !currentStep.attempts[0].tools) {
          const input = formatJson(info.data.input)
          const tool = tools.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id }
          data.steps.push({
            id: info.id,
            type: 'tool',
            status: 'running',
            duration: info.duration || 0,
            input: info.data?.input,
            user_question: info.data?.user_question,
            attempts: [{
              tools: [{ ...tool, executionId: info.id, input }],
            }],
          })
        } else {
          const toolInFirstAttempt = currentStep.attempts[0].tools?.find(t => t.executionId === info.id)
          //One step might have multiple tools. When in an approval mode, we might not have all the tools in the array yet.
          //So we make sure to add any tools that are not in there.
          if (!toolInFirstAttempt) {
            const input = formatJson(info.data.input)
            const tool = tools?.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id }
            currentStep.attempts[info.data.attempt - 1].tools?.push({
              ...tool,
              executionId: info.id,
              input,
            })
          } else {
            const input = formatJson(info.data.input)
            if (info.data.attempt === 1) {
              toolInFirstAttempt.input = input
            } else {
              const tool = tools.find(({ id }) => id === info.data?.tool_id) ?? { id: info.data?.tool_id, name: info.data?.tool_id }
              currentStep.attempts[info.data.attempt - 1] ??= { tools: [] }
              currentStep.attempts[info.data.attempt - 1].tools?.push({
                ...tool,
                executionId: info.id,
                input,
              })
            }
          }
        }
      }

      if (info.type === 'tool' && info.action === 'end') {
        const currentStep = data.steps.find(s => s.status === 'running') as StepChatStep
        if (!currentStep || !info.data) return
        const tool = currentStep.attempts[info.data.attempt - 1]?.tools?.find(t => t.executionId === info.id)
        if (tool) {
          tool.output = formatJson(info.data.output)
          tool.duration = info.duration
        }
      }

      if (info.type === 'final_answer' && info.action === 'start') {
        const answerStep = last(data.steps)
        if (answerStep) answerStep.status = 'running'
      }

      if (info.type === 'chat' && info.action === 'end') {
        const answerStep = last(data.steps)
        if (answerStep) {
          answerStep.status = 'success'
          answerStep.duration = info.duration
        }
      }
    }

    return new StreamedJson({
      eventsPromise: events,
      abortController,
      minChangeIntervalMS,
      ignoreKeys: ['agent_info'],
      transform,
    })
  }

  contentDependencies = this.query(removeAuthorizationParam(
    getContentDependenciesV1ContentContentTypeContentIdDependenciesGet as ReplaceResult<
      typeof getContentDependenciesV1ContentContentTypeContentIdDependenciesGet,
      FixedDependencyResponse
    >,
  ))
}

export const aiClient = new AIClient()
