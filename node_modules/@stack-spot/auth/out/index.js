'use strict';

var jose = require('jose');
var lodash = require('lodash');
var CryptoJS = require('crypto-es');
var sha256_js = require('crypto-es/lib/sha256.js');
var encBase64_js = require('crypto-es/lib/enc-base64.js');

var __defProp$b = Object.defineProperty;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$b = (obj, key, value) => {
  __defNormalProp$b(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class AuthenticationError extends Error {
  constructor(message) {
    super(message);
  }
}
class ConnectionError extends AuthenticationError {
  constructor() {
    super(`Unable to complete request. Please check your internet connection or contact your network administrator if the problem persists.`);
  }
}
class SessionExpiredError extends AuthenticationError {
  constructor() {
    super("The session is expired, please reauthenticate.");
  }
}
class MalFormedAccessToken extends AuthenticationError {
  constructor(token, cause) {
    super(`Unable to decode the access token, it seems to be malformed.
Cause: ${cause}`);
    __publicField$b(this, "token");
    this.cause = cause;
    this.token = token;
  }
}
class InvalidTenantError extends AuthenticationError {
  constructor(tenant) {
    super(`The tenant for authentication (${tenant}) is invalid.`);
    __publicField$b(this, "tenant");
    this.tenant = tenant;
  }
}
class InvalidCredentialsError extends AuthenticationError {
  constructor(status, method, tenant, description) {
    const reason = description || "The provided credentials are invalid. Please, try again.";
    super(`Error while retrieving token from the authentication service. Method: ${method}. Tenant: ${tenant}. Status: ${status}. Reason:
${reason}`);
  }
}
class InvalidSSOError extends AuthenticationError {
  constructor() {
    super("The e-mail provided doesn't correspond to any authentication provider in the database.");
  }
}
class InvalidProvider extends AuthenticationError {
  constructor() {
    super("The chosen provider is not currently supported");
  }
}
class AuthMethodUnavailable extends AuthenticationError {
  constructor(causes) {
    super(`The authentication is not currently available for the e-mail provided${causes ? `(${causes.filter((c) => !!c).join(", ")})` : ""}`);
  }
}
class LogoutError extends Error {
  constructor(response) {
    super(`Unable to logout from IAM. Cause: ${response.statusText}.`);
    __publicField$b(this, "response");
    this.response = response;
  }
}
class NetworkError extends Error {
  constructor({ response, body, message }) {
    super(message || `${response.status}. ${body}.`);
    __publicField$b(this, "response");
    this.response = response;
  }
  static async create(response) {
    let body = "";
    try {
      body = await response.text();
    } catch (e) {
    }
    return new NetworkError({ response, body });
  }
}
class PendingAuthenticationError extends AuthenticationError {
  constructor() {
    super("Can't authenticate because the device flow is still in progress, i.e. the user has not authenticated in the browser yet.");
  }
}
class AuthenticationTimeout extends AuthenticationError {
  constructor() {
    super("The user took to long to authenticate and this attempt is no longer valid.");
  }
}

var __defProp$a = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
var __publicField$a = (obj, key, value) => {
  __defNormalProp$a(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class InterceptorAuth {
  constructor(session) {
    __publicField$a(this, "session");
    this.session = session;
  }
  /**
   * The Fetch API can receive headers as an object in the format `{ headerKey: headerValue }`, an array with key-value pairs
   * `[[headerKey, headerValue]]` or an instance of the class `Headers`. This function receives any type of headers and normalizes it into
   * an object in the format `{ headerKey: headerValue }`.
   * @param headers the headers to normalize.
   * @returns an object where each entry is composed by a header key and a header value.
   */
  normalizeHeaders(headers) {
    try {
      if (headers instanceof Headers) {
        const record = {};
        headers.forEach((value, key) => record[key] = value);
        return record;
      }
    } catch (e) {
    }
    if (Array.isArray(headers)) {
      return headers.reduce((result, [key, value]) => __spreadProps$3(__spreadValues$4({}, result), { [key]: value }), {});
    }
    return headers;
  }
  /**
   * Intercepts the request to include the authentication token.
   * 
   * @param request the original request
   * @returns the request with the authentication header.
   */
  async interceptRequest(request) {
    var _a;
    const token = await this.session.getToken();
    const headers = lodash.omitBy(this.normalizeHeaders((_a = request.init) == null ? void 0 : _a.headers), (_, key) => key.toLowerCase() === "authorization");
    const init = __spreadProps$3(__spreadValues$4({}, request.init), {
      headers: __spreadProps$3(__spreadValues$4({}, headers), {
        authorization: `Bearer ${token}`
      })
    });
    return { url: request.url, init };
  }
}

var __defProp$9 = Object.defineProperty;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$9 = (obj, key, value) => {
  __defNormalProp$9(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const _InterceptorManager = class _InterceptorManager {
  constructor(originalFetch) {
    __publicField$9(this, "originalFetch");
    __publicField$9(this, "interceptors", {});
    this.originalFetch = originalFetch;
  }
  /**
   * Adds a new interceptor
   * @param interceptor The interceptor to add.
   * @return {Number} An ID used to remove interceptor later
   */
  addInterceptor(interceptor) {
    this.interceptors[_InterceptorManager.next++] = interceptor;
    return _InterceptorManager.next - 1;
  }
  /**
   * Remove an interceptor
   * @param {Number} id The ID that was returned by `addInterceptor`
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  removeInterceptor(id) {
    if (this.interceptors[id]) {
      delete this.interceptors[id];
      return true;
    }
    return false;
  }
  /**
   * Executes all request interceptors in sequence.
   * @param request The original request.
   * @returns The modified request.
   */
  async executeRequestInterceptors(request) {
    let modifiedRequest = request;
    for (const interceptor of Object.values(this.interceptors)) {
      if (interceptor.interceptRequest) {
        modifiedRequest = await interceptor.interceptRequest(modifiedRequest);
      }
    }
    return modifiedRequest;
  }
  /**
   * Executes all response interceptors in sequence.
   * @param response The original response.
   * @param request The original request.
   * @returns The modified response.
   */
  async executeResponseInterceptors(response, request) {
    let modifiedResponse = response;
    for (const interceptor of Object.values(this.interceptors)) {
      if (interceptor.interceptResponse) {
        modifiedResponse = await interceptor.interceptResponse(modifiedResponse, request);
      }
    }
    return modifiedResponse;
  }
  /**
   * A custom implementation of {@link global.fetch} including all interceptors.
   * @param input The URL to the request.
   * @param init The request options.
   * @returns The response.
   */
  async fetch(input, init) {
    const request = await this.executeRequestInterceptors({ url: input, init });
    const response = await this.originalFetch(request.url, request.init);
    return this.executeResponseInterceptors(response, request);
  }
};
__publicField$9(_InterceptorManager, "next", 0);
let InterceptorManager = _InterceptorManager;

var __defProp$8 = Object.defineProperty;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$8 = (obj, key, value) => {
  __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class InterceptorRetry {
  constructor(maxRetrials, retryDelay, originalFetch) {
    __publicField$8(this, "maxRetrials");
    __publicField$8(this, "retryDelay");
    __publicField$8(this, "originalFetch");
    this.maxRetrials = maxRetrials;
    this.retryDelay = retryDelay;
    this.originalFetch = originalFetch;
  }
  /**
   * Intercepts the response in order to perform retrials in case of errors.
   * 
   * @param response the original response.
   * @param request the request.
   * @param retrials the number of retrials already performed.
   * @returns the retried response.
   */
  async interceptResponse(response, request, retrials = 0) {
    var _a, _b, _c, _d;
    if (response.ok || retrials >= this.maxRetrials || ((_b = (_a = request.init) == null ? void 0 : _a.signal) == null ? void 0 : _b.aborted))
      return response;
    await new Promise((resolve) => {
      var _a2, _b2;
      const timeout = setTimeout(resolve, this.retryDelay);
      (_b2 = (_a2 = request.init) == null ? void 0 : _a2.signal) == null ? void 0 : _b2.addEventListener("abort", () => {
        clearTimeout(timeout);
        resolve();
      });
    });
    if ((_d = (_c = request.init) == null ? void 0 : _c.signal) == null ? void 0 : _d.aborted)
      return response;
    const newResponse = await this.originalFetch(request.url, request.init);
    return this.interceptResponse(newResponse, request, retrials + 1);
  }
}

function queryStringToObject(qs) {
  return [...new URLSearchParams(qs)].reduce(
    (result, [key, value]) => (result[key] = value, result),
    {}
  );
}
function secondsToMilliseconds(seconds) {
  return seconds * 1e3;
}
const numberOfSymbols = 36;
const aCode = "a".charCodeAt(0);
function randomizeString(numberOfChars) {
  const rand = lodash.random(0, numberOfSymbols - 1);
  const char = rand < 10 ? `${rand}` : String.fromCharCode(aCode + (rand - 10));
  return numberOfChars > 1 ? `${char}${randomizeString(numberOfChars - 1)}` : char;
}
function randomizeNumericString(numberOfChars) {
  const rand = lodash.random(0, 9);
  return numberOfChars > 1 ? `${rand}${randomizeNumericString(numberOfChars - 1)}` : `${rand}`;
}
async function printResponseError(response) {
  let body = "";
  try {
    body = await response.text();
  } catch (e) {
  }
  const headers = [];
  response.headers.forEach((v, k) => headers.push(`${k} = ${v}`));
  console.error(`Request to ${response.url} failed.
status: ${response.status}
statusText: ${response.statusText}
body: "${body}"
headers: ${headers.join(", ")}.`);
}
async function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

var __defProp$7 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __publicField$7 = (obj, key, value) => {
  __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const refreshCheck = {
  maxAttempts: 10,
  intervalMS: 500
};
const expiryTimeMarginMs = 15e3;
function jwtToAccessTokenPayload(token) {
  try {
    return jose.decodeJwt(token);
  } catch (error) {
    throw new MalFormedAccessToken(token, error);
  }
}
function parseSerializedSession(serialized) {
  var _a;
  const [_, time, data] = (_a = serialized.match(/^(\d*);(.*)$/)) != null ? _a : [];
  const error = new Error(`Error while deserializing Session. Malformed string.
${serialized}`);
  if (!time || !data)
    throw error;
  try {
    return { time, data: JSON.parse(data) };
  } catch (e) {
    throw error;
  }
}
function isTokenExpired(tokenData, clientTimeMs, safetyMarginMs = 0) {
  if (!tokenData.exp || !tokenData.iat)
    return false;
  const issued = secondsToMilliseconds(tokenData.iat);
  const expiration = secondsToMilliseconds(tokenData.exp);
  const duration = expiration - issued - safetyMarginMs;
  return (/* @__PURE__ */ new Date()).getTime() > (clientTimeMs || issued) + duration;
}
class Session {
  constructor(data, config, tokenClient, lastPersisted = "") {
    __publicField$7(this, "data", {});
    // this is initialized in the constructor
    __publicField$7(this, "accessTokenData", {});
    __publicField$7(this, "refreshTokenData", {});
    __publicField$7(this, "currentRefresh");
    __publicField$7(this, "tokenClient");
    __publicField$7(this, "persistence");
    __publicField$7(this, "interceptor");
    __publicField$7(this, "lastPersisted");
    __publicField$7(this, "interceptorAuthId");
    __publicField$7(this, "interceptorRetryId");
    __publicField$7(this, "logger");
    this.logger = config.logger;
    this.setSessionData(data);
    this.tokenClient = tokenClient;
    this.persistence = config.sessionPersistence;
    this.lastPersisted = lastPersisted;
    if (!lastPersisted)
      this.persist();
    this.interceptor = new InterceptorManager(config.fetch);
    this.setInterceptors(config);
  }
  setSessionData(data) {
    this.data = data;
    this.accessTokenData = jwtToAccessTokenPayload(data.access_token);
    this.refreshTokenData = jwtToAccessTokenPayload(data.refresh_token);
    this.serialize();
  }
  setInterceptors(config) {
    const interceptorAuth = new InterceptorAuth(this);
    const interceptorRetry = new InterceptorRetry(config.retry, config.retryDelay, config.fetch);
    this.interceptorAuthId = this.interceptor.addInterceptor(interceptorAuth);
    this.interceptorRetryId = this.interceptor.addInterceptor(interceptorRetry);
  }
  /**
   * Updates values in the session data. Values not available in the object passed as parameter will keep their previous values.
   * Useful for changing tokens with arbitrary values.
   * @param data the properties to update
   */
  updateSessionData(data) {
    this.setSessionData(__spreadValues$3(__spreadValues$3({}, this.data), data));
    this.persist();
  }
  /**
   * Restores a serialized session created with `Session#serialize()`.
   * 
   * It's a good idea to call `Session#isExpired()` right after this to check the session validity.
   * 
   * @param serialized the serialized session as a string.
   * @param tokenClient a TokenClient.
   * @returns the restored session.
   */
  static fromSerializedSession(serialized, config, tokenClient) {
    const { time, data } = parseSerializedSession(serialized);
    return new Session(data, config, tokenClient, time);
  }
  async loadPersisted() {
    var _a;
    const persisted = await ((_a = this.persistence) == null ? void 0 : _a.load());
    if (!persisted || persisted.startsWith(`${this.lastPersisted};`))
      return;
    try {
      const { data } = parseSerializedSession(persisted);
      this.logger.log("Loaded session from storage.");
      this.setSessionData(data);
    } catch (error) {
      this.logger.error("Unable to load session from storage.", error);
      console.error("Error while recovering session.", error);
    }
  }
  async persist() {
    if (!this.persistence)
      return;
    this.lastPersisted = `${Date.now()}`;
    await this.persistence.save(this.serialize());
    this.logger.log("Session persisted in storage.");
  }
  async refreshSession() {
    try {
      const data = await this.tokenClient.authenticate(
        "refreshToken",
        {
          refreshToken: this.data.refresh_token,
          clientId: this.data.client_id,
          tenant: this.data.tenant
        }
      );
      this.setSessionData(data);
      await this.persist();
      return this.data.access_token;
    } catch (error) {
      if (!(error instanceof AuthenticationError)) {
        console.error("Unexpected error while refreshing token:", error.message || `${error}`);
      }
      if (error instanceof InvalidCredentialsError) {
        let attempts = refreshCheck.maxAttempts;
        while (attempts && this.shouldRefreshToken()) {
          this.logger.warn(`Failed to refresh token. ${attempts} attempts left.`);
          await delay(refreshCheck.intervalMS);
          await this.loadPersisted();
          attempts--;
        }
        if (this.shouldRefreshToken())
          throw error;
        else
          return this.data.access_token;
      } else {
        throw error;
      }
    }
  }
  shouldRefreshToken() {
    return isTokenExpired(this.accessTokenData, this.data.clientTimeMs, expiryTimeMarginMs);
  }
  /**
   * Gets the current access token.
   * 
   * - If the access token is set to expire within the next 15 seconds, it refreshes it before returning (async).
   * - If the refresh token is also invalid, then this session is no longer valid and a {@link SessionExpiredError} is thrown.
   * - If an error occurs while refreshing, this error is thrown.
   * 
   * Important: this function never produces multiple concurrent calls to the authentication API. Whenever multiple calls are made, they
   * use the same ongoing request. In summary, there's no need to worry about multiple requests triggering this at the same time.
   * 
   * @throws
   * - {@link SessionExpiredError} when the both the access token and refresh token are expired.
   * - {@link AuthenticationError}, {@link InvalidCredentialsError}, {@link InvalidTenantError} when the refresh fails.
   * 
   * @returns a promise that resolves to the access token.
   */
  async getToken() {
    await this.loadPersisted();
    if (this.currentRefresh)
      return this.currentRefresh;
    if (this.isExpired()) {
      this.logger.warn("Session is expired. A new login is required.");
      throw new SessionExpiredError();
    }
    if (this.shouldRefreshToken()) {
      this.logger.log("Session must be refreshed (refresh token).");
      this.currentRefresh = this.refreshSession();
      await this.currentRefresh;
      this.currentRefresh = void 0;
    }
    return this.data.access_token;
  }
  /**
   * A Session is expired if its refresh token is expired.
   * @returns true if the session is expired, false otherwise.
   */
  isExpired() {
    return isTokenExpired(this.refreshTokenData, this.data.clientTimeMs);
  }
  /**
   * Gets the data contained in the access token.
   * Useful for getting user information like name and email.
   * @returns the access token data.
   */
  getTokenData() {
    return this.accessTokenData;
  }
  /**
   * Gets the raw data used to build the session.
   * @returns the session data.
   */
  getSessionData() {
    return this.data;
  }
  /**
   * Serializes this session.
   * 
   * The session can be restored with Session.fromSerializedSession(string).
   * 
   * Format: {unix time in ms when the session was created or restored};{session data ({@link SessionPayload}) in json form}
   * 
   * @returns the serialized session.
   */
  serialize() {
    return `${this.lastPersisted};${JSON.stringify(this.data)}`;
  }
  /**
   * A custom implementation of {@link global.fetch} including authentication and retrials on errors. This will take care of refreshing the
   * token when necessary.
   * 
   * @throws
   * - {@link SessionExpiredError} when both the access token and refresh token are expired.
   * - {@link AuthenticationError}, {@link InvalidCredentialsError}, {@link InvalidTenantError} when the refresh fails.
   * 
   * @param input the URL to the request.
   * @param init the request options.
   * @returns the response.
   */
  fetch(input, init) {
    return this.interceptor.fetch(input, init);
  }
  /**
  * Adds an interceptor
  * 
  * @param interceptor - The interceptor to add.
  * @returns The ID of the added interceptor.
  */
  addInterceptor(interceptor) {
    return this.interceptor.addInterceptor(interceptor);
  }
  /**
   * Removes an interceptor
   * 
   * @param id - The ID of the interceptor to remove.
   */
  removeInterceptor(id) {
    if (id !== this.interceptorAuthId && id !== this.interceptorRetryId) {
      return this.interceptor.removeInterceptor(id);
    }
  }
  /**
   * Logs out from IAM.
   * @throws
   * - {@link LogoutError} if the logout fails. This error has the original response as one of its properties.
   */
  logout() {
    return this.tokenClient.logout(this.data);
  }
}

const UUID_V4_TEMPLATE = "10000000-1000-4000-8000-100000000000";
class CryptoUtils {
  static _randomWord() {
    return CryptoJS.lib.WordArray.random(1).words[0];
  }
  /**
   * Generates RFC4122 version 4 guid
   */
  static generateUUIDv4() {
    const uuid = UUID_V4_TEMPLATE.replace(
      /[018]/g,
      (c) => (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16)
    );
    return uuid.replace(/-/g, "");
  }
  /**
   * PKCE: Generate a code verifier
   */
  static generateCodeVerifier() {
    return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();
  }
  /**
   * PKCE: Generate a code challenge
   */
  static generateCodeChallenge(code_verifier) {
    try {
      const hashed = sha256_js.SHA256(code_verifier);
      return encBase64_js.Base64.stringify(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    } catch (err) {
      throw err;
    }
  }
}
const random = CryptoUtils.generateCodeVerifier;
const generators = {
  random,
  state: random,
  nonce: random,
  codeVerifier: random,
  codeChallenge: CryptoUtils.generateCodeChallenge
};

var __defProp$6 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var __publicField$6 = (obj, key, value) => {
  __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const MAX_ATTEMPTS_TO_GENERATE_ACCOUNT = 5;
const storageKeyPrefix = "stackSpotAuth.thirdPartyLogin.";
const maxLoginTimeMs = 24 * 60 * 60 * 1e3;
function buildPKCE() {
  const codeVerifier = generators.codeVerifier();
  return {
    state: generators.state(),
    codeVerifier,
    codeChallenge: generators.codeChallenge(codeVerifier)
  };
}
function buildStorageKey(state) {
  return `${storageKeyPrefix}${state}`;
}
class ThirdPartyClient {
  constructor(config, tokenClient) {
    __publicField$6(this, "config");
    __publicField$6(this, "tokenClient");
    this.config = config;
    this.tokenClient = tokenClient;
  }
  async findAuthDataByEmail(email) {
    const url = `${this.config.accountUrl}/v1/accounts?email=${encodeURIComponent(email)}`;
    const response = await this.config.fetch(url);
    if (response.ok) {
      const { tenant, idp, accountType, iamTenant } = await response.json();
      if (!tenant)
        throw new InvalidSSOError();
      return { tenant, idp, accountType, iamTenant };
    }
    printResponseError(response);
    let errorCode;
    try {
      errorCode = (await response.json()).code;
    } catch (e) {
    }
    throw errorCode === "ACC_ACCOUNT_NOT_FOUND_ERROR" ? new InvalidSSOError() : new AuthMethodUnavailable([response.statusText, response.status, errorCode]);
  }
  buildSearchParams({ codeChallenge, state, email, idp, locale, type }) {
    const params = {
      state,
      client_id: this.config.clientId,
      redirect_uri: this.config.redirectUrl,
      response_type: "code",
      scope: "openid email offline_access profile attributes roles",
      code_challenge: codeChallenge,
      code_challenge_method: "S256",
      ui_locales: locale || "en"
    };
    if (email) {
      params.login_hint = email;
    }
    if (type === "idp" && !!idp) {
      params.login_hint = idp;
    }
    return new URLSearchParams(params);
  }
  clearExpiredLoginAttempts() {
    var _a;
    const st = this.config.storage;
    for (let i = 0; i < st.length; i++) {
      const key = st.key(i);
      if (key == null ? void 0 : key.startsWith(storageKeyPrefix)) {
        const data = JSON.parse((_a = st.getItem(key)) != null ? _a : "{}");
        if (Date.now() - data.createdAt > maxLoginTimeMs)
          st.removeItem(key);
      }
    }
  }
  /**
   * Performs an authenticated fetch and returns the JSON result.
   */
  async authFetch(input, token, init) {
    const headers = __spreadProps$2(__spreadValues$2({}, init == null ? void 0 : init.headers), { authorization: `Bearer ${token}`, "content-type": "application/json; charset=utf-8" });
    const response = await this.config.fetch(input, __spreadProps$2(__spreadValues$2({}, init), { headers }));
    if (!response.ok)
      throw await NetworkError.create(response);
    return response.json();
  }
  async isAccountAvailable(acc, accessToken) {
    var _a;
    const params = new URLSearchParams(acc);
    const url = `${this.config.accountUrl}/v1/accounts/freemium/available?${params}`;
    try {
      const { available } = await this.authFetch(url, accessToken);
      return available != null ? available : false;
    } catch (error) {
      console.error("Error while validating account name and slug. Cause:", (_a = error.message) != null ? _a : error);
    }
    return false;
  }
  createSlug(name) {
    return lodash.deburr(name).toLowerCase().replaceAll(/^-+|-+$/g, "").replace(/ /g, "-").replace(/(-)+/g, "-").replace(/[^a-z-\d]/g, "").substring(0, 60);
  }
  async generateAccount(accessToken, name, remainingAttempts = MAX_ATTEMPTS_TO_GENERATE_ACCOUNT) {
    if (remainingAttempts === 0 || !name) {
      const name2 = randomizeString(20);
      return { name: name2, slug: name2 };
    }
    const suffix = remainingAttempts === MAX_ATTEMPTS_TO_GENERATE_ACCOUNT ? void 0 : randomizeNumericString(4);
    name = suffix ? `${name} ${suffix}` : name;
    const acc = { name, slug: this.createSlug(name) };
    const available = await this.isAccountAvailable(acc, accessToken);
    return available ? acc : this.generateAccount(accessToken, name, remainingAttempts - 1);
  }
  getUserName({ name, given_name, family_name, preferred_username, email }) {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = name != null ? name : given_name && family_name ? `${given_name} ${family_name}` : void 0) != null ? _a : email) != null ? _b : preferred_username) != null ? _c : given_name) != null ? _d : family_name;
  }
  async createAccount(accessToken) {
    var _a;
    const data = jwtToAccessTokenPayload(accessToken);
    if (data.freemium_status === "PENDING") {
      const url = `${this.config.accountUrl}/v1/accounts/freemium`;
      const acc = await this.generateAccount(accessToken, this.getUserName(data));
      try {
        await this.authFetch(url, accessToken, { method: "post", body: JSON.stringify(acc) });
      } catch (error) {
        console.error(
          "It was not possible to complete the account creation. The user will be able to use some features, but not all. A new attempt will be made in the next login. Cause:",
          (_a = error.message) != null ? _a : error
        );
      }
      return true;
    }
    return false;
  }
  async refreshToken(session) {
    var _a;
    try {
      return this.tokenClient.authenticate(
        "refreshToken",
        { refreshToken: session.refresh_token, clientId: session.client_id, tenant: session.tenant }
      );
    } catch (error) {
      console.error(
        "Could not refresh token after account creation. Permissions will be reduced during this session. Cause:",
        (_a = error.message) != null ? _a : error
      );
      return session;
    }
  }
  /**
   * Performs a 3rd party login (first part).
   * 
   * This operation happens in two parts, this is the first one and it returns the URL to redirect the user to login.
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   * 
   * @throws
   * - {@link InvalidSSOError}: if the email doesn't correspond to any SSO registered.
   * - {@link AuthMethodUnavailable}: if the 3rd party login is temporally unavailable.
   * - {@link PasswordExpectedError}: if the email address is managed by StackSpot itself and should instead use password login. This
   * exception has the property `tenant`, so it can be catch and redirect the user to the expected login method.
   * 
   * @param login parameters to the 3rd party login.
   * @returns the external url to login and the state. The state can be used to identify this login attempt.
   */
  async getThirdPartyLoginUrlAndState(login, data) {
    this.clearExpiredLoginAttempts();
    const { idp, iamTenant = "" } = login.type === "sso" ? await this.findAuthDataByEmail(login.email) : {
      idp: login.provider,
      iamTenant: this.config.defaultTenant
    };
    const path = `${iamTenant}/oidc/auth`;
    const { codeVerifier, codeChallenge, state } = buildPKCE();
    const storageData = {
      codeVerifier,
      tenant: iamTenant,
      createdAt: Date.now(),
      data,
      provider: idp
    };
    this.config.storage.setItem(buildStorageKey(state), JSON.stringify(storageData));
    const params = this.buildSearchParams({
      codeChallenge,
      state,
      email: login.type === "sso" ? login.email : void 0,
      idp,
      locale: login.locale,
      type: login.type
    });
    return { url: `${this.config.authUrl}/${path}?${params}`, state };
  }
  /**
  * Performs a 3rd party login (first part) using the given tenant.
  * 
  * This operation happens in two parts, this is the first one and it returns the URL to redirect the user to login.
  * This function does not depend on the user email, instead will use the given tenant to mount the url.
  * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
  * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
  * 
  * @param login parameters to the 3rd party login.
  * @param tenant tenant to mount the 3rd party login url.
  * @returns the external url to login and the state. The state can be used to identify this login attempt.
  */
  async getThirdPartyLoginFromTenant(login, tenant, data) {
    this.clearExpiredLoginAttempts();
    const { idp, iamTenant = "" } = login.type === "sso" ? { iamTenant: tenant, idp: void 0 } : {
      idp: login.provider,
      iamTenant: this.config.defaultTenant
    };
    const path = `${iamTenant}/oidc/auth`;
    const { codeVerifier, codeChallenge, state } = buildPKCE();
    const storageData = {
      codeVerifier,
      tenant: iamTenant,
      createdAt: Date.now(),
      data,
      provider: idp
    };
    this.config.storage.setItem(buildStorageKey(state), JSON.stringify(storageData));
    const params = this.buildSearchParams({
      codeChallenge,
      state,
      email: login.type === "sso" ? login.email : void 0,
      idp,
      locale: login.locale,
      type: login.type
    });
    return { url: `${this.config.authUrl}/${path}?${params}`, state };
  }
  /**
   * Performs a 3rd party login (second and final part).
   * 
   * This operation happens in two parts, this is the last one and it returns a SessionPayload.
   * This should be called by whatever is in `config.redirectUrl`. The only parameter it receives must be the query string in the url.
   * 
   * If the account is new and PENDING, another service will be called to finish the account creation. If the account creation cannot be
   * completed, it will not fail. Instead, it will try again on the next login while the user has some reduced permissions.
   * 
   * @throws
   * - {@link AuthenticationError}: if something goes wrong.
   * 
   * @param queryString 
   * @returns the session payload, which may be used to create a Session object.
   */
  async completeThirdPartyLogin(queryString) {
    const queryObject = queryStringToObject(queryString);
    if (queryObject.error) {
      throw new AuthenticationError(`${queryObject.error}. ${decodeURIComponent(queryObject.error_description)}.`);
    }
    const { code, state } = queryObject;
    const storageKey = buildStorageKey(state);
    const fromStorage = this.config.storage.getItem(storageKey);
    const { codeVerifier, tenant, data, provider } = fromStorage ? JSON.parse(fromStorage) : {};
    this.config.storage.removeItem(storageKey);
    if (!codeVerifier || !tenant)
      throw new AuthenticationError("Not enough data to perform 3rd party login.");
    const sessionData = await this.tokenClient.authenticate("authorizationCode", { code, tenant, codeVerifier });
    const hasAccountBeenCreated = await this.createAccount(sessionData.access_token);
    const finalSessionData = hasAccountBeenCreated ? await this.refreshToken(sessionData) : sessionData;
    return { sessionData: __spreadProps$2(__spreadValues$2({}, finalSessionData), { provider }), data };
  }
  /**
   * List all accounts available for the user of the access token passed as parameter.
   * 
   * @throws
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param accessToken 
   * @returns the accounts
   */
  listAccounts(accessToken) {
    const url = `${this.config.accountUrl}/v1/users/accounts`;
    try {
      return this.authFetch(url, accessToken);
    } catch (error) {
      if (error instanceof NetworkError && [401, 403].includes(error.response.status)) {
        throw new AuthenticationError(`You are not allowed to list accounts. Check the error below for more details:
${error.message}`);
      }
      throw error;
    }
  }
  /**
   * Switches the active account for the user of the access token passed as parameter.
   * 
   * @throws
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param accountId the id of the account to switch to.
   * @param accessToken 
   * @returns the tokens linking to the new accont.
   */
  switchAccount(accountId, accessToken) {
    const url = `${this.config.accountUrl}/v1/authentication/switch-account`;
    try {
      return this.authFetch(url, accessToken, { method: "post", body: JSON.stringify({ accountId }) });
    } catch (error) {
      if (error instanceof NetworkError && [401, 403].includes(error.response.status)) {
        throw new AuthenticationError(
          `You are not allowed to switch to this account. Check the error below for more details:
${error.message}`
        );
      }
      throw error;
    }
  }
}

var __defProp$5 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField$5 = (obj, key, value) => {
  __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
async function buildError(method, tenant, response) {
  var _a;
  if (response.status === 404)
    return new InvalidTenantError(tenant);
  let errorMessage = void 0;
  try {
    const errorData = await response.json();
    errorMessage = errorData.error_description;
    errorMessage || (errorMessage = await response.text());
  } catch (e) {
  }
  return [400, 401, 403].includes(response.status) ? new InvalidCredentialsError(response.status, method, tenant, errorMessage) : new AuthenticationError((_a = errorMessage != null ? errorMessage : response.statusText) != null ? _a : "Unknown error.");
}
const credentialMethodToGrantType = {
  password: "password",
  client: "client_credentials",
  refreshToken: "refresh_token",
  authorizationCode: "authorization_code",
  device: "urn:ietf:params:oauth:grant-type:device_code"
};
class TokenClient {
  constructor(config) {
    __publicField$5(this, "config");
    this.config = config;
  }
  /**
   * Authenticates using one of the authentication methods available.
   * 
   * This throws an AuthenticationError on errors:
   * - {@link InvalidTenantError}: if the tenant or the url is invalid (on 404).
   * - {@link InvalidCredentialsError}: if the credentials are invalid.
   * - Plain {@link AuthenticationError}: if the error is unknown.
   * 
   * @param url the url to the authentication API.
   * @param method the authentication method.
   * @param credentials the credentials for signing in.
   * @returns the session data. You can use it to create an instance of Session.
   * @throws AuthenticationError
   */
  async authenticate(method, _a) {
    var _b = _a, { tenant = this.config.defaultTenant, clientId = this.config.clientId } = _b, credentials = __objRest(_b, ["tenant", "clientId"]);
    const encoded = lodash.map(
      __spreadProps$1(__spreadValues$1({}, credentials), { clientId, grantType: credentialMethodToGrantType[method], redirectUri: this.config.redirectUrl }),
      (value, key) => `${lodash.snakeCase(key)}=${encodeURIComponent(`${value}`)}`
    ).join("&");
    const url = `${this.config.authUrl}/${encodeURIComponent(tenant)}/oidc/oauth/token`;
    this.config.logger.log(`Authenticating. Method: ${method}. Tenant: ${tenant}. ClientId: ${clientId}. Credential keys: ${Object.keys(credentials).join(", ")}. URL: ${url}.`);
    let response;
    try {
      response = await this.config.fetch(
        url,
        {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: encoded
        }
      );
    } catch (e) {
      this.config.logger.error("Connection Error. The request has not been sent due to a local connection error. The request may have been blocked or the user may be disconnected.");
      this.config.logger.error(e);
      console.error(e);
      throw new ConnectionError();
    }
    if (!response.ok) {
      const error = await buildError(method, tenant, response);
      this.config.logger.error("Authentication failed.", response.status, error);
      throw error;
    }
    this.config.logger.log("Authentication request succeeded. Status:", response.status);
    try {
      const sessionData = await response.json();
      if (sessionData.access_token === "PENDING") {
        this.config.logger.log("Authentication is pending.");
        throw new PendingAuthenticationError();
      }
      this.config.logger.log("Authentication succeeded.");
      return __spreadProps$1(__spreadValues$1({}, sessionData), { client_id: clientId, tenant, clientTimeMs: (/* @__PURE__ */ new Date()).getTime() });
    } catch (e) {
      const error = new AuthenticationError(
        "There was an error while deserializing the body of the authentication response."
      );
      this.config.logger.error(error, await response.text());
      throw error;
    }
  }
  /**
   * Logs out from Stk Iam.
   * @throws
   * - {@link LogoutError} if the logout fails. This error has the original response as one of its properties.
   * @param the session data to log out 
   */
  async logout({
    tenant,
    id_token
  }) {
    const logoutUrl = `${this.config.authUrl}/${tenant}/oidc/end_session`;
    const params = new URLSearchParams({
      id_token_hint: id_token,
      post_logout_redirect_uri: location.origin
    });
    this.config.logger.log("Logging out.", `Tenant: ${tenant}.`, `Url: ${logoutUrl}.`);
    try {
      const response = await this.config.fetch(logoutUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: params.toString()
      });
      if (response.ok) {
        this.config.logger.log("Logged out.");
      } else {
        this.config.logger.error("Failed to logout.", response.status);
        throw new LogoutError(response);
      }
    } catch (e) {
      this.config.logger.error("Connection error while logging out.", e);
      throw e;
    }
  }
  async getDeviceAuthUrl({ tenant = this.config.defaultTenant, clientId = this.config.clientId, provider }) {
    const deviceUrl = `${this.config.authUrl}/${encodeURIComponent(tenant)}/oidc/device_authorization`;
    try {
      const response = await (provider ? this.config.fetch(`${deviceUrl}?client_id=${clientId}&external-idp=${provider}`, { method: "GET" }) : this.config.fetch(deviceUrl, { method: "POST", body: new URLSearchParams({ client_id: clientId }) }));
      if (!response.ok) {
        let message = "";
        try {
          message = `Error status ${response.status}
${await response.text()}`;
        } catch (e) {
          message = `Unexpected server error: ${response.status}`;
        }
        throw new AuthenticationError(message);
      }
      return response.json();
    } catch (error) {
      const message = `Could not get URL for device authentication. Tenant: ${tenant}; clientId: ${clientId}, provider: ${provider}.
${error.message || `${error}`}`;
      this.config.logger.error(message);
      throw new AuthenticationError(message);
    }
  }
}

var __defProp$4 = Object.defineProperty;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$4 = (obj, key, value) => {
  __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class LinkedList {
  constructor(array) {
    __publicField$4(this, "length", 0);
    __publicField$4(this, "first");
    __publicField$4(this, "last");
    array == null ? void 0 : array.forEach((item) => this.push(item));
  }
  push(item) {
    const linked = { data: item };
    if (this.length) {
      linked.previous = this.last;
      this.last.next = linked;
      this.last = linked;
    } else {
      this.first = linked;
      this.last = linked;
    }
    this.length++;
  }
  unshift(item) {
    const linked = { data: item };
    if (this.length) {
      linked.next = this.first;
      this.first.previous = linked;
      this.first = linked;
    } else {
      this.first = linked;
      this.last = linked;
    }
    this.length++;
  }
  shift() {
    var _a;
    this.first = (_a = this.first) == null ? void 0 : _a.next;
    if (this.first)
      this.first.previous = void 0;
    else
      this.last = void 0;
    this.length--;
  }
  pop() {
    var _a;
    this.last = (_a = this.last) == null ? void 0 : _a.previous;
    if (this.last)
      this.last.next = void 0;
    else
      this.first = void 0;
    this.length--;
  }
  forEach(iteratee) {
    let i = 0;
    let current = this.first;
    while (current) {
      iteratee(current.data, i);
      i++;
      current = current.next;
    }
  }
  map(iteratee) {
    let i = 0;
    let current = this.first;
    let result = [];
    while (current) {
      result.push(iteratee(current.data, i));
      i++;
      current = current.next;
    }
    return result;
  }
  toArray() {
    let current = this.first;
    const result = [];
    while (current) {
      result.push(current.data);
      current = current.next;
    }
    return result;
  }
  clear() {
    this.first = void 0;
    this.last = void 0;
    this.length = 0;
  }
}

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key2, value) => key2 in obj ? __defProp$3(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField$3 = (obj, key2, value) => {
  __defNormalProp$3(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
const key = "auth-logs";
const maxEntries = 1e3;
class Logger {
  constructor(storage) {
    __publicField$3(this, "entries", new LinkedList());
    __publicField$3(this, "persistenceIntervalMS", 6e4);
    __publicField$3(this, "persistOnError", true);
    __publicField$3(this, "storage");
    __publicField$3(this, "persistenceTimeout");
    this.storage = storage;
  }
  createLog(level, message) {
    if (this.entries.length >= maxEntries)
      this.entries.shift();
    this.entries.push({
      id: Math.random() + (/* @__PURE__ */ new Date()).getTime(),
      level,
      message,
      time: /* @__PURE__ */ new Date()
    });
    if (!this.persistenceTimeout) {
      try {
        this.persistenceTimeout = window.setTimeout(() => this.persist(), this.persistenceIntervalMS);
      } catch (e) {
      }
    }
  }
  merge(entriesA, entriesB) {
    return lodash.sortBy(lodash.uniqBy([...entriesA, ...entriesB], "id"), "time");
  }
  loadEntriesFromStorage() {
    try {
      const fromStorage = this.storage.getItem(key);
      const parsed = fromStorage ? JSON.parse(fromStorage) : void 0;
      return parsed.map((p) => ({ id: p.id, time: new Date(p.time), level: p.level, message: [p.message] }));
    } catch (e) {
      return [];
    }
  }
  log(...args) {
    this.createLog("info", args);
  }
  warn(...args) {
    this.createLog("warning", args);
  }
  error(...args) {
    this.createLog("error", args);
    if (this.persistOnError)
      this.persist();
  }
  getEntries() {
    return lodash.cloneDeep(this.entries);
  }
  logToConsole() {
    let lastDate = /* @__PURE__ */ new Date();
    this.entries.forEach((e) => {
      if (e.time.toLocaleDateString() !== (lastDate == null ? void 0 : lastDate.toLocaleDateString())) {
        console.log("==================================");
        console.log(e.time.toLocaleDateString());
        console.log("==================================");
        lastDate = e.time;
      }
      console[e.level === "warning" ? "warn" : e.level](`${e.time.toLocaleTimeString()} [${e.level.toUpperCase()}]:`, ...e.message);
    });
  }
  toString() {
    const lines = [];
    let lastDate = /* @__PURE__ */ new Date();
    this.entries.forEach((e) => {
      if (e.time.toLocaleDateString() !== (lastDate == null ? void 0 : lastDate.toLocaleDateString())) {
        lines.push("==================================");
        lines.push(e.time.toLocaleDateString());
        lines.push("==================================");
        lastDate = e.time;
      }
      lines.push(`${e.time.toLocaleTimeString()} [${e.level.toUpperCase()}]: ${e.message.join(" ")}`);
    });
    return lines.join("\n");
  }
  load() {
    const fromStorage = this.loadEntriesFromStorage();
    this.entries = new LinkedList(fromStorage);
  }
  persist() {
    try {
      if (this.persistenceTimeout) {
        window.clearTimeout(this.persistenceTimeout);
        this.persistenceTimeout = void 0;
      }
      const fromStorage = this.loadEntriesFromStorage();
      const toPersist = this.merge(fromStorage, this.entries.toArray());
      this.storage.setItem(
        key,
        JSON.stringify(toPersist.map((e) => ({ time: e.time.toISOString(), level: e.level, message: e.message.join(" ") })))
      );
    } catch (e) {
    }
  }
  copy() {
    try {
      navigator.clipboard.writeText(this.toString());
    } catch (e) {
    }
  }
  download() {
    try {
      const element = document.createElement("a");
      element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(this.toString()));
      element.setAttribute("download", "authentication-log.txt");
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    } catch (e) {
    }
  }
  clear() {
    this.entries.clear();
    try {
      this.storage.removeItem(key);
    } catch (e) {
    }
  }
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MemoryStorage {
  constructor() {
    __publicField$2(this, "map", /* @__PURE__ */ new Map());
    __publicField$2(this, "length", 0);
  }
  clear() {
    this.map.clear();
    this.length = 0;
  }
  getItem(key) {
    var _a;
    return (_a = this.map.get(key)) != null ? _a : null;
  }
  key(index) {
    var _a;
    return (_a = Array.from(this.map.keys())[index]) != null ? _a : null;
  }
  removeItem(key) {
    this.map.delete(key);
    this.length = this.map.size;
  }
  setItem(key, value) {
    this.map.set(key, value);
    this.length = this.map.size;
  }
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ThirdPartyObservable {
  constructor() {
    __publicField$1(this, "listeners", {
      error: [],
      redirect: [],
      success: [],
      url: []
    });
    __publicField$1(this, "events", {
      error: [],
      redirect: [],
      success: [],
      url: []
    });
  }
  /**
   * Registers a listener for whenever an error occurs during login.
   * The original error object is passed as a parameter to the listener.
   * @param listener the lister to register.
   * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
   */
  onError(listener, runPreviousEvents = true) {
    if (runPreviousEvents)
      this.events.error.forEach((params) => listener(...params));
    this.listeners.error.push(listener);
    return this;
  }
  /**
   * Register a listener to run when the external login redirects the user back to the application.
   * @param listener the lister to register.
   * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
   */
  onRedirect(listener, runPreviousEvents = true) {
    if (runPreviousEvents)
      this.events.redirect.forEach((params) => listener(...params));
    this.listeners.redirect.push(listener);
    return this;
  }
  /**
   * Register a listener to run when the login succeeds and a session is created.
   * The new session is passed as a parameter to the listener.
   * If the data parameter was passed to the `startThirdPartyLogin` method, it is provided here as the second parameter.
   * @param listener the lister to register.
   * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
   */
  onSuccess(listener, runPreviousEvents = true) {
    if (runPreviousEvents)
      this.events.success.forEach((params) => listener(...params));
    this.listeners.success.push(listener);
    return this;
  }
  /**
   * Register a listener to run when the url for the external login is obtained.
   * The url is passed as a parameter to the listener.
   * @param listener the lister to register.
   * @param runPreviousEvents set to false if you don't want the listener to run for the events triggered before it was attached.
   */
  onUrl(listener, runPreviousEvents = true) {
    if (runPreviousEvents)
      this.events.url.forEach((params) => listener(...params));
    this.listeners.url.push(listener);
    return this;
  }
  /**
   * Triggers a login event.
   * @param event the event to trigger.
   * @param args the arguments expected by the event.
   */
  trigger(event, ...args) {
    this.listeners[event].forEach((l) => l(...args));
    this.events[event].push(args);
  }
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class AuthManager {
  constructor(config) {
    __publicField(this, "config");
    __publicField(this, "tokenClient");
    __publicField(this, "thirdPartyClient");
    __publicField(this, "thirdPartyLoginAttempts", /* @__PURE__ */ new Map());
    var _a, _b, _c, _d, _e, _f;
    const storage = (_a = config.storage) != null ? _a : new MemoryStorage();
    this.config = __spreadProps(__spreadValues({}, config), {
      fetch: (_b = config.fetch) != null ? _b : (...args) => window.fetch.apply(window, args),
      storage,
      retry: (_c = config.retry) != null ? _c : 1,
      retryDelay: (_d = config.retryDelay) != null ? _d : 500,
      sessionPersistence: (_e = config.sessionPersistence) != null ? _e : null,
      logger: (_f = config.logger) != null ? _f : new Logger(storage)
    });
    try {
      window.authenticationLogger = this.config.logger;
    } catch (e) {
    }
    if (this.config.logger instanceof Logger)
      this.config.logger.load();
    if (!this.config.fetch) {
      throw new Error(
        "This platform doesn't have a global implementation of the fetch function. Please, provide an implementation in you configuration."
      );
    }
    this.tokenClient = new TokenClient(this.config);
    this.thirdPartyClient = new ThirdPartyClient(this.config, this.tokenClient);
  }
  /**
   * Authenticates using one of the authentication methods available.
   * 
   * @throws
   * - {@link InvalidTenantError}: if the tenant or the url is invalid (on 404).
   * - {@link InvalidCredentialsError}: if the credentials are invalid.
   * - Plain {@link AuthenticationError}: if the error is unknown.
   * 
   * @param url the url to the authentication API.
   * @param method the authentication method.
   * @param credentials the credentials for signing in.
   * @returns the session.
   */
  async startSession(method, credentials) {
    const sessionData = await this.tokenClient.authenticate(method, credentials);
    return new Session(sessionData, this.config, this.tokenClient);
  }
  /**
   * Restores a serialized session using `config.sessionPersistence.load`. If there's no session persisted or the persisted session is
   * expired, undefined is returned.
   * 
   * @returns the restored session.
   */
  async restoreSession() {
    var _a;
    try {
      this.config.logger.log("Restoring session.");
      const restored = await ((_a = this.config.sessionPersistence) == null ? void 0 : _a.load());
      const session = restored ? Session.fromSerializedSession(restored, this.config, this.tokenClient) : void 0;
      if (session && !session.isExpired()) {
        this.config.logger.log("Session restored.");
        return session;
      } else if (!session) {
        this.config.logger.warn("No Session found.");
      } else {
        this.config.logger.warn("Session was restored, but it was expired.");
      }
    } catch (error) {
      this.config.logger.error("Could not restore Session.", error);
      console.error(error);
    }
  }
  async startObservableThirdPartyLoginAsync(login, observable, data) {
    try {
      const { url, state } = await this.thirdPartyClient.getThirdPartyLoginUrlAndState(login, data);
      this.thirdPartyLoginAttempts.set(state, observable);
      observable.onSuccess(() => this.thirdPartyLoginAttempts.delete(state));
      observable.trigger("url", url);
    } catch (error) {
      observable.trigger("error", error);
    }
  }
  /**
   * Performs a 3rd party login (first part).
   * 
   * This operation happens in two parts, this is the first one and it returns the url to perform the 3rd party login.
   * 
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * 
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   * 
   * @throws
   * - {@link InvalidSSOError}: if the email doesn't correspond to any SSO registered.
   * - {@link AuthMethodUnavailable}: if the 3rd party login is temporally unavailable.
   * 
   * @param login parameters to the 3rd party login.
   * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
   * @returns the url to perform the 3rd party login.
   */
  async startThirdPartyLogin(login, ...data) {
    const { url } = await this.thirdPartyClient.getThirdPartyLoginUrlAndState(login, data[0]);
    return url;
  }
  /**
   * Just like {@link startThirdPartyLogin}. But instead of returning the URL, it returns an observable object that can listen to any
   * login event. A login event is triggered on every step: url generated, redirected to application, success and error.
   * 
   * @param login parameters to the 3rd party login.
   * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
   * @returns an observable object that will update whenever a login step succeeds or fails.
   */
  startObservableThirdPartyLogin(login, ...data) {
    const observable = new ThirdPartyObservable();
    this.startObservableThirdPartyLoginAsync(login, observable, data[0]);
    return observable;
  }
  async completeObservableThirdPartyLoginAsync(queryString) {
    const { state } = queryStringToObject(queryString);
    const observable = this.thirdPartyLoginAttempts.get(state);
    if (!observable)
      throw new Error("Login attempt not found. This is a bug, please contact the team.");
    observable.trigger("redirect");
    try {
      const { sessionData, data } = await this.thirdPartyClient.completeThirdPartyLogin(queryString);
      const session = new Session(sessionData, this.config, this.tokenClient);
      observable.trigger("success", session, data);
    } catch (error) {
      observable.trigger("error", error);
    }
  }
  /**
   * Performs a 3rd party login (second and final part).
   * 
   * This operation happens in two parts, this is the last one and it returns a Session.
   * This should be called by whatever is in `config.redirectUrl`. The only parameter it receives must be the query string in the url.
   * 
   * @throws
   * - {@link AuthenticationError}: if something goes wrong.
   * 
   * @param queryString 
   * @returns an object containing the session and the data object passed to the `startThirdPartyLogin` method (if any).
   */
  async completeThirdPartyLogin(queryString) {
    const { sessionData, data } = await this.thirdPartyClient.completeThirdPartyLogin(queryString);
    const session = new Session(sessionData, this.config, this.tokenClient);
    return { session, data };
  }
  /**
   * Performs a 3rd party login (first part) using the given tenant
   * 
   * This operation happens in two parts, this is the first one and it returns the url to perform the 3rd party login.
   * This function does not use or depend on the user email, instead it will use the given tenant.
   * 
   * After login in the 3rd party site, the user will be redirected to the url informed in `config.redirectUrl`.
   * 
   * When the user is at `redirectUrl`, the method `completeThirdPartyLogin` should be called with the query string in the url.
   *
   * @param login parameters to the 3rd party login.
   * @param tenant parameters the tenant to mount the url.
   * @param data the extra data you want to pass from the 1st phase of the login to the end phase of the login.
   * @returns the url to perform the 3rd party login.
   */
  async getThirdPartyLoginFromTenant(login, tenant, ...data) {
    const { url } = await this.thirdPartyClient.getThirdPartyLoginFromTenant(login, tenant, data[0]);
    return url;
  }
  /**
   * Just like {@link completeThirdPartyLogin}. But instead of returning a Session, it completes the login for an existing
   * {@link ThirdPartyObservable} instantiated by the function {@link startObservableThirdPartyLogin}.
   * 
   * @param queryString.
   */
  completeObservableThirdPartyLogin(queryString) {
    this.completeObservableThirdPartyLoginAsync(queryString);
  }
  /**
   * List all accounts available for the user of the session passed as parameter.
   * 
   * @throws
   * - {@link SessionExpiredError}: if the session passed as parameter is expired.
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param session 
   * @returns the accounts
   */
  async listAccounts(session) {
    if (session.isExpired())
      throw new SessionExpiredError();
    const token = await session.getToken();
    return this.thirdPartyClient.listAccounts(token);
  }
  /**
   * Switches the active account for the user of the session passed as parameter.
   * 
   * @throws
   * - {@link SessionExpiredError}: if the session passed as parameter is expired.
   * - {@link AuthenticationError}: if the operation is not allowed.
   * 
   * @param accountId the id of the account to switch to.
   * @param accessToken 
   * @returns the tokens linking to the new account.
   */
  async switchAccount(accountId, session) {
    if (session.isExpired())
      throw new SessionExpiredError();
    const token = await session.getToken();
    const sessionData = await this.thirdPartyClient.switchAccount(accountId, token);
    session.updateSessionData(sessionData);
  }
  /**
   * Performs a device login using the given login data.
   * 
   * Use the methods `onUrl`, `onSuccess` and `onError` on the object returned to respond to the authentication events.
   *
   * @param loginData parameters to the device login.
   * @returns an object where you can attach listeners to login events.
   */
  startDeviceLogin(loginData) {
    const observable = new ThirdPartyObservable();
    const start = async () => {
      try {
        const { tenant } = !loginData.tenant && loginData.email ? await this.thirdPartyClient.findAuthDataByEmail(loginData.email) : { tenant: loginData.tenant || this.thirdPartyClient.config.defaultTenant };
        const authData = await this.tokenClient.getDeviceAuthUrl(__spreadProps(__spreadValues({}, loginData), { tenant }));
        observable.trigger("url", authData.verification_uri_complete);
        const expiration = (/* @__PURE__ */ new Date()).getTime() + authData.expires_in * 1e3;
        const checkAuth = () => {
          setTimeout(async () => {
            try {
              const sessionData = await this.tokenClient.authenticate(
                "device",
                { device_code: authData.device_code, clientId: loginData.clientId, tenant }
              );
              observable.trigger("success", new Session(sessionData, this.config, this.tokenClient), void 0);
            } catch (error) {
              if ((/* @__PURE__ */ new Date()).getTime() > expiration) {
                const error2 = new AuthenticationTimeout();
                this.config.logger.error(error2.message);
                observable.trigger("error", error2);
              } else {
                checkAuth();
              }
            }
          }, authData.interval * 1e3);
        };
        checkAuth();
      } catch (error) {
        observable.trigger("error", error);
      }
    };
    start();
    return observable;
  }
}

exports.AuthManager = AuthManager;
exports.AuthMethodUnavailable = AuthMethodUnavailable;
exports.AuthenticationError = AuthenticationError;
exports.AuthenticationTimeout = AuthenticationTimeout;
exports.ConnectionError = ConnectionError;
exports.InterceptorAuth = InterceptorAuth;
exports.InvalidCredentialsError = InvalidCredentialsError;
exports.InvalidProvider = InvalidProvider;
exports.InvalidSSOError = InvalidSSOError;
exports.InvalidTenantError = InvalidTenantError;
exports.LinkedList = LinkedList;
exports.LogoutError = LogoutError;
exports.MalFormedAccessToken = MalFormedAccessToken;
exports.NetworkError = NetworkError;
exports.PendingAuthenticationError = PendingAuthenticationError;
exports.Session = Session;
exports.SessionExpiredError = SessionExpiredError;
exports.ThirdPartyClient = ThirdPartyClient;
exports.ThirdPartyObservable = ThirdPartyObservable;
exports.TokenClient = TokenClient;
//# sourceMappingURL=index.js.map
