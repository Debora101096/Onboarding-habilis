export interface LinkedItem<T> {
  data: T,
  previous?: LinkedItem<T>,
  next?: LinkedItem<T>,
}

export class LinkedList<T> {
  length = 0
  private first: LinkedItem<T> | undefined
  private last: LinkedItem<T> | undefined

  constructor(array?: T[]) {
    array?.forEach(item => this.push(item))
  }

  push(item: T) {
    const linked: LinkedItem<T> = { data: item }
    if (this.length) {
      linked.previous = this.last
      this.last!.next = linked
      this.last = linked
    } else {
      this.first = linked
      this.last = linked
    }
    this.length++
  }

  unshift(item: T) {
    const linked: LinkedItem<T> = { data: item }
    if (this.length) {
      linked.next = this.first
      this.first!.previous = linked
      this.first = linked
    } else {
      this.first = linked
      this.last = linked
    }
    this.length++
  }

  shift() {
    this.first = this.first?.next
    if (this.first) this.first.previous = undefined
    else this.last = undefined
    this.length--
  }

  pop() {
    this.last = this.last?.previous
    if (this.last) this.last.next = undefined
    else this.first = undefined
    this.length--
  }

  forEach(iteratee: (item: T, index: number) => void) {
    let i = 0
    let current = this.first
    while (current) {
      iteratee(current.data, i)
      i++
      current = current.next
    }
  }

  map<U>(iteratee: (item: T, index: number) => U) {
    let i = 0
    let current = this.first
    let result: U[] = []
    while (current) {
      result.push(iteratee(current.data, i))
      i++
      current = current.next
    }
    return result
  }

  toArray() {
    let current = this.first
    const result: T[] = []
    while (current) {
      result.push(current.data)
      current = current.next
    }
    return result
  }

  clear() {
    this.first = undefined
    this.last = undefined
    this.length = 0
  }
}