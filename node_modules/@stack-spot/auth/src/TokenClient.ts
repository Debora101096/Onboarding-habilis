import { map, snakeCase } from 'lodash'
import { AuthenticationError, ConnectionError, InvalidCredentialsError, InvalidTenantError, LogoutError, PendingAuthenticationError } from './error'
import { AuthConfig, AuthenticationErrorPayload, CredentialMethod, CredentialOf, DeviceAuth, DeviceLoginData, SessionPayload } from './types'

async function buildError(method: CredentialMethod, tenant: string, response: Response): Promise<AuthenticationError> {
  if (response.status === 404) return new InvalidTenantError(tenant)
  let errorMessage: string | undefined = undefined
  try {
    const errorData = await response.json() as AuthenticationErrorPayload
    errorMessage = errorData.error_description
    errorMessage ||= await response.text()
  } catch { }
  return [400, 401, 403].includes(response.status)
    ? new InvalidCredentialsError(response.status, method, tenant, errorMessage)
    : new AuthenticationError(errorMessage ?? response.statusText ?? 'Unknown error.')
}

const credentialMethodToGrantType: Record<CredentialMethod, string> = {
  password: 'password',
  client: 'client_credentials',
  refreshToken: 'refresh_token',
  authorizationCode: 'authorization_code',
  device: 'urn:ietf:params:oauth:grant-type:device_code',
}

export class TokenClient {
  readonly config: Required<AuthConfig>

  constructor(config: Required<AuthConfig>) {
    this.config = config
  }

  /**
   * Authenticates using one of the authentication methods available.
   * 
   * This throws an AuthenticationError on errors:
   * - {@link InvalidTenantError}: if the tenant or the url is invalid (on 404).
   * - {@link InvalidCredentialsError}: if the credentials are invalid.
   * - Plain {@link AuthenticationError}: if the error is unknown.
   * 
   * @param url the url to the authentication API.
   * @param method the authentication method.
   * @param credentials the credentials for signing in.
   * @returns the session data. You can use it to create an instance of Session.
   * @throws AuthenticationError
   */
  async authenticate<T extends CredentialMethod>(
    method: T,
    { tenant = this.config.defaultTenant, clientId = this.config.clientId, ...credentials }: CredentialOf<T>,
  ): Promise<SessionPayload> {
    const encoded = map(
      { ...credentials, clientId, grantType: credentialMethodToGrantType[method], redirectUri: this.config.redirectUrl },
      (value, key) => `${snakeCase(key)}=${encodeURIComponent(`${value}`)}`,
    ).join('&')
    const url = `${this.config.authUrl}/${encodeURIComponent(tenant)}/oidc/oauth/token`
    this.config.logger.log(`Authenticating. Method: ${method}. Tenant: ${tenant}. ClientId: ${clientId}. Credential keys: ${Object.keys(credentials).join(', ')}. URL: ${url}.`)
    let response
    try {
      response = await this.config.fetch(
        url,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: encoded,
        },
      )
    } catch (e) {
      this.config.logger.error('Connection Error. The request has not been sent due to a local connection error. The request may have been blocked or the user may be disconnected.')
      this.config.logger.error(e)
      console.error(e)
      // By itself, fetch will only throw an error if there is a network-level issue (e.g., no internet connection, DNS failure, or the request is blocked by CORS).
      throw new ConnectionError()
    }

    if (!response.ok) {
      const error = await buildError(method, tenant, response)
      this.config.logger.error('Authentication failed.', response.status, error)
      throw error
    }

    this.config.logger.log('Authentication request succeeded. Status:', response.status)
    try {
      const sessionData = await response.json()
      if (sessionData.access_token === 'PENDING') {
        this.config.logger.log('Authentication is pending.')
        throw new PendingAuthenticationError()
      }
      this.config.logger.log('Authentication succeeded.')
      return { ...sessionData, client_id: clientId, tenant, clientTimeMs: new Date().getTime() }
    } catch {
      const error = new AuthenticationError(
        'There was an error while deserializing the body of the authentication response.'
      )
      this.config.logger.error(error, await response.text())
      throw error
    }
  }

  /**
   * Logs out from Stk Iam.
   * @throws
   * - {@link LogoutError} if the logout fails. This error has the original response as one of its properties.
   * @param the session data to log out 
   */
  async logout({
    tenant,
    id_token,
  }: Pick<SessionPayload, 'tenant' | 'id_token'>) {
    const logoutUrl = `${this.config.authUrl}/${tenant}/oidc/end_session`
    const params = new URLSearchParams({
      id_token_hint: id_token,
      post_logout_redirect_uri: location.origin
    })

    this.config.logger.log('Logging out.', `Tenant: ${tenant}.`, `Url: ${logoutUrl}.`)
    try {
      const response = await this.config.fetch(logoutUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: params.toString(),
      })
      if (response.ok) {
        this.config.logger.log('Logged out.')
      } else {
        this.config.logger.error('Failed to logout.', response.status)
        throw new LogoutError(response)
      }
    } catch (e) {
      this.config.logger.error('Connection error while logging out.', e)
      throw e
    }
  }

  async getDeviceAuthUrl(
    { tenant = this.config.defaultTenant, clientId = this.config.clientId, provider }: DeviceLoginData,
  ): Promise<DeviceAuth> {
    const deviceUrl = `${this.config.authUrl}/${encodeURIComponent(tenant)}/oidc/device_authorization`
    try {
      const response = await (provider
        ? this.config.fetch(`${deviceUrl}?client_id=${clientId}&external-idp=${provider}`, { method: 'GET' })
        : this.config.fetch(deviceUrl, { method: 'POST', body: new URLSearchParams({ client_id: clientId }) })
      )
      if (!response.ok) {
        let message = ''
        try {
          message = `Error status ${response.status}\n${await response.text()}`
        } catch {
          message = `Unexpected server error: ${response.status}`
        }
        throw new AuthenticationError(message)
      }
      return response.json()
    } catch (error: any) {
      const message = `Could not get URL for device authentication. Tenant: ${tenant}; clientId: ${clientId}, provider: ${provider}.\n${error.message || `${error}`}`
      this.config.logger.error(message)
      throw new AuthenticationError(message)
    }
  }
}
