import { omitBy } from 'lodash'
import { Session } from '../Session'
import { FetchRequest } from '../types'
import { Interceptor } from './InterceptorManager'

export class InterceptorAuth implements Interceptor {
  private session: Session

  constructor(session: Session) {
    this.session = session
  }

  /**
   * The Fetch API can receive headers as an object in the format `{ headerKey: headerValue }`, an array with key-value pairs
   * `[[headerKey, headerValue]]` or an instance of the class `Headers`. This function receives any type of headers and normalizes it into
   * an object in the format `{ headerKey: headerValue }`.
   * @param headers the headers to normalize.
   * @returns an object where each entry is composed by a header key and a header value.
   */
  private normalizeHeaders(headers?: HeadersInit): Record<string, string> | undefined {
    // we use a try-catch here to not break the application if running inside an environment that doesn't support the class `Headers`.
    try {
      if (headers instanceof Headers) {
        const record: Record<string, string> = {}
        headers.forEach((value, key) => record[key] = value)
        return record
      }
    } catch { /* empty */ }
    if (Array.isArray(headers)) {
      return headers.reduce<Record<string, string>>((result, [key, value]) => ({ ...result, [key]: value }), {})
    }
    return headers as Record<string, string>
  }

  /**
   * Intercepts the request to include the authentication token.
   * 
   * @param request the original request
   * @returns the request with the authentication header.
   */
  async interceptRequest(request: FetchRequest): Promise<FetchRequest> {
    const token = await this.session.getToken()
    const headers = omitBy(this.normalizeHeaders(request.init?.headers), (_, key) => key.toLowerCase() === 'authorization')
    const init = {
      ...request.init,
      headers: {
        ...headers,
        authorization: `Bearer ${token}`,
      },
    } as RequestInit
    return { url: request.url, init }
  }
}
