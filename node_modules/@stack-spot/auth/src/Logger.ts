import { cloneDeep, sortBy, uniqBy } from 'lodash'
import { LinkedList } from './LinkedList'
import { GenericLogger, GenericStorage } from './types'

const key = 'auth-logs'
const maxEntries = 1000

export interface LogEntry {
  id: number,
  time: Date,
  level: 'info' | 'warning' | 'error',
  message: any[],
}

export class Logger implements GenericLogger {
  protected entries: LinkedList<LogEntry> = new LinkedList()
  protected persistenceIntervalMS = 60000
  protected persistOnError = true
  protected readonly storage: GenericStorage
  private persistenceTimeout: number | undefined

  constructor(storage: GenericStorage) {
    this.storage = storage
  }

  private createLog(level: LogEntry['level'], message: any[]) {
    if (this.entries.length >= maxEntries) this.entries.shift()
    this.entries.push({
      id: Math.random() + new Date().getTime(),
      level,
      message,
      time: new Date(),
    })
    if (!this.persistenceTimeout) {
      try {
        this.persistenceTimeout = window.setTimeout(() => this.persist(), this.persistenceIntervalMS)
      } catch {}
    }
  }

  private merge(entriesA: LogEntry[], entriesB: LogEntry[]) {
    return sortBy(uniqBy([...entriesA, ...entriesB], 'id'), 'time')
  }

  private loadEntriesFromStorage(): LogEntry[] {
    try {
      const fromStorage = this.storage.getItem(key)
      const parsed: any[] = fromStorage ? JSON.parse(fromStorage) : undefined
      return parsed.map(p => ({ id: p.id, time: new Date(p.time), level: p.level, message: [p.message] }))
    } catch {
      return []
    }
  }

  log(...args: any[]) {
    this.createLog('info', args)
  }

  warn(...args: any[]) {
    this.createLog('warning', args)
  }

  error(...args: any[]) {
    this.createLog('error', args)
    if (this.persistOnError) this.persist()
  }

  getEntries() {
    return cloneDeep(this.entries)
  }

  logToConsole() {
    let lastDate: Date | undefined = new Date()
    this.entries.forEach((e) => {
      if (e.time.toLocaleDateString() !== lastDate?.toLocaleDateString()) {
        console.log('==================================')
        console.log(e.time.toLocaleDateString())
        console.log('==================================')
        lastDate = e.time
      }
      console[e.level === 'warning' ? 'warn' : e.level](`${e.time.toLocaleTimeString()} [${e.level.toUpperCase()}]:`, ...e.message)
    })
  }

  toString() {
    const lines: string[] = []
    let lastDate: Date | undefined = new Date()
    this.entries.forEach((e) => {
      if (e.time.toLocaleDateString() !== lastDate?.toLocaleDateString()) {
        lines.push('==================================')
        lines.push(e.time.toLocaleDateString())
        lines.push('==================================')
        lastDate = e.time
      }
      lines.push(`${e.time.toLocaleTimeString()} [${e.level.toUpperCase()}]: ${e.message.join(' ')}`)
    })
    return lines.join('\n')
  }

  load() {
    const fromStorage = this.loadEntriesFromStorage()
    this.entries = new LinkedList(fromStorage)
  }

  persist() {
    try {
      if (this.persistenceTimeout) {
        window.clearTimeout(this.persistenceTimeout)
        this.persistenceTimeout = undefined
      }
      const fromStorage = this.loadEntriesFromStorage()
      const toPersist = this.merge(fromStorage, this.entries.toArray())
      this.storage.setItem(
        key,
        JSON.stringify(toPersist.map(e => ({ time: e.time.toISOString(), level: e.level, message: e.message.join(' ') }))),
      )
    } catch {}
  }

  copy() {
    try {
      navigator.clipboard.writeText(this.toString())
    } catch {}
  }

  download() {
    try {
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(this.toString()))
      element.setAttribute('download', 'authentication-log.txt')
      element.style.display = 'none'
      document.body.appendChild(element)
      element.click()
      document.body.removeChild(element)
    } catch {}
  }

  clear() {
    this.entries.clear()
    try {
      this.storage.removeItem(key)
    } catch {}
  }
}
