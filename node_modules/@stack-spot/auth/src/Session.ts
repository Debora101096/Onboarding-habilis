import { decodeJwt, JWTPayload } from 'jose'
// don't remove the next ignore, it's  used by ts-docs.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { AuthenticationError, InvalidCredentialsError, InvalidTenantError, MalFormedAccessToken, SessionExpiredError } from './error'
import { InterceptorAuth } from './interceptors/InterceptorAuth'
import { Interceptor, InterceptorManager } from './interceptors/InterceptorManager'
import { InterceptorRetry } from './interceptors/InterceptorRetry'
import { TokenClient } from './TokenClient'
import { AccessTokenPayload, AuthConfig, GenericLogger, SessionPayload, SessionPersistence } from './types'
import { delay, secondsToMilliseconds } from './utils'

/**
 * If multiple instances of the application make a request at the same time and the token is expired, multiple requests to refresh the token
 * may be sent with the same refresh token. Only one of them will succeed and the user would be logged off once the remaining requests fail
 * because the refresh token would've been already used.
 * 
 * This is a super-rare scenario, so instead of synchronizing the request across multiple instances, which would make this class more
 * complex and introduce a breaking change, we're going to make the refresh token request anyway, not worrying if it will fail or not. If
 * it fails, we'll check if a refreshed session has been stored by another instance in the meantime. We'll check for a refreshed session
 * at most `refreshCheck.maxAttempts` times, with an interval of `refreshCheck.intervalMS`. If we find a refreshed session, we return it,
 * otherwise, we throw the original request error.
 */
const refreshCheck = {
  maxAttempts: 10,
  intervalMS: 500,
}

/**
 * The access-token expires after `X` amount of time. We can't make a request with an expired access-token. Let's say we start a request
 * at time `X - 10ms`, it might be that this request arrives at the server at time `Y`, where `Y > X`. For this reason, to be safe, we
 * don't refresh the token when it's expired, but, instead, when it's about to expire. This constant defines what `about` is. We refresh
 * a token if it's going to expire in the next `expiryTimeMarginMs` milliseconds.
 */
const expiryTimeMarginMs = 15000

export function jwtToAccessTokenPayload(token: string): AccessTokenPayload {
  try {
    // deepcode ignore JwtDecodeMethod: Only needed to access token data. This is still validated on the backend. 
    return decodeJwt(token)
  } catch (error) {
    throw new MalFormedAccessToken(token, error)
  }
}

function parseSerializedSession(serialized: string): { time: string, data: SessionPayload } {
  const [_, time, data] = serialized.match(/^(\d*);(.*)$/) ?? []
  const error = new Error(`Error while deserializing Session. Malformed string.\n${serialized}`)
  if (!time || !data) throw error
  try {
    return { time, data: JSON.parse(data) }
  } catch {
    throw error
  }
}

function isTokenExpired(tokenData: AccessTokenPayload, clientTimeMs: number | undefined, safetyMarginMs = 0) {
  if (!tokenData.exp || !tokenData.iat) return false
  const issued = secondsToMilliseconds(tokenData.iat)
  const expiration = secondsToMilliseconds(tokenData.exp)
  const duration = expiration - issued - safetyMarginMs
  return new Date().getTime() > (clientTimeMs || issued) + duration
}

export class Session {
  private data: SessionPayload = {} as unknown as SessionPayload // this is initialized in the constructor
  private accessTokenData: AccessTokenPayload = {}
  private refreshTokenData: JWTPayload = {}
  private currentRefresh: Promise<string> | undefined
  private readonly tokenClient: TokenClient
  private readonly persistence: SessionPersistence | null
  private readonly interceptor: InterceptorManager
  private lastPersisted: string
  private interceptorAuthId: number | undefined
  private interceptorRetryId: number | undefined
  private logger: GenericLogger

  constructor(data: SessionPayload, config: Required<AuthConfig>, tokenClient: TokenClient, lastPersisted = '') {
    this.logger = config.logger
    this.setSessionData(data)
    this.tokenClient = tokenClient
    this.persistence = config.sessionPersistence
    this.lastPersisted = lastPersisted
    if (!lastPersisted) this.persist()
    this.interceptor = new InterceptorManager(config.fetch)
    this.setInterceptors(config)
  }

  private setSessionData(data: SessionPayload) {
    this.data = data
    this.accessTokenData = jwtToAccessTokenPayload(data.access_token)
    this.refreshTokenData = jwtToAccessTokenPayload(data.refresh_token)
    this.serialize()
  }

  private setInterceptors(config: Required<AuthConfig>) {
    const interceptorAuth = new InterceptorAuth(this)
    const interceptorRetry = new InterceptorRetry(config.retry, config.retryDelay, config.fetch)
    this.interceptorAuthId = this.interceptor.addInterceptor(interceptorAuth)
    this.interceptorRetryId = this.interceptor.addInterceptor(interceptorRetry)
  }

  /**
   * Updates values in the session data. Values not available in the object passed as parameter will keep their previous values.
   * Useful for changing tokens with arbitrary values.
   * @param data the properties to update
   */
  updateSessionData(data: Partial<SessionPayload>) {
    this.setSessionData({ ...this.data, ...data })
    this.persist()
  }

  /**
   * Restores a serialized session created with `Session#serialize()`.
   * 
   * It's a good idea to call `Session#isExpired()` right after this to check the session validity.
   * 
   * @param serialized the serialized session as a string.
   * @param tokenClient a TokenClient.
   * @returns the restored session.
   */
  static fromSerializedSession(serialized: string, config: Required<AuthConfig>, tokenClient: TokenClient) {
    const { time, data } = parseSerializedSession(serialized)
    return new Session(data, config, tokenClient, time)
  }

  private async loadPersisted() {
    const persisted = await this.persistence?.load()
    if (!persisted || persisted.startsWith(`${this.lastPersisted};`)) return
    try {
      const { data } = parseSerializedSession(persisted)
      this.logger.log('Loaded session from storage.')
      this.setSessionData(data)
    } catch (error) {
      this.logger.error('Unable to load session from storage.', error)
      // eslint-disable-next-line no-console
      console.error('Error while recovering session.', error)
    }
  }

  private async persist() {
    if (!this.persistence) return
    this.lastPersisted = `${Date.now()}`
    await this.persistence.save(this.serialize())
    this.logger.log('Session persisted in storage.')
  }

  private async refreshSession(): Promise<string> {
    try {
      const data = await this.tokenClient.authenticate(
        'refreshToken',
        {
          refreshToken: this.data.refresh_token,
          clientId: this.data.client_id,
          tenant: this.data.tenant,
        },
      )
      this.setSessionData(data)
      await this.persist()
      return this.data.access_token
    } catch (error: any) {
      if (!(error instanceof AuthenticationError)) {
        console.error('Unexpected error while refreshing token:', error.message || `${error}`)
      }
      if (error instanceof InvalidCredentialsError) {
        let attempts = refreshCheck.maxAttempts
        while (attempts && this.shouldRefreshToken()) {
          this.logger.warn(`Failed to refresh token. ${attempts} attempts left.`)
          await delay(refreshCheck.intervalMS)
          await this.loadPersisted()
          attempts--
        }
        if (this.shouldRefreshToken()) throw error
        else return this.data.access_token
      } else {
        throw error
      }
    }
  }

  private shouldRefreshToken() {
    return isTokenExpired(this.accessTokenData, this.data.clientTimeMs, expiryTimeMarginMs)
  }

  /**
   * Gets the current access token.
   * 
   * - If the access token is set to expire within the next 15 seconds, it refreshes it before returning (async).
   * - If the refresh token is also invalid, then this session is no longer valid and a {@link SessionExpiredError} is thrown.
   * - If an error occurs while refreshing, this error is thrown.
   * 
   * Important: this function never produces multiple concurrent calls to the authentication API. Whenever multiple calls are made, they
   * use the same ongoing request. In summary, there's no need to worry about multiple requests triggering this at the same time.
   * 
   * @throws
   * - {@link SessionExpiredError} when the both the access token and refresh token are expired.
   * - {@link AuthenticationError}, {@link InvalidCredentialsError}, {@link InvalidTenantError} when the refresh fails.
   * 
   * @returns a promise that resolves to the access token.
   */
  async getToken(): Promise<string> {
    await this.loadPersisted()
    if (this.currentRefresh) return this.currentRefresh
    if (this.isExpired()) {
      this.logger.warn('Session is expired. A new login is required.')
      throw new SessionExpiredError()
    }
    if (this.shouldRefreshToken()) {
      this.logger.log('Session must be refreshed (refresh token).')
      this.currentRefresh = this.refreshSession()
      await this.currentRefresh
      this.currentRefresh = undefined
    }
    return this.data.access_token
  }

  /**
   * A Session is expired if its refresh token is expired.
   * @returns true if the session is expired, false otherwise.
   */
  isExpired(): boolean {
    return isTokenExpired(this.refreshTokenData, this.data.clientTimeMs)
  }

  /**
   * Gets the data contained in the access token.
   * Useful for getting user information like name and email.
   * @returns the access token data.
   */
  getTokenData(): AccessTokenPayload {
    return this.accessTokenData
  }

  /**
   * Gets the raw data used to build the session.
   * @returns the session data.
   */
  getSessionData(): SessionPayload {
    return this.data
  }

  /**
   * Serializes this session.
   * 
   * The session can be restored with Session.fromSerializedSession(string).
   * 
   * Format: {unix time in ms when the session was created or restored};{session data ({@link SessionPayload}) in json form}
   * 
   * @returns the serialized session.
   */
  serialize(): string {
    return `${this.lastPersisted};${JSON.stringify(this.data)}`
  }

  /**
   * A custom implementation of {@link global.fetch} including authentication and retrials on errors. This will take care of refreshing the
   * token when necessary.
   * 
   * @throws
   * - {@link SessionExpiredError} when both the access token and refresh token are expired.
   * - {@link AuthenticationError}, {@link InvalidCredentialsError}, {@link InvalidTenantError} when the refresh fails.
   * 
   * @param input the URL to the request.
   * @param init the request options.
   * @returns the response.
   */
  fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
    return this.interceptor.fetch(input, init)
  }

   /**
   * Adds an interceptor
   * 
   * @param interceptor - The interceptor to add.
   * @returns The ID of the added interceptor.
   */
  addInterceptor(interceptor: Interceptor) {
    return this.interceptor.addInterceptor(interceptor)
  }
  
  /**
   * Removes an interceptor
   * 
   * @param id - The ID of the interceptor to remove.
   */
  removeInterceptor(id: number) {
    if (id !== this.interceptorAuthId && id !== this.interceptorRetryId) {
      return this.interceptor.removeInterceptor(id)
    }
  }

  /**
   * Logs out from IAM.
   * @throws
   * - {@link LogoutError} if the logout fails. This error has the original response as one of its properties.
   */
  logout() {
    return this.tokenClient.logout(this.data)
  }
}
