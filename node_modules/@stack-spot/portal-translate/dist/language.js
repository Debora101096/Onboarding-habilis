import { useEffect, useState } from 'react';
import { MissingDefaultLanguageTranslation, TranslationConfigError } from './error.js';
export const ptEn = ['pt', 'en'];
let supported = ptEn;
const key = 'language';
let defaultLanguage = 'en';
const listeners = [];
const configChangeListeners = [];
let eventsRegistered;
/**
 * Retrieves the current language. Will be the navigator language if the user didn't change this setting.
 *
 * If you want to listen to changes on the language, use `onLanguageChange`.
 *
 * @param allowed a list of languages allowed to be returned. If not provided, the list of supported languages is used.
 * @returns the current language.
 */
export function getLanguage(allowed = supported) {
    const language = getLanguageFromCookie();
    if (allowed.includes(language))
        return language;
    const navigatorLanguage = navigator.language.split('-')[0];
    if (allowed.includes(navigatorLanguage))
        return navigatorLanguage;
    return allowed.includes(defaultLanguage) ? defaultLanguage : allowed[0];
}
/**
 * Changes the current language.
 *
 * Once the language is changed, all registered listeners are run. To register a listener, use `onLanguageChange`.
 *
 * @param language the new language. Must be a supported language. Call `setupTranslation` to change the supported languages.
 * @param setCookie whether or not to set the language cookie (true by default).
 * @param domain the domain to set the cookie, will be ".stackspot.com" by default.
 */
export function setLanguage(language, setCookie = true, domain = '.stackspot.com') {
    if (!supported.includes(language)) {
        // eslint-disable-next-line no-console
        return console.warn('Language', language, 'not applied, because it is not supported. Supported languages are:', supported.join(', '));
    }
    if (setCookie)
        document.cookie = `${key}=${language};path=/${location.host.endsWith(domain) ? `;domain=${domain}` : ''}`;
    listeners.forEach(l => l(language));
}
function getLanguageFromCookie() {
    return ((document.cookie.match(new RegExp(`${key}=([^;]+)`)) ?? [])[1]);
}
/**
 * Loads the current language from the cookies. If no language has been set before, "en" is loaded.
 */
export function loadLanguage() {
    const language = getLanguage();
    setLanguage(language);
    if (eventsRegistered)
        return;
    // if there's support for the cookieStore, change the theme whenever the cookie is changed.
    if ('cookieStore' in window) {
        // @ts-ignore cookieStore is not yet available on Safari and Firefox, this is why TS doesn't recognize it
        cookieStore.addEventListener('change', ({ changed }) => {
            for (const { name, value } of changed) {
                if (name === 'language' && supported.includes(value))
                    listeners.forEach(l => l(value));
            }
        });
    }
    // otherwise, change the theme when the tab/window is refocused.
    else {
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible')
                loadLanguage();
        });
    }
    eventsRegistered = true;
}
/**
 * Registers a listener for when the language changes.
 * @param listener a function to be called whenever the language changes.
 * @returns a function that, when called, removes the listener.
 */
export function onLanguageChange(listener) {
    listeners.push(listener);
    return () => {
        const index = listeners.indexOf(listener);
        if (index !== -1)
            listeners.splice(index, 1);
    };
}
/**
 * Registers a listener for when the configuration changes.
 * @param listener a function to be called whenever the configuration changes.
 * @returns a function that, when called, removes the listener.
 */
export function onTranslationSetup(listener) {
    configChangeListeners.push(listener);
    return () => {
        const index = configChangeListeners.indexOf(listener);
        if (index !== -1)
            configChangeListeners.splice(index, 1);
    };
}
/**
 * Gets the correct version of a dictionary depending on the language passed as parameter.
 * @param dictionary
 * @param language
 * @returns the english or portuguese version of the dictionary, depending on the value of `language`.
 */
export function translate(dictionary, language = getLanguage()) {
    return dictionary[language in dictionary ? language : defaultLanguage];
}
/**
 * A React Hook for getting the correct version of a dictionary depending on the current language.
 *
 * The value returned by this is updated whenever the language changes.
 *
 * If there are no translations for the current language, this fallbacks to the default language. To change the default language, call
 * `setupTranslation`.
 *
 * @throws {@link MissingDefaultLanguageTranslation} if the dictionary doesn't contain the translation for the default language.
 * @param dictionary
 * @returns the translated version of the dictionary, depending on the current language.
 */
export function useTranslate(dictionary) {
    const language = useLanguage();
    if (!(defaultLanguage in dictionary)) {
        throw new MissingDefaultLanguageTranslation(defaultLanguage);
    }
    return translate(dictionary, language);
}
/**
 * A React Hook for getting the current language.
 *
 * The value returned by this is updated whenever the language changes.
 *
 * @param allowed a list of languages allowed to be returned. If not provided, the list of supported languages is used.
 * @returns the current language.
 */
export function useLanguage(allowed) {
    const [language, setLanguage] = useState(getLanguage(allowed));
    useEffect(() => onLanguageChange(l => setLanguage(l)), []);
    return language;
}
/**
 * Receives a string of the type `"Some text $0 with some variables $2 and $1."`.
 * Returns the same string with symbols expressed as "$index" replaced by the elements in the array passed in the second parameter.
 *
 * For the previous example, if the 2nd, 3rd and 4th parameters are `'hello', 'world', 'test'`, then the result is `"Some text hello with
 * some variables test and world."`
 *
 * @param template the template string to interpolate.
 * @param variables the variables to use while replacing the symbols prefixed with "$".
 * @return the interpolated string. Variables without equivalence in the array of variables will be left untouched.
 */
export function interpolate(template, ...variables) {
    return template.replaceAll(/\$(\d+)/g, (original, index) => variables[index] ?? original);
}
/**
 * Changes the configuration for the translation.
 * @param config the new configuration.
 */
export function setupTranslation(config) {
    const sup = config.supported ?? supported;
    const def = config.defaultLanguage ?? defaultLanguage;
    if (!sup.includes(def)) {
        throw new TranslationConfigError('the configuration is invalid. The default language must be supported.');
    }
    supported = sup;
    defaultLanguage = def;
    if (!supported.includes(getLanguage())) {
        setLanguage(defaultLanguage);
    }
    configChangeListeners.forEach(l => l({ supported, defaultLanguage }));
}
/**
 * Adds support for a new language. A shortcut to setupTranslation.
 *
 * @param language the new language to support.
 */
export function addLanguageSupport(language) {
    if (supported.includes(language))
        return;
    setupTranslation({ supported: [...supported, language] });
}
/**
 * Gets the list of the supported languages.
 */
export function getSupportedLanguages() {
    return supported;
}
export function useSupportedLanguages() {
    const [value, setValue] = useState(supported);
    useEffect(() => onTranslationSetup(config => setValue(config.supported)));
    return value;
}
//# sourceMappingURL=language.js.map