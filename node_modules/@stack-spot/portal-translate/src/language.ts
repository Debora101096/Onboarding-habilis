import { useEffect, useState } from 'react'
import { MissingDefaultLanguageTranslation, TranslationConfigError } from './error'
import { Dictionary, Language, OnChange, OnChangeConfig, TranslationConfig } from './types'

export const ptEn: ['pt', 'en'] = ['pt', 'en']
let supported: Language[] = ptEn
const key = 'language'
let defaultLanguage: Language = 'en'
const listeners: OnChange[] = []
const configChangeListeners: OnChangeConfig[] = []
let eventsRegistered: boolean

/**
 * Retrieves the current language. Will be the navigator language if the user didn't change this setting.
 * 
 * If you want to listen to changes on the language, use `onLanguageChange`.
 * 
 * @param allowed a list of languages allowed to be returned. If not provided, the list of supported languages is used.
 * @returns the current language.
 */
export function getLanguage<T extends Language = Language>(allowed = supported as T[]): T {
  const language = getLanguageFromCookie() as any
  if (allowed.includes(language)) return language as T
  const navigatorLanguage = navigator.language.split('-')[0] as any
  if (allowed.includes(navigatorLanguage)) return navigatorLanguage as T
  return allowed.includes(defaultLanguage as T) ? defaultLanguage as T : allowed[0]
}

/**
 * Changes the current language.
 * 
 * Once the language is changed, all registered listeners are run. To register a listener, use `onLanguageChange`.
 * 
 * @param language the new language. Must be a supported language. Call `setupTranslation` to change the supported languages.
 * @param setCookie whether or not to set the language cookie (true by default).
 * @param domain the domain to set the cookie, will be ".stackspot.com" by default.
 */
export function setLanguage(language: Language, setCookie = true, domain = '.stackspot.com') {
  if (!supported.includes(language)) {
    // eslint-disable-next-line no-console
    return console.warn('Language', language, 'not applied, because it is not supported. Supported languages are:', supported.join(', '))
  }
  if (setCookie) document.cookie = `${key}=${language};path=/${location.host.endsWith(domain) ? `;domain=${domain}` : ''}`
  listeners.forEach(l => l(language))
}

function getLanguageFromCookie() {
  return ((document.cookie.match(new RegExp(`${key}=([^;]+)`)) ?? [])[1]) as Language
}

/**
 * Loads the current language from the cookies. If no language has been set before, "en" is loaded.
 */
export function loadLanguage() {
  const language = getLanguage()
  setLanguage(language)
  if (eventsRegistered) return
  // if there's support for the cookieStore, change the theme whenever the cookie is changed.
  if ('cookieStore' in window) {
    // @ts-ignore cookieStore is not yet available on Safari and Firefox, this is why TS doesn't recognize it
    cookieStore.addEventListener('change', ({ changed }) => {
      for (const { name, value } of changed) {
        if (name === 'language' && supported.includes(value as Language)) listeners.forEach(l => l(value as Language))
      }
    })
  }
  // otherwise, change the theme when the tab/window is refocused.
  else {
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') loadLanguage()
    })
  }
  eventsRegistered = true
}

/**
 * Registers a listener for when the language changes.
 * @param listener a function to be called whenever the language changes.
 * @returns a function that, when called, removes the listener.
 */
export function onLanguageChange(listener: OnChange): () => void {
  listeners.push(listener)
  return () => {
    const index = listeners.indexOf(listener)
    if (index !== -1) listeners.splice(index, 1)
  }
}

/**
 * Registers a listener for when the configuration changes.
 * @param listener a function to be called whenever the configuration changes.
 * @returns a function that, when called, removes the listener.
 */
export function onTranslationSetup(listener: OnChangeConfig): () => void {
  configChangeListeners.push(listener)
  return () => {
    const index = configChangeListeners.indexOf(listener)
    if (index !== -1) configChangeListeners.splice(index, 1)
  }
}

/**
 * Gets the correct version of a dictionary depending on the language passed as parameter.
 * @param dictionary
 * @param language
 * @returns the english or portuguese version of the dictionary, depending on the value of `language`.
 */
export function translate<T extends Partial<Dictionary<Language>>>(
  dictionary: T,
  language: T extends Dictionary<infer R> ? R : never = getLanguage() as any,
) {
  return dictionary[language in dictionary ? language : defaultLanguage] as
    T extends Dictionary<infer L> ? Record<keyof T[L], string> : never
}

/**
 * A React Hook for getting the correct version of a dictionary depending on the current language.
 * 
 * The value returned by this is updated whenever the language changes.
 * 
 * If there are no translations for the current language, this fallbacks to the default language. To change the default language, call
 * `setupTranslation`.
 * 
 * @throws {@link MissingDefaultLanguageTranslation} if the dictionary doesn't contain the translation for the default language.
 * @param dictionary 
 * @returns the translated version of the dictionary, depending on the current language.
 */
export function useTranslate<T extends Partial<Dictionary<Language>>>(dictionary: T) {
  const language = useLanguage()
  if (!(defaultLanguage in dictionary)) {
    throw new MissingDefaultLanguageTranslation(defaultLanguage)
  }
  return translate(dictionary, language as any)
}

/**
 * A React Hook for getting the current language.
 * 
 * The value returned by this is updated whenever the language changes.
 * 
 * @param allowed a list of languages allowed to be returned. If not provided, the list of supported languages is used.
 * @returns the current language.
 */
export function useLanguage<T extends Language>(allowed?: T[]): T {
  const [language, setLanguage] = useState(getLanguage(allowed))
  useEffect(() => onLanguageChange(l => setLanguage(l as T)), [])
  return language
}

/**
 * Receives a string of the type `"Some text $0 with some variables $2 and $1."`.
 * Returns the same string with symbols expressed as "$index" replaced by the elements in the array passed in the second parameter.
 *
 * For the previous example, if the 2nd, 3rd and 4th parameters are `'hello', 'world', 'test'`, then the result is `"Some text hello with
 * some variables test and world."`
 *
 * @param template the template string to interpolate.
 * @param variables the variables to use while replacing the symbols prefixed with "$".
 * @return the interpolated string. Variables without equivalence in the array of variables will be left untouched.
 */
export function interpolate(template: string, ...variables: any[]): string {
  return template.replaceAll(/\$(\d+)/g, (original, index) => variables[index] ?? original)
}

/**
 * Changes the configuration for the translation.
 * @param config the new configuration.
 */
export function setupTranslation(config: TranslationConfig) {
  const sup = config.supported ?? supported
  const def = config.defaultLanguage ?? defaultLanguage
  if (!sup.includes(def)) {
    throw new TranslationConfigError('the configuration is invalid. The default language must be supported.')
  }
  supported = sup
  defaultLanguage = def
  if (!supported.includes(getLanguage())) {
    setLanguage(defaultLanguage)
  }
  configChangeListeners.forEach(l => l({ supported, defaultLanguage }))
}

/**
 * Adds support for a new language. A shortcut to setupTranslation.
 * 
 * @param language the new language to support.
 */
export function addLanguageSupport(language: Language) {
  if (supported.includes(language)) return
  setupTranslation({ supported: [...supported, language] })
}

/**
 * Gets the list of the supported languages.
 */
export function getSupportedLanguages(): Language[] {
  return supported
}

export function useSupportedLanguages(): Language[] {
  const [value, setValue] = useState(supported)
  useEffect(() => onTranslationSetup(config => setValue(config.supported)))
  return value
}
